#!/bin/bash
#
# /sbin/pkg_remove - remove installed Decebal Linux packages (renamed pkg_del)
#
# Copyright (C) 2003-2005 Teodor Adrian Florin <slider@decebal.org>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#

BASEDIR=$(pwd)

if [ ! "$UID" = "0" ]
then
  echo "You need root privilegies to install packages."
  exit 1
fi

CONFDIR="/etc/dpack"
FUNCTIONSDIR="/usr/share"

source $CONFDIR/common
source $FUNCTIONSDIR/dpack/pkg
source $FUNCTIONSDIR/dpack/depend
source $FUNCTIONSDIR/dpack/msg
source $FUNCTIONSDIR/dpack/tmp
source $FUNCTIONSDIR/dpack/exec
source $FUNCTIONSDIR/dpack/exit
source $FUNCTIONSDIR/dpack/log

usage() {
  cat << EOF
usage: pkg_del [options] <package>
options:
  -b, --nobackups   - remove backup files as well
  -d, --nodeps      - skip dependencies checks (dangerous)
  -p, --pretend     - only show actions (dont execute them)
  -P, --preserve    - move package contents to preserve dir
  -r, --root <root> - use alternative remove path
  -v, --verbose     - be more verbose
  -V, --version     - print name, version and license
  -h, --help        - print this message and exit
EOF
}

version() {
  cat << EOF
pkg_remove v0.0.2 (dpack v0.1.6)
  
Copyright (C) 2003-2005 Teodor Adrian Florin <slider@decebal.org>
  
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.
  
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
  
You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
EOF
}
  

PKG_NOBACKUPS=0
PKG_NODEPS=0
PKG_PRETEND=0
PKG_PRESERVE=0
PKG_VERBOSE=0

PKG_ROOT=""
PKG_ARGS=""

if [ $# -eq 0 ]
then
  echo "error: pkd_remove needs an argument (package)." >&2
  usage >&2
  exit 1
fi

while [ $# -ne 0 ]
do
  case "$1" in
    --nobackups) PKG_NOBACKUPS=1 ;;
    --nodeps)    PKG_NODEPS=1    ;;
    --pretend)   PKG_PRETEND=1   ;;
    --preserve)  PKG_PRESERVE=1  ;;
    --verbose)   PKG_VERBOSE=1   ;;
    --root)
      PKG_ROOT="$2"
      shift 1
      ;;
    --verbose)
      version
      exit 0
      ;;
    --help)
      usage
      exit 0
      ;;
    --*)
      echo "error: unrecongnized option." >&2
      usage >&2
      pkg_exit "main()" "unrecognized option (--*)" "$LINENO" 1
      ;;
    -*)
      while getopts "bdpPvVhr:-" OPT
      do
        case "$OPT" in
	  b) PKG_NOBACKUPS=1 ;;
	  d) PKG_NODEPS=1    ;;
	  p) PKG_PRETEND=1   ;;
	  P) PKG_PRESERVE=1  ;;
	  v) PKG_VERBOSE=1   ;;
	  V)
	    version
	    exit 0
	    ;;
	  h)
	    usage
	    exit 0
	    ;;
	  r)
	    PKG_ROOT="$OPTARG"
	    shift 1
	    ;;
	  -)
	    OPTBIND=0
	    break
	    ;;
	  *)
	    usage >&2
            pkg_exit "main()" "unrecognized option (--*)" "$LINENO" 1
            ;;
	esac
      done
      ;;
    *)
      PKG_ARGS="$1"
      shift 1
      while [ -n "$1" ]
      do
        PKG_ARGS="$PKG_ARGS $1"
        shift 1
      done
      ;;
  esac
  shift 1
done

if [ "$PKG_ARGS" = "" ]
then
  echo "error: pkg_remove needs an argument <package>" >&2
  usage >&2
  pkg_exit "main()" "no <package> argument" "$LINENO" 1
fi

check_dir_contents() {
  if [ -z "$(ls $1 2>/dev/null)" ]
  then
    return 0
  else
    return 1
  fi
}

pkg_remove_file() {
  if [ "$PKG_PRESERVE" = "1" ]
  then
    echo "       preserving: $1"
    mv $1 ${PKG_ROOT}${DATABASEDIR}/preserve/${IPKG}${1}
  else
    if [ "$PKG_VERBOSE" = "1" ]
    then
      echo "        $1"
    fi
    rm -f $1
  fi
}

pkg_remove_dir() {
  if [ -d $PKG_ROOT/$1 ]
  then
    if check_dir_contents $PKG_ROOT/$1
    then
      if [ "$PKG_VERBOSE" = "1" ]
      then
        echo "        ${PKG_ROOT}/$1"
      fi
      rm -rf $PKG_ROOT/$1
    fi
  fi
}

pkg_preserve() {
  [ "$PKG_PRESERVE" = "1" ] || return 0
  for DIR in ${FILES[@]}
  do
    if [ -d $PKG_ROOT/$DIR ]
    then
      mkdir -p ${PKG_ROOT}${DATABASEDIR}/preserve/${IPKG}/${DIR}
    fi
  done
}

pkg_remove() {
  local PKGNAME=$(pkgname $1)
  
  if ! pkg_is_installed $PKGNAME
  then
    echo "package '$PKGNAME' is not installed." >&2
    pkg_exit "pkg_remove()" "check_if_package_is_installed" "$LINENO" 2
  fi
  
  local IPKG=$(get_installed_pkg $PKGNAME)
  
  if ! source ${PKG_ROOT}${DATABASEDIR}/db/$IPKG 2>/dev/null
  then
    msg_error "package database entry not found (database error)."
    pkg_exit "pkg_remove()" "get_package_database_entry" "$LINENO" 1
  fi
  
  msg_start_nnl "removing $PKGNAME..."
  
  pkg_create_tmp
  
  if [ ! "$PKG_NODEPS" = "1" ]
  then
    msg_verbose_nnl "checking dependencies..."
    if [ -n "$REQUIRED" ]
    then
      local REQUIREDPACKAGES=""
      for PKG in ${REQUIRED[@]}
      do
        if pkg_is_installed $PKG
	then
	  REQUIREDPACKAGES="$REQUIREDPACKAGES $PKG"
	fi
      done
      unset REQUIRED
      if [ -n "$REQUIREDPACKAGES" ]
      then
        msg_failed_verbose
	msg_failed
	msg_error "package that depend on this package: " >&2
	for PKG in $REQUIREDPACKAGES
	do
	  echo -e "\t $PKG" >&2
	done
	pkg_exit "pkg_remove()" "check_package_dependencies" "$LINENO" 1
      fi
    fi
    msg_ok_verbose
  fi
  
  pkg_exec pre_remove
  
  if [ ! "$PKG_NOBACKUPS" = "1" ]
  then
    local RETVAL=0
    msg_verbose_nnl "saving backup files..."
    for BACKUP in ${BACKUPS[@]}
    do
      if [ -f $PKG_ROOT/$BACKUP ]
      then
        mv -f $PKG_ROOT/$BACKUP $PKG_ROOT/${BACKUP}.pkgbackup
	RETVAL=$(($RETVAL + $?))
      fi
    done
    if [ $RETVAL -eq 0 ]
    then
      msg_done_verbose
    else
      msg_failed_verbose
    fi
  fi
  
  msg_verbose "removing files..." && echo
  
  pkg_preserve $IPKG
  
  for FILE in ${FILES[@]}
  do
    if [ -e $PKG_ROOT/$FILE -o -h $PKG_ROOT/$FILE ] && [ ! -d $PKG_ROOT/$FILE ]
    then
      pkg_remove_file $PKG_ROOT/$FILE
    fi
  done
    
  local COUNTER=0
  while [ $COUNTER -ne 10 ]
  do
    for DIR in ${FILES[@]}
    do
      pkg_remove_dir $DIR
    done
    COUNTER=$(($COUNTER + 1))
  done
  
  pkg_exec post_remove
  
  msg_verbose_nnl "removing database entry..."
  if [ -r ${PKG_ROOT}${DATABASEDIR}/db/$IPKG ]
  then
    . ${PKG_ROOT}${DATABASEDIR}/db/$IPKG 2>/dev/null
    
    if [ -n "$PROVIDES" ]
    then
      for PROVIDE in ${PROVIDES[@]}
      do
        if [ -h ${PKG_ROOT}${DATABASEDIR}/virtual/$PROVIDE ]
	then
	  rm -f ${PKG_ROOT}${DATABASEDIR}/virtual/$PROVIDE
	fi
      done
    fi
    
    if [ -n "$DEPENDS" ]
    then
      for DEP in ${DEPENDS[@]}
      do
        local DNAME="$(get_dep_name $DEP)"
	if [ -n "$DNAME" ]
	then
          if pkg_is_installed $DNAME
	  then
	    local DIPKG=$(get_installed_pkg $DNAME)
	    local INDEX=0
	    if [ -n "$DIPKG" ]
	    then
	      cp ${PKG_ROOT}${DATABASEDIR}/db/$DIPKG $TMP/$DIPKG
	      grep -vE "^REQUIRED\[[[:digit:]]*\]=" $TMP/$DIPKG > ${PKG_ROOT}${DATABASEDIR}/db/$DIPKG
	      echo >> ${PKG_ROOT}${DATABASEDIR}/db/$DIPKG
	      
	      . $TMP/$DIPKG 2>/dev/null
	      for REQ in ${REQUIRED[@]}
	      do
	        if [ ! "$PKGNAME" = "$REQ" ]
		then
		  echo "REQUIRED[$INDEX]=\"$REQ\"" >> ${PKG_ROOT}${DATABASEDIR}/db/$DIPKG
		  INDEX=$(($INDEX + 1))
		fi
	      done
	      unset NAME VERSION ARCH RELEASE URL DESC GROUP INSTALLDATE BUILDDATE \
	        LICENSE CSIZE USIZE FILES BACKUPS DEPENDS CONFLICTS REPLACES PROVIDES
	      unset -f pre_install post_install pre_upgrade post_upgrade \
	        pre_remove post_remove
	    fi
	  fi
	fi
      done
    fi
    	      	  
    rm -f ${PKG_ROOT}${DATABASEDIR}/db/$IPKG
    msg_done_verbose
  fi
  
  unset NAME VERSION ARCH RELEASE URL DESC GROUP LICENSE USIZE \
    CSIZE MAINTAINER FILES DEPENDS CONFLICTS PROVIDES REPLACES \
    FILES REQUIRED USEFLAGS BUILDDATE INSTALLDATE SIZE BACKUPS
  
  pkg_log "removed $1"
  pkg_remove_tmp
  msg_ok
}

for ARG in $PKG_ARGS
do
  pkg_remove $ARG
done

cd $BASEDIR

exit 0
