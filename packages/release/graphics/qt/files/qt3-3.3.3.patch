diff -Nru qt-x11-free-3.3.3.orig/config.tests/x11/xfreetype.test qt-x11-free-3.3.3/config.tests/x11/xfreetype.test
--- qt-x11-free-3.3.3.orig/config.tests/x11/xfreetype.test	2004-08-22 13:20:59.513560269 +0200
+++ qt-x11-free-3.3.3/config.tests/x11/xfreetype.test	2004-08-22 13:24:47.213516598 +0200
@@ -56,7 +56,7 @@
     XFT=no
     [ "$VERBOSE" = "yes" ] && echo "  Could not find Xft lib anywhere in $LIBDIRS"
 fi
-LIBXFT="-l$F -lfreetype"
+LIBXFT="-l$F -lfontconfig -lexpat -lfreetype"
 
 # check for X11/Xft/Xft.h
 XFT_H=
@@ -90,7 +90,7 @@
     [ "$VERBOSE" = "yes" ] && echo "  Found Xft version $XFT_MAJOR.$XFT_MINOR.$XFT_REVISION"
     if [ "$XFT_MAJOR" = "2" ]; then
         XFT2=yes
-	LIBXFT="$LIBXFT -lfontconfig"
+	LIBXFT="$LIBXFT"
     fi
 fi
 
diff -Nru qt-x11-free-3.3.3.orig/configure qt-x11-free-3.3.3/configure
--- qt-x11-free-3.3.3.orig/configure	2004-08-22 13:20:59.509561026 +0200
+++ qt-x11-free-3.3.3/configure	2004-08-22 13:24:47.212516787 +0200
@@ -1782,21 +1782,6 @@
 	    CFG_FREETYPE=yes
 	fi
     fi
-    # add freetype2 include path
-    if [ "$CFG_FREETYPE" = "yes" ] && [ -f $outpath/config.tests/x11/xft.inc ];then
-	QMAKE_VARS="$QMAKE_VARS \"INCLUDEPATH+=`cat $outpath/config.tests/x11/xft.inc`\""
-    fi
-    rm -f $outpath/config.tests/x11/xft.inc
-    # add Xft specific libraries
-    if [ "$CFG_FREETYPE" = "yes" ] && [ -f $outpath/config.tests/x11/xft.lib ]; then
-	QMAKE_VARS="$QMAKE_VARS \"QMAKE_LIBS_X11=`cat $outpath/config.tests/x11/xft.lib` \$\$QMAKE_LIBS_X11\""
-    fi
-    rm -f $outpath/config.tests/x11/xft.lib
-    # add Xft specific config options
-    if [ "$CFG_FREETYPE" = "yes" ] && [ -f $outpath/config.tests/x11/xft.cfg ]; then
-	QMAKE_CONFIG="$QMAKE_CONFIG `cat $outpath/config.tests/x11/xft.cfg`"
-    fi
-    rm -f $outpath/config.tests/x11/xft.cfg
     # auto-detect Session Management support
     if [ "$CFG_SM" = "auto" ]; then
 	if $x11tests/sm.test $XQMAKESPEC $OPT_VERBOSE $L_FLAGS $I_FLAGS; then
@@ -2926,6 +2911,21 @@
     if [ "$CFG_XKB" = "yes" ]; then
         QMAKE_CONFIG="$QMAKE_CONFIG xkb"
     fi
+    # add freetype2 include path
+    if [ "$CFG_FREETYPE" = "yes" ] && [ -f $outpath/config.tests/x11/xft.inc ];then
+	QMAKE_VARS="$QMAKE_VARS \"INCLUDEPATH+=`cat $outpath/config.tests/x11/xft.inc`\""
+    fi
+    rm -f $outpath/config.tests/x11/xft.inc
+    # add Xft specific libraries
+    if [ "$CFG_FREETYPE" = "yes" ] && [ -f $outpath/config.tests/x11/xft.lib ]; then
+	QMAKE_VARS="$QMAKE_VARS \"QMAKE_LIBS_X11=`cat $outpath/config.tests/x11/xft.lib` \$\$QMAKE_LIBS_X11\""
+    fi
+    rm -f $outpath/config.tests/x11/xft.lib
+    # add Xft specific config options
+    if [ "$CFG_FREETYPE" = "yes" ] && [ -f $outpath/config.tests/x11/xft.cfg ]; then
+	QMAKE_CONFIG="$QMAKE_CONFIG `cat $outpath/config.tests/x11/xft.cfg`"
+    fi
+    rm -f $outpath/config.tests/x11/xft.cfg
 elif [ "$PLATFORM_MAC" = "yes" ]; then
     if [ "$CFG_TABLET" = "yes" ]; then
 	QMAKE_CONFIG="$QMAKE_CONFIG tablet"
diff -Nru qt-x11-free-3.3.3.orig/include/qdragobject.h qt-x11-free-3.3.3/include/qdragobject.h
--- qt-x11-free-3.3.3.orig/include/qdragobject.h	2004-08-22 13:20:57.260986749 +0200
+++ qt-x11-free-3.3.3/include/qdragobject.h	2004-08-22 13:22:29.657504419 +0200
@@ -245,10 +245,11 @@
     void move( const QPoint & );
     void drop();
     void updatePixmap();
+    void updatePixmap( const QPoint& cursorPos );
 
 private:
     QDragObject * object;
-    void updateMode( ButtonState newstate );
+    bool updateMode( ButtonState newstate );
     void updateCursor();
 
     QWidget * dragSource;
diff -Nru qt-x11-free-3.3.3.orig/include/qiconview.h qt-x11-free-3.3.3/include/qiconview.h
--- qt-x11-free-3.3.3.orig/include/qiconview.h	2004-08-22 13:20:57.132011168 +0200
+++ qt-x11-free-3.3.3/include/qiconview.h	2004-08-22 13:23:59.931444409 +0200
@@ -496,6 +496,8 @@
 			const QPoint &relativeTo,
 			const QIconViewItem *item ) const;
     QBitmap mask( QPixmap *pix ) const;
+    int visibleWidthSB() const;
+    int visibleHeightSB() const;
 
     QIconViewPrivate *d;
 
diff -Nru qt-x11-free-3.3.3.orig/include/qprogressbar.h qt-x11-free-3.3.3/include/qprogressbar.h
--- qt-x11-free-3.3.3.orig/include/qprogressbar.h	2004-08-22 13:20:57.524936774 +0200
+++ qt-x11-free-3.3.3/include/qprogressbar.h	2004-08-22 13:23:33.151503266 +0200
@@ -61,6 +61,7 @@
 public:
     QProgressBar( QWidget* parent=0, const char* name=0, WFlags f=0 );
     QProgressBar( int totalSteps, QWidget* parent=0, const char* name=0, WFlags f=0 );
+    virtual ~QProgressBar();
 
     int		totalSteps() const;
     int		progress()   const;
@@ -91,6 +92,7 @@
     virtual bool setIndicator( QString & progress_str, int progress,
 			       int totalSteps );
     void styleChange( QStyle& );
+    bool	requireRepaint( int newProgress ) const;
 
 private:
     int		total_steps;
diff -Nru qt-x11-free-3.3.3.orig/include/qvaluelist.h qt-x11-free-3.3.3/include/qvaluelist.h
--- qt-x11-free-3.3.3.orig/include/qvaluelist.h	2004-08-22 13:20:56.017222236 +0200
+++ qt-x11-free-3.3.3/include/qvaluelist.h	2004-08-22 13:23:26.717718888 +0200
@@ -636,13 +636,11 @@
     l.clear();
     Q_UINT32 c;
     s >> c;
-    for( Q_UINT32 i = 0; i < c; ++i )
+    for( Q_UINT32 i = 0; i < c && !s.atEnd(); ++i )
     {
 	T t;
 	s >> t;
 	l.append( t );
-	if ( s.atEnd() )
-	    break;
     }
     return s;
 }
diff -Nru qt-x11-free-3.3.3.orig/mkspecs/linux-g++/qplatformdefs.h qt-x11-free-3.3.3/mkspecs/linux-g++/qplatformdefs.h
--- qt-x11-free-3.3.3.orig/mkspecs/linux-g++/qplatformdefs.h	2004-08-22 13:21:00.611352430 +0200
+++ qt-x11-free-3.3.3/mkspecs/linux-g++/qplatformdefs.h	2004-08-22 13:22:38.978741970 +0200
@@ -102,5 +102,6 @@
 #define QT_VSNPRINTF		::vsnprintf
 #endif
 
+#define QT_MITSHM
 
 #endif // QPLATFORMDEFS_H
diff -Nru qt-x11-free-3.3.3.orig/src/3rdparty/libpng/png.h qt-x11-free-3.3.3/src/3rdparty/libpng/png.h
--- qt-x11-free-3.3.3.orig/src/3rdparty/libpng/png.h	2004-08-22 13:20:57.409958544 +0200
+++ qt-x11-free-3.3.3/src/3rdparty/libpng/png.h	2004-08-22 13:24:47.272505463 +0200
@@ -833,7 +833,14 @@
 typedef png_info FAR * FAR * png_infopp;
 
 /* Maximum positive integer used in PNG is (2^31)-1 */
-#define PNG_MAX_UINT ((png_uint_32)0x7fffffffL)
+#define PNG_UINT_31_MAX ((png_uint_32)0x7fffffffL)
+#define PNG_UINT_32_MAX (~((png_uint_32)0))
+#define PNG_SIZE_MAX (~((png_size_t)0))
+/* PNG_MAX_UINT is deprecated; use PNG_UINT_31_MAX instead. */
+#define PNG_MAX_UINT PNG_UINT_31_MAX
+
+/* Constraints on width, height, (2 ^ 24) - 1*/
+#define PNG_MAX_DIMENSION 16777215
 
 /* These describe the color_type field in png_info. */
 /* color type masks */
@@ -2655,6 +2662,8 @@
 PNG_EXTERN png_uint_32 png_get_uint_32 PNGARG((png_bytep buf));
 PNG_EXTERN png_uint_16 png_get_uint_16 PNGARG((png_bytep buf));
 #endif /* !PNG_READ_BIG_ENDIAN_SUPPORTED */
+PNG_EXTERN png_uint_32 png_get_uint_31 PNGARG((png_structp png_ptr,
+  png_bytep buf));
 
 /* Initialize png_ptr struct for reading, and allocate any other memory.
  * (old interface - DEPRECATED - use png_create_read_struct instead).
diff -Nru qt-x11-free-3.3.3.orig/src/3rdparty/libpng/pngconf.h qt-x11-free-3.3.3/src/3rdparty/libpng/pngconf.h
--- qt-x11-free-3.3.3.orig/src/3rdparty/libpng/pngconf.h	2004-08-22 13:20:57.398960626 +0200
+++ qt-x11-free-3.3.3/src/3rdparty/libpng/pngconf.h	2004-08-22 13:24:47.215516221 +0200
@@ -251,10 +251,6 @@
 #      define PNG_SAVE_BSD_SOURCE
 #      undef _BSD_SOURCE
 #    endif
-#    ifdef _SETJMP_H
-      __png.h__ already includes setjmp.h;
-      __dont__ include it again.;
-#    endif
 #  endif /* __linux__ */
 
    /* include setjmp.h for error handling */
diff -Nru qt-x11-free-3.3.3.orig/src/3rdparty/libpng/pngerror.c qt-x11-free-3.3.3/src/3rdparty/libpng/pngerror.c
--- qt-x11-free-3.3.3.orig/src/3rdparty/libpng/pngerror.c	2004-08-22 13:20:57.436953433 +0200
+++ qt-x11-free-3.3.3/src/3rdparty/libpng/pngerror.c	2004-08-22 13:24:47.216516032 +0200
@@ -135,10 +135,13 @@
       buffer[iout] = 0;
    else
    {
+      png_size_t len;
+      if ((len = png_strlen(error_message)) > 63)
+          len = 63;
       buffer[iout++] = ':';
       buffer[iout++] = ' ';
-      png_memcpy(buffer+iout, error_message, 64);
-      buffer[iout+63] = 0;
+      png_memcpy(buffer+iout, error_message, len);
+      buffer[iout+len] = 0;
    }
 }
 
diff -Nru qt-x11-free-3.3.3.orig/src/3rdparty/libpng/pngpread.c qt-x11-free-3.3.3/src/3rdparty/libpng/pngpread.c
--- qt-x11-free-3.3.3.orig/src/3rdparty/libpng/pngpread.c	2004-08-22 13:20:57.421956272 +0200
+++ qt-x11-free-3.3.3/src/3rdparty/libpng/pngpread.c	2004-08-22 13:24:47.248509993 +0200
@@ -208,7 +208,7 @@
       }
 
       png_push_fill_buffer(png_ptr, chunk_length, 4);
-      png_ptr->push_length = png_get_uint_32(chunk_length);
+      png_ptr->push_length = png_get_uint_31(png_ptr,chunk_length);
       png_reset_crc(png_ptr);
       png_crc_read(png_ptr, png_ptr->chunk_name, 4);
       png_ptr->mode |= PNG_HAVE_CHUNK_HEADER;
@@ -591,6 +591,11 @@
       png_size_t new_max;
       png_bytep old_buffer;
 
+      if (png_ptr->save_buffer_size > PNG_SIZE_MAX - 
+         (png_ptr->current_buffer_size + 256))
+      {
+        png_error(png_ptr, "Potential overflow of save_buffer");
+      }
       new_max = png_ptr->save_buffer_size + png_ptr->current_buffer_size + 256;
       old_buffer = png_ptr->save_buffer;
       png_ptr->save_buffer = (png_bytep)png_malloc(png_ptr,
@@ -637,8 +642,7 @@
       }
 
       png_push_fill_buffer(png_ptr, chunk_length, 4);
-      png_ptr->push_length = png_get_uint_32(chunk_length);
-
+      png_ptr->push_length = png_get_uint_31(png_ptr,chunk_length);
       png_reset_crc(png_ptr);
       png_crc_read(png_ptr, png_ptr->chunk_name, 4);
       png_ptr->mode |= PNG_HAVE_CHUNK_HEADER;
diff -Nru qt-x11-free-3.3.3.orig/src/3rdparty/libpng/pngread.c qt-x11-free-3.3.3/src/3rdparty/libpng/pngread.c
--- qt-x11-free-3.3.3.orig/src/3rdparty/libpng/pngread.c	2004-08-22 13:20:57.418956840 +0200
+++ qt-x11-free-3.3.3/src/3rdparty/libpng/pngread.c	2004-08-22 13:24:47.253509049 +0200
@@ -384,7 +384,7 @@
       png_uint_32 length;
 
       png_read_data(png_ptr, chunk_length, 4);
-      length = png_get_uint_32(chunk_length);
+      length = png_get_uint_31(png_ptr,chunk_length);
 
       png_reset_crc(png_ptr);
       png_crc_read(png_ptr, png_ptr->chunk_name, 4);
@@ -392,9 +392,6 @@
       png_debug2(0, "Reading %s chunk, length=%lu.\n", png_ptr->chunk_name,
          length);
 
-      if (length > PNG_MAX_UINT)
-         png_error(png_ptr, "Invalid chunk length.");
-
       /* This should be a binary subdivision search or a hash for
        * matching the chunk name rather than a linear search.
        */
@@ -673,10 +670,7 @@
             png_crc_finish(png_ptr, 0);
 
             png_read_data(png_ptr, chunk_length, 4);
-            png_ptr->idat_size = png_get_uint_32(chunk_length);
-
-            if (png_ptr->idat_size > PNG_MAX_UINT)
-              png_error(png_ptr, "Invalid chunk length.");
+            png_ptr->idat_size = png_get_uint_31(png_ptr,chunk_length);
 
             png_reset_crc(png_ptr);
             png_crc_read(png_ptr, png_ptr->chunk_name, 4);
@@ -946,16 +940,13 @@
 #endif /* PNG_GLOBAL_ARRAYS */
 
       png_read_data(png_ptr, chunk_length, 4);
-      length = png_get_uint_32(chunk_length);
+      length = png_get_uint_31(png_ptr,chunk_length);
 
       png_reset_crc(png_ptr);
       png_crc_read(png_ptr, png_ptr->chunk_name, 4);
 
       png_debug1(0, "Reading %s chunk.\n", png_ptr->chunk_name);
 
-      if (length > PNG_MAX_UINT)
-         png_error(png_ptr, "Invalid chunk length.");
-
       if (!png_memcmp(png_ptr->chunk_name, png_IHDR, 4))
          png_handle_IHDR(png_ptr, info_ptr, length);
       else if (!png_memcmp(png_ptr->chunk_name, png_IEND, 4))
@@ -1299,6 +1290,9 @@
     */
    png_read_info(png_ptr, info_ptr);
 
+   if (info_ptr->height > PNG_UINT_32_MAX/sizeof(png_bytep))
+      png_error(png_ptr,"Image is too high to process with png_read_png()");
+
    /* -------------- image transformations start here ------------------- */
 
 #if defined(PNG_READ_16_TO_8_SUPPORTED)
diff -Nru qt-x11-free-3.3.3.orig/src/3rdparty/libpng/pngrtran.c qt-x11-free-3.3.3/src/3rdparty/libpng/pngrtran.c
--- qt-x11-free-3.3.3.orig/src/3rdparty/libpng/pngrtran.c	2004-08-22 13:20:57.435953622 +0200
+++ qt-x11-free-3.3.3/src/3rdparty/libpng/pngrtran.c	2004-08-22 13:24:47.221515088 +0200
@@ -1889,8 +1889,8 @@
          /* This changes the data from GG to GGXX */
          if (flags & PNG_FLAG_FILLER_AFTER)
          {
-            png_bytep sp = row + (png_size_t)row_width;
-            png_bytep dp = sp  + (png_size_t)row_width;
+            png_bytep sp = row + (png_size_t)row_width * 2;
+            png_bytep dp = sp  + (png_size_t)row_width * 2;
             for (i = 1; i < row_width; i++)
             {
                *(--dp) = hi_filler;
@@ -1907,8 +1907,8 @@
          /* This changes the data from GG to XXGG */
          else
          {
-            png_bytep sp = row + (png_size_t)row_width;
-            png_bytep dp = sp  + (png_size_t)row_width;
+            png_bytep sp = row + (png_size_t)row_width * 2;
+            png_bytep dp = sp  + (png_size_t)row_width * 2;
             for (i = 0; i < row_width; i++)
             {
                *(--dp) = *(--sp);
@@ -1965,8 +1965,8 @@
          /* This changes the data from RRGGBB to RRGGBBXX */
          if (flags & PNG_FLAG_FILLER_AFTER)
          {
-            png_bytep sp = row + (png_size_t)row_width * 3;
-            png_bytep dp = sp  + (png_size_t)row_width;
+            png_bytep sp = row + (png_size_t)row_width * 6;
+            png_bytep dp = sp  + (png_size_t)row_width * 2;
             for (i = 1; i < row_width; i++)
             {
                *(--dp) = hi_filler;
@@ -1987,8 +1987,8 @@
          /* This changes the data from RRGGBB to XXRRGGBB */
          else
          {
-            png_bytep sp = row + (png_size_t)row_width * 3;
-            png_bytep dp = sp  + (png_size_t)row_width;
+            png_bytep sp = row + (png_size_t)row_width * 6;
+            png_bytep dp = sp  + (png_size_t)row_width * 2;
             for (i = 0; i < row_width; i++)
             {
                *(--dp) = *(--sp);
diff -Nru qt-x11-free-3.3.3.orig/src/3rdparty/libpng/pngrutil.c qt-x11-free-3.3.3/src/3rdparty/libpng/pngrutil.c
--- qt-x11-free-3.3.3.orig/src/3rdparty/libpng/pngrutil.c	2004-08-22 13:20:57.436953433 +0200
+++ qt-x11-free-3.3.3/src/3rdparty/libpng/pngrutil.c	2004-08-22 13:24:47.276504708 +0200
@@ -38,6 +38,14 @@
 #  endif
 #endif
 
+png_uint_32 /* PRIVATE */
+png_get_uint_31(png_structp png_ptr, png_bytep buf)
+{
+   png_uint_32 i = png_get_uint_32(buf);
+   if (i > PNG_UINT_31_MAX)
+     png_error(png_ptr, "PNG unsigned integer out of range.\n");
+   return (i);
+}
 #ifndef PNG_READ_BIG_ENDIAN_SUPPORTED
 /* Grab an unsigned 32-bit integer from a buffer in big-endian format. */
 png_uint_32 /* PRIVATE */
@@ -347,7 +355,11 @@
    png_crc_finish(png_ptr, 0);
 
    width = png_get_uint_32(buf);
+   if (width > PNG_MAX_DIMENSION)
+      png_error(png_ptr, "Width is too large");
    height = png_get_uint_32(buf + 4);
+   if (height > PNG_MAX_DIMENSION)
+      png_error(png_ptr, "Height is too large");
    bit_depth = buf[8];
    color_type = buf[9];
    compression_type = buf[10];
@@ -579,7 +591,7 @@
       /* Should be an error, but we can cope with it */
       png_warning(png_ptr, "Out of place gAMA chunk");
 
-   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_gAMA)
+   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_gAMA)
 #if defined(PNG_READ_sRGB_SUPPORTED)
       && !(info_ptr->valid & PNG_INFO_sRGB)
 #endif
@@ -660,7 +672,7 @@
       /* Should be an error, but we can cope with it */
       png_warning(png_ptr, "Out of place sBIT chunk");
    }
-   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sBIT))
+   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sBIT))
    {
       png_warning(png_ptr, "Duplicate sBIT chunk");
       png_crc_finish(png_ptr, length);
@@ -672,7 +684,7 @@
    else
       truelen = (png_size_t)png_ptr->channels;
 
-   if (length != truelen)
+   if (length != truelen || length > 4)
    {
       png_warning(png_ptr, "Incorrect sBIT chunk length");
       png_crc_finish(png_ptr, length);
@@ -729,7 +741,7 @@
       /* Should be an error, but we can cope with it */
       png_warning(png_ptr, "Missing PLTE before cHRM");
 
-   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_cHRM)
+   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_cHRM)
 #if defined(PNG_READ_sRGB_SUPPORTED)
       && !(info_ptr->valid & PNG_INFO_sRGB)
 #endif
@@ -891,7 +903,7 @@
       /* Should be an error, but we can cope with it */
       png_warning(png_ptr, "Out of place sRGB chunk");
 
-   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sRGB))
+   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sRGB))
    {
       png_warning(png_ptr, "Duplicate sRGB chunk");
       png_crc_finish(png_ptr, length);
@@ -977,8 +989,7 @@
    png_bytep pC;
    png_charp profile;
    png_uint_32 skip = 0;
-   png_uint_32 profile_size = 0;
-   png_uint_32 profile_length = 0;
+   png_uint_32 profile_size, profile_length;
    png_size_t slength, prefix_length, data_length;
 
    png_debug(1, "in png_handle_iCCP\n");
@@ -995,7 +1006,7 @@
       /* Should be an error, but we can cope with it */
       png_warning(png_ptr, "Out of place iCCP chunk");
 
-   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_iCCP))
+   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_iCCP))
    {
       png_warning(png_ptr, "Duplicate iCCP chunk");
       png_crc_finish(png_ptr, length);
@@ -1154,8 +1165,18 @@
    }
 
    new_palette.nentries = data_length / entry_size;
-   new_palette.entries = (png_sPLT_entryp)png_malloc(
+   if (new_palette.nentries > PNG_SIZE_MAX / sizeof(png_sPLT_entry))
+   {
+       png_warning(png_ptr, "sPLT chunk too long");
+       return;
+   }
+   new_palette.entries = (png_sPLT_entryp)png_malloc_warn(
        png_ptr, new_palette.nentries * sizeof(png_sPLT_entry));
+   if (new_palette.entries == NULL)
+   {
+       png_warning(png_ptr, "sPLT chunk requires too much memory");
+       return;
+   }
 
 #ifndef PNG_NO_POINTER_INDEXING
    for (i = 0; i < new_palette.nentries; i++)
@@ -1241,7 +1262,8 @@
          /* Should be an error, but we can cope with it */
          png_warning(png_ptr, "Missing PLTE before tRNS");
       }
-      if (length > (png_uint_32)png_ptr->num_palette)
+      if (length > (png_uint_32)png_ptr->num_palette ||
+          length > PNG_MAX_PALETTE_LENGTH)
       {
          png_warning(png_ptr, "Incorrect tRNS chunk length");
          png_crc_finish(png_ptr, length);
@@ -1397,7 +1419,7 @@
 void /* PRIVATE */
 png_handle_hIST(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
 {
-   int num, i;
+   unsigned int num, i;
    png_uint_16 readbuf[PNG_MAX_PALETTE_LENGTH];
 
    png_debug(1, "in png_handle_hIST\n");
@@ -1423,8 +1445,8 @@
       return;
    }
 
-   num = (int)length / 2 ;
-   if (num != png_ptr->num_palette)
+   num = length / 2 ;
+   if (num != png_ptr->num_palette || num > PNG_MAX_PALETTE_LENGTH)
    {
       png_warning(png_ptr, "Incorrect hIST chunk length");
       png_crc_finish(png_ptr, length);
@@ -2865,6 +2887,9 @@
                png_read_data(png_ptr, chunk_length, 4);
                png_ptr->idat_size = png_get_uint_32(chunk_length);
 
+               if (png_ptr->idat_size > PNG_MAX_UINT)
+                  png_error(png_ptr, "Invalid chunk length.");
+
                png_reset_crc(png_ptr);
                png_crc_read(png_ptr, png_ptr->chunk_name, 4);
                if (png_memcmp(png_ptr->chunk_name, (png_bytep)png_IDAT, 4))
diff -Nru qt-x11-free-3.3.3.orig/src/3rdparty/libpng/pngrutil.c~ qt-x11-free-3.3.3/src/3rdparty/libpng/pngrutil.c~
--- qt-x11-free-3.3.3.orig/src/3rdparty/libpng/pngrutil.c~	1970-01-01 01:00:00.000000000 +0100
+++ qt-x11-free-3.3.3/src/3rdparty/libpng/pngrutil.c~	2004-08-22 13:24:47.258508105 +0200
@@ -0,0 +1,3120 @@
+
+/* pngrutil.c - utilities to read a PNG file
+ *
+ * libpng 1.2.5 - October 3, 2002
+ * For conditions of distribution and use, see copyright notice in png.h
+ * Copyright (c) 1998-2002 Glenn Randers-Pehrson
+ * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
+ * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
+ *
+ * This file contains routines that are only called from within
+ * libpng itself during the course of reading an image.
+ */
+
+#define PNG_INTERNAL
+#include "png.h"
+
+#if 0 && defined(_WIN32_WCE)
+/* strtod() function is not supported on WindowsCE */
+#  ifdef PNG_FLOATING_POINT_SUPPORTED
+__inline double strtod(const char *nptr, char **endptr)
+{
+   double result = 0;
+   int len;
+   wchar_t *str, *end;
+
+   len = MultiByteToWideChar(CP_ACP, 0, nptr, -1, NULL, 0);
+   str = (wchar_t *)malloc(len * sizeof(wchar_t));
+   if ( NULL != str )
+   {
+      MultiByteToWideChar(CP_ACP, 0, nptr, -1, str, len);
+      result = wcstod(str, &end);
+      len = WideCharToMultiByte(CP_ACP, 0, end, -1, NULL, 0, NULL, NULL);
+      *endptr = (char *)nptr + (png_strlen(nptr) - len + 1);
+      free(str);
+   }
+   return result;
+}
+#  endif
+#endif
+
+png_uint_32 /* PRIVATE */
+png_get_uint_31(png_structp png_ptr, png_bytep buf)
+{
+   png_uint_32 i = png_get_uint_32(buf);
+   if (i > PNG_UINT_31_MAX)
+     png_error(png_ptr, "PNG unsigned integer out of range.\n");
+   return (i);
+}
+#ifndef PNG_READ_BIG_ENDIAN_SUPPORTED
+/* Grab an unsigned 32-bit integer from a buffer in big-endian format. */
+png_uint_32 /* PRIVATE */
+png_get_uint_32(png_bytep buf)
+{
+   png_uint_32 i = ((png_uint_32)(*buf) << 24) +
+      ((png_uint_32)(*(buf + 1)) << 16) +
+      ((png_uint_32)(*(buf + 2)) << 8) +
+      (png_uint_32)(*(buf + 3));
+
+   return (i);
+}
+
+#if defined(PNG_READ_pCAL_SUPPORTED) || defined(PNG_READ_oFFs_SUPPORTED)
+/* Grab a signed 32-bit integer from a buffer in big-endian format.  The
+ * data is stored in the PNG file in two's complement format, and it is
+ * assumed that the machine format for signed integers is the same. */
+png_int_32 /* PRIVATE */
+png_get_int_32(png_bytep buf)
+{
+   png_int_32 i = ((png_int_32)(*buf) << 24) +
+      ((png_int_32)(*(buf + 1)) << 16) +
+      ((png_int_32)(*(buf + 2)) << 8) +
+      (png_int_32)(*(buf + 3));
+
+   return (i);
+}
+#endif /* PNG_READ_pCAL_SUPPORTED */
+
+/* Grab an unsigned 16-bit integer from a buffer in big-endian format. */
+png_uint_16 /* PRIVATE */
+png_get_uint_16(png_bytep buf)
+{
+   png_uint_16 i = (png_uint_16)(((png_uint_16)(*buf) << 8) +
+      (png_uint_16)(*(buf + 1)));
+
+   return (i);
+}
+#endif /* PNG_READ_BIG_ENDIAN_SUPPORTED */
+
+/* Read data, and (optionally) run it through the CRC. */
+void /* PRIVATE */
+png_crc_read(png_structp png_ptr, png_bytep buf, png_size_t length)
+{
+   png_read_data(png_ptr, buf, length);
+   png_calculate_crc(png_ptr, buf, length);
+}
+
+/* Optionally skip data and then check the CRC.  Depending on whether we
+   are reading a ancillary or critical chunk, and how the program has set
+   things up, we may calculate the CRC on the data and print a message.
+   Returns '1' if there was a CRC error, '0' otherwise. */
+int /* PRIVATE */
+png_crc_finish(png_structp png_ptr, png_uint_32 skip)
+{
+   png_size_t i;
+   png_size_t istop = png_ptr->zbuf_size;
+
+   for (i = (png_size_t)skip; i > istop; i -= istop)
+   {
+      png_crc_read(png_ptr, png_ptr->zbuf, png_ptr->zbuf_size);
+   }
+   if (i)
+   {
+      png_crc_read(png_ptr, png_ptr->zbuf, i);
+   }
+
+   if (png_crc_error(png_ptr))
+   {
+      if (((png_ptr->chunk_name[0] & 0x20) &&                /* Ancillary */
+           !(png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN)) ||
+          (!(png_ptr->chunk_name[0] & 0x20) &&             /* Critical  */
+          (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_USE)))
+      {
+         png_chunk_warning(png_ptr, "CRC error");
+      }
+      else
+      {
+         png_chunk_error(png_ptr, "CRC error");
+      }
+      return (1);
+   }
+
+   return (0);
+}
+
+/* Compare the CRC stored in the PNG file with that calculated by libpng from
+   the data it has read thus far. */
+int /* PRIVATE */
+png_crc_error(png_structp png_ptr)
+{
+   png_byte crc_bytes[4];
+   png_uint_32 crc;
+   int need_crc = 1;
+
+   if (png_ptr->chunk_name[0] & 0x20)                     /* ancillary */
+   {
+      if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==
+          (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))
+         need_crc = 0;
+   }
+   else                                                    /* critical */
+   {
+      if (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE)
+         need_crc = 0;
+   }
+
+   png_read_data(png_ptr, crc_bytes, 4);
+
+   if (need_crc)
+   {
+      crc = png_get_uint_32(crc_bytes);
+      return ((int)(crc != png_ptr->crc));
+   }
+   else
+      return (0);
+}
+
+#if defined(PNG_READ_zTXt_SUPPORTED) || defined(PNG_READ_iTXt_SUPPORTED) || \
+    defined(PNG_READ_iCCP_SUPPORTED)
+/*
+ * Decompress trailing data in a chunk.  The assumption is that chunkdata
+ * points at an allocated area holding the contents of a chunk with a
+ * trailing compressed part.  What we get back is an allocated area
+ * holding the original prefix part and an uncompressed version of the
+ * trailing part (the malloc area passed in is freed).
+ */
+png_charp /* PRIVATE */
+png_decompress_chunk(png_structp png_ptr, int comp_type,
+                              png_charp chunkdata, png_size_t chunklength,
+                              png_size_t prefix_size, png_size_t *newlength)
+{
+   static char msg[] = "Error decoding compressed text";
+   png_charp text = NULL;
+   png_size_t text_size;
+
+   if (comp_type == PNG_COMPRESSION_TYPE_BASE)
+   {
+      int ret = Z_OK;
+      png_ptr->zstream.next_in = (png_bytep)(chunkdata + prefix_size);
+      png_ptr->zstream.avail_in = (uInt)(chunklength - prefix_size);
+      png_ptr->zstream.next_out = png_ptr->zbuf;
+      png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
+
+      text_size = 0;
+      text = NULL;
+
+      while (png_ptr->zstream.avail_in)
+      {
+         ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH);
+         if (ret != Z_OK && ret != Z_STREAM_END)
+         {
+            if (png_ptr->zstream.msg != NULL)
+               png_warning(png_ptr, png_ptr->zstream.msg);
+            else
+               png_warning(png_ptr, msg);
+            inflateReset(&png_ptr->zstream);
+            png_ptr->zstream.avail_in = 0;
+
+            if (text ==  NULL)
+            {
+               text_size = prefix_size + sizeof(msg) + 1;
+               text = (png_charp)png_malloc_warn(png_ptr, text_size);
+               if (text ==  NULL)
+                 {
+                    png_free(png_ptr,chunkdata);
+                    png_error(png_ptr,"Not enough memory to decompress chunk");
+                 }
+               png_memcpy(text, chunkdata, prefix_size);
+            }
+
+            text[text_size - 1] = 0x00;
+
+            /* Copy what we can of the error message into the text chunk */
+            text_size = (png_size_t)(chunklength - (text - chunkdata) - 1);
+            text_size = sizeof(msg) > text_size ? text_size : sizeof(msg);
+            png_memcpy(text + prefix_size, msg, text_size + 1);
+            break;
+         }
+         if (!png_ptr->zstream.avail_out || ret == Z_STREAM_END)
+         {
+            if (text == NULL)
+            {
+               text_size = prefix_size +
+                   png_ptr->zbuf_size - png_ptr->zstream.avail_out;
+               text = (png_charp)png_malloc_warn(png_ptr, text_size + 1);
+               if (text ==  NULL)
+                 {
+                    png_free(png_ptr,chunkdata);
+                    png_error(png_ptr,"Not enough memory to decompress chunk.");
+                 }
+               png_memcpy(text + prefix_size, png_ptr->zbuf,
+                    text_size - prefix_size);
+               png_memcpy(text, chunkdata, prefix_size);
+               *(text + text_size) = 0x00;
+            }
+            else
+            {
+               png_charp tmp;
+
+               tmp = text;
+               text = (png_charp)png_malloc_warn(png_ptr,
+                  (png_uint_32)(text_size +
+                  png_ptr->zbuf_size - png_ptr->zstream.avail_out + 1));
+               if (text == NULL)
+               {
+                  png_free(png_ptr, tmp);
+                  png_free(png_ptr, chunkdata);
+                  png_error(png_ptr,"Not enough memory to decompress chunk..");
+               }
+               png_memcpy(text, tmp, text_size);
+               png_free(png_ptr, tmp);
+               png_memcpy(text + text_size, png_ptr->zbuf,
+                  (png_ptr->zbuf_size - png_ptr->zstream.avail_out));
+               text_size += png_ptr->zbuf_size - png_ptr->zstream.avail_out;
+               *(text + text_size) = 0x00;
+            }
+            if (ret == Z_STREAM_END)
+               break;
+            else
+            {
+               png_ptr->zstream.next_out = png_ptr->zbuf;
+               png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
+            }
+         }
+      }
+      if (ret != Z_STREAM_END)
+      {
+#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)
+         char umsg[50];
+
+         if (ret == Z_BUF_ERROR)
+            sprintf(umsg,"Buffer error in compressed datastream in %s chunk",
+                png_ptr->chunk_name);
+         else if (ret == Z_DATA_ERROR)
+            sprintf(umsg,"Data error in compressed datastream in %s chunk",
+                png_ptr->chunk_name);
+         else
+            sprintf(umsg,"Incomplete compressed datastream in %s chunk",
+                png_ptr->chunk_name);
+         png_warning(png_ptr, umsg);
+#else
+         png_warning(png_ptr,
+            "Incomplete compressed datastream in chunk other than IDAT");
+#endif
+         text_size=prefix_size;
+         if (text ==  NULL)
+         {
+            text = (png_charp)png_malloc_warn(png_ptr, text_size+1);
+            if (text == NULL)
+              {
+                png_free(png_ptr, chunkdata);
+                png_error(png_ptr,"Not enough memory for text.");
+              }
+            png_memcpy(text, chunkdata, prefix_size);
+         }
+         *(text + text_size) = 0x00;
+      }
+
+      inflateReset(&png_ptr->zstream);
+      png_ptr->zstream.avail_in = 0;
+
+      png_free(png_ptr, chunkdata);
+      chunkdata = text;
+      *newlength=text_size;
+   }
+   else /* if (comp_type != PNG_COMPRESSION_TYPE_BASE) */
+   {
+#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)
+      char umsg[50];
+
+      sprintf(umsg, "Unknown zTXt compression type %d", comp_type);
+      png_warning(png_ptr, umsg);
+#else
+      png_warning(png_ptr, "Unknown zTXt compression type");
+#endif
+
+      *(chunkdata + prefix_size) = 0x00;
+      *newlength=prefix_size;
+   }
+
+   return chunkdata;
+}
+#endif
+
+/* read and check the IDHR chunk */
+void /* PRIVATE */
+png_handle_IHDR(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
+{
+   png_byte buf[13];
+   png_uint_32 width, height;
+   int bit_depth, color_type, compression_type, filter_type;
+   int interlace_type;
+
+   png_debug(1, "in png_handle_IHDR\n");
+
+   if (png_ptr->mode & PNG_HAVE_IHDR)
+      png_error(png_ptr, "Out of place IHDR");
+
+   /* check the length */
+   if (length != 13)
+      png_error(png_ptr, "Invalid IHDR chunk");
+
+   png_ptr->mode |= PNG_HAVE_IHDR;
+
+   png_crc_read(png_ptr, buf, 13);
+   png_crc_finish(png_ptr, 0);
+
+   width = png_get_uint_32(buf);
+   height = png_get_uint_32(buf + 4);
+   bit_depth = buf[8];
+   color_type = buf[9];
+   compression_type = buf[10];
+   filter_type = buf[11];
+   interlace_type = buf[12];
+
+
+   /* set internal variables */
+   png_ptr->width = width;
+   png_ptr->height = height;
+   png_ptr->bit_depth = (png_byte)bit_depth;
+   png_ptr->interlaced = (png_byte)interlace_type;
+   png_ptr->color_type = (png_byte)color_type;
+#if defined(PNG_MNG_FEATURES_SUPPORTED)
+   png_ptr->filter_type = (png_byte)filter_type;
+#endif
+
+   /* find number of channels */
+   switch (png_ptr->color_type)
+   {
+      case PNG_COLOR_TYPE_GRAY:
+      case PNG_COLOR_TYPE_PALETTE:
+         png_ptr->channels = 1;
+         break;
+      case PNG_COLOR_TYPE_RGB:
+         png_ptr->channels = 3;
+         break;
+      case PNG_COLOR_TYPE_GRAY_ALPHA:
+         png_ptr->channels = 2;
+         break;
+      case PNG_COLOR_TYPE_RGB_ALPHA:
+         png_ptr->channels = 4;
+         break;
+   }
+
+   /* set up other useful info */
+   png_ptr->pixel_depth = (png_byte)(png_ptr->bit_depth *
+   png_ptr->channels);
+   png_ptr->rowbytes = ((png_ptr->width *
+      (png_uint_32)png_ptr->pixel_depth + 7) >> 3);
+   png_debug1(3,"bit_depth = %d\n", png_ptr->bit_depth);
+   png_debug1(3,"channels = %d\n", png_ptr->channels);
+   png_debug1(3,"rowbytes = %lu\n", png_ptr->rowbytes);
+   png_set_IHDR(png_ptr, info_ptr, width, height, bit_depth,
+      color_type, interlace_type, compression_type, filter_type);
+}
+
+/* read and check the palette */
+void /* PRIVATE */
+png_handle_PLTE(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
+{
+   png_color palette[PNG_MAX_PALETTE_LENGTH];
+   int num, i;
+#ifndef PNG_NO_POINTER_INDEXING
+   png_colorp pal_ptr;
+#endif
+
+   png_debug(1, "in png_handle_PLTE\n");
+
+   if (!(png_ptr->mode & PNG_HAVE_IHDR))
+      png_error(png_ptr, "Missing IHDR before PLTE");
+   else if (png_ptr->mode & PNG_HAVE_IDAT)
+   {
+      png_warning(png_ptr, "Invalid PLTE after IDAT");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+   else if (png_ptr->mode & PNG_HAVE_PLTE)
+      png_error(png_ptr, "Duplicate PLTE chunk");
+
+   png_ptr->mode |= PNG_HAVE_PLTE;
+
+   if (!(png_ptr->color_type&PNG_COLOR_MASK_COLOR))
+   {
+      png_warning(png_ptr,
+        "Ignoring PLTE chunk in grayscale PNG");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+#if !defined(PNG_READ_OPT_PLTE_SUPPORTED)
+   if (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE)
+   {
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+#endif
+
+   if (length > 3*PNG_MAX_PALETTE_LENGTH || length % 3)
+   {
+      if (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE)
+      {
+         png_warning(png_ptr, "Invalid palette chunk");
+         png_crc_finish(png_ptr, length);
+         return;
+      }
+      else
+      {
+         png_error(png_ptr, "Invalid palette chunk");
+      }
+   }
+
+   num = (int)length / 3;
+
+#ifndef PNG_NO_POINTER_INDEXING
+   for (i = 0, pal_ptr = palette; i < num; i++, pal_ptr++)
+   {
+      png_byte buf[3];
+
+      png_crc_read(png_ptr, buf, 3);
+      pal_ptr->red = buf[0];
+      pal_ptr->green = buf[1];
+      pal_ptr->blue = buf[2];
+   }
+#else
+   for (i = 0; i < num; i++)
+   {
+      png_byte buf[3];
+
+      png_crc_read(png_ptr, buf, 3);
+      /* don't depend upon png_color being any order */
+      palette[i].red = buf[0];
+      palette[i].green = buf[1];
+      palette[i].blue = buf[2];
+   }
+#endif
+
+   /* If we actually NEED the PLTE chunk (ie for a paletted image), we do
+      whatever the normal CRC configuration tells us.  However, if we
+      have an RGB image, the PLTE can be considered ancillary, so
+      we will act as though it is. */
+#if !defined(PNG_READ_OPT_PLTE_SUPPORTED)
+   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
+#endif
+   {
+      png_crc_finish(png_ptr, 0);
+   }
+#if !defined(PNG_READ_OPT_PLTE_SUPPORTED)
+   else if (png_crc_error(png_ptr))  /* Only if we have a CRC error */
+   {
+      /* If we don't want to use the data from an ancillary chunk,
+         we have two options: an error abort, or a warning and we
+         ignore the data in this chunk (which should be OK, since
+         it's considered ancillary for a RGB or RGBA image). */
+      if (!(png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_USE))
+      {
+         if (png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN)
+         {
+            png_chunk_error(png_ptr, "CRC error");
+         }
+         else
+         {
+            png_chunk_warning(png_ptr, "CRC error");
+            return;
+         }
+      }
+      /* Otherwise, we (optionally) emit a warning and use the chunk. */
+      else if (!(png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN))
+      {
+         png_chunk_warning(png_ptr, "CRC error");
+      }
+   }
+#endif
+
+   png_set_PLTE(png_ptr, info_ptr, palette, num);
+
+#if defined(PNG_READ_tRNS_SUPPORTED)
+   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
+   {
+      if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS))
+      {
+         if (png_ptr->num_trans > (png_uint_16)num)
+         {
+            png_warning(png_ptr, "Truncating incorrect tRNS chunk length");
+            png_ptr->num_trans = (png_uint_16)num;
+         }
+         if (info_ptr->num_trans > (png_uint_16)num)
+         {
+            png_warning(png_ptr, "Truncating incorrect info tRNS chunk length");
+            info_ptr->num_trans = (png_uint_16)num;
+         }
+      }
+   }
+#endif
+
+}
+
+void /* PRIVATE */
+png_handle_IEND(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
+{
+   png_debug(1, "in png_handle_IEND\n");
+
+   if (!(png_ptr->mode & PNG_HAVE_IHDR) || !(png_ptr->mode & PNG_HAVE_IDAT))
+   {
+      png_error(png_ptr, "No image in file");
+
+      info_ptr = info_ptr; /* quiet compiler warnings about unused info_ptr */
+   }
+
+   png_ptr->mode |= (PNG_AFTER_IDAT | PNG_HAVE_IEND);
+
+   if (length != 0)
+   {
+      png_warning(png_ptr, "Incorrect IEND chunk length");
+   }
+   png_crc_finish(png_ptr, length);
+}
+
+#if defined(PNG_READ_gAMA_SUPPORTED)
+void /* PRIVATE */
+png_handle_gAMA(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
+{
+   png_fixed_point igamma;
+#ifdef PNG_FLOATING_POINT_SUPPORTED
+   float file_gamma;
+#endif
+   png_byte buf[4];
+
+   png_debug(1, "in png_handle_gAMA\n");
+
+   if (!(png_ptr->mode & PNG_HAVE_IHDR))
+      png_error(png_ptr, "Missing IHDR before gAMA");
+   else if (png_ptr->mode & PNG_HAVE_IDAT)
+   {
+      png_warning(png_ptr, "Invalid gAMA after IDAT");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+   else if (png_ptr->mode & PNG_HAVE_PLTE)
+      /* Should be an error, but we can cope with it */
+      png_warning(png_ptr, "Out of place gAMA chunk");
+
+   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_gAMA)
+#if defined(PNG_READ_sRGB_SUPPORTED)
+      && !(info_ptr->valid & PNG_INFO_sRGB)
+#endif
+      )
+   {
+      png_warning(png_ptr, "Duplicate gAMA chunk");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+
+   if (length != 4)
+   {
+      png_warning(png_ptr, "Incorrect gAMA chunk length");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+
+   png_crc_read(png_ptr, buf, 4);
+   if (png_crc_finish(png_ptr, 0))
+      return;
+
+   igamma = (png_fixed_point)png_get_uint_32(buf);
+   /* check for zero gamma */
+   if (igamma == 0)
+      {
+         png_warning(png_ptr,
+           "Ignoring gAMA chunk with gamma=0");
+         return;
+      }
+
+#if defined(PNG_READ_sRGB_SUPPORTED)
+   if (info_ptr->valid & PNG_INFO_sRGB)
+      if(igamma < 45000L || igamma > 46000L)
+      {
+         png_warning(png_ptr,
+           "Ignoring incorrect gAMA value when sRGB is also present");
+#ifndef PNG_NO_CONSOLE_IO
+         fprintf(stderr, "gamma = (%d/100000)\n", (int)igamma);
+#endif
+         return;
+      }
+#endif /* PNG_READ_sRGB_SUPPORTED */
+
+#ifdef PNG_FLOATING_POINT_SUPPORTED
+   file_gamma = (float)igamma / (float)100000.0;
+#  ifdef PNG_READ_GAMMA_SUPPORTED
+     png_ptr->gamma = file_gamma;
+#  endif
+     png_set_gAMA(png_ptr, info_ptr, file_gamma);
+#endif
+#ifdef PNG_FIXED_POINT_SUPPORTED
+   png_set_gAMA_fixed(png_ptr, info_ptr, igamma);
+#endif
+}
+#endif
+
+#if defined(PNG_READ_sBIT_SUPPORTED)
+void /* PRIVATE */
+png_handle_sBIT(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
+{
+   png_size_t truelen;
+   png_byte buf[4];
+
+   png_debug(1, "in png_handle_sBIT\n");
+
+   buf[0] = buf[1] = buf[2] = buf[3] = 0;
+
+   if (!(png_ptr->mode & PNG_HAVE_IHDR))
+      png_error(png_ptr, "Missing IHDR before sBIT");
+   else if (png_ptr->mode & PNG_HAVE_IDAT)
+   {
+      png_warning(png_ptr, "Invalid sBIT after IDAT");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+   else if (png_ptr->mode & PNG_HAVE_PLTE)
+   {
+      /* Should be an error, but we can cope with it */
+      png_warning(png_ptr, "Out of place sBIT chunk");
+   }
+   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sBIT))
+   {
+      png_warning(png_ptr, "Duplicate sBIT chunk");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+
+   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
+      truelen = 3;
+   else
+      truelen = (png_size_t)png_ptr->channels;
+
+   if (length != truelen)
+   {
+      png_warning(png_ptr, "Incorrect sBIT chunk length");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+
+   png_crc_read(png_ptr, buf, truelen);
+   if (png_crc_finish(png_ptr, 0))
+      return;
+
+   if (png_ptr->color_type & PNG_COLOR_MASK_COLOR)
+   {
+      png_ptr->sig_bit.red = buf[0];
+      png_ptr->sig_bit.green = buf[1];
+      png_ptr->sig_bit.blue = buf[2];
+      png_ptr->sig_bit.alpha = buf[3];
+   }
+   else
+   {
+      png_ptr->sig_bit.gray = buf[0];
+      png_ptr->sig_bit.red = buf[0];
+      png_ptr->sig_bit.green = buf[0];
+      png_ptr->sig_bit.blue = buf[0];
+      png_ptr->sig_bit.alpha = buf[1];
+   }
+   png_set_sBIT(png_ptr, info_ptr, &(png_ptr->sig_bit));
+}
+#endif
+
+#if defined(PNG_READ_cHRM_SUPPORTED)
+void /* PRIVATE */
+png_handle_cHRM(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
+{
+   png_byte buf[4];
+#ifdef PNG_FLOATING_POINT_SUPPORTED
+   float white_x, white_y, red_x, red_y, green_x, green_y, blue_x, blue_y;
+#endif
+   png_fixed_point int_x_white, int_y_white, int_x_red, int_y_red, int_x_green,
+      int_y_green, int_x_blue, int_y_blue;
+
+   png_uint_32 uint_x, uint_y;
+
+   png_debug(1, "in png_handle_cHRM\n");
+
+   if (!(png_ptr->mode & PNG_HAVE_IHDR))
+      png_error(png_ptr, "Missing IHDR before cHRM");
+   else if (png_ptr->mode & PNG_HAVE_IDAT)
+   {
+      png_warning(png_ptr, "Invalid cHRM after IDAT");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+   else if (png_ptr->mode & PNG_HAVE_PLTE)
+      /* Should be an error, but we can cope with it */
+      png_warning(png_ptr, "Missing PLTE before cHRM");
+
+   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_cHRM)
+#if defined(PNG_READ_sRGB_SUPPORTED)
+      && !(info_ptr->valid & PNG_INFO_sRGB)
+#endif
+      )
+   {
+      png_warning(png_ptr, "Duplicate cHRM chunk");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+
+   if (length != 32)
+   {
+      png_warning(png_ptr, "Incorrect cHRM chunk length");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+
+   png_crc_read(png_ptr, buf, 4);
+   uint_x = png_get_uint_32(buf);
+
+   png_crc_read(png_ptr, buf, 4);
+   uint_y = png_get_uint_32(buf);
+
+   if (uint_x > 80000L || uint_y > 80000L ||
+      uint_x + uint_y > 100000L)
+   {
+      png_warning(png_ptr, "Invalid cHRM white point");
+      png_crc_finish(png_ptr, 24);
+      return;
+   }
+   int_x_white = (png_fixed_point)uint_x;
+   int_y_white = (png_fixed_point)uint_y;
+
+   png_crc_read(png_ptr, buf, 4);
+   uint_x = png_get_uint_32(buf);
+
+   png_crc_read(png_ptr, buf, 4);
+   uint_y = png_get_uint_32(buf);
+
+   if (uint_x > 80000L || uint_y > 80000L ||
+      uint_x + uint_y > 100000L)
+   {
+      png_warning(png_ptr, "Invalid cHRM red point");
+      png_crc_finish(png_ptr, 16);
+      return;
+   }
+   int_x_red = (png_fixed_point)uint_x;
+   int_y_red = (png_fixed_point)uint_y;
+
+   png_crc_read(png_ptr, buf, 4);
+   uint_x = png_get_uint_32(buf);
+
+   png_crc_read(png_ptr, buf, 4);
+   uint_y = png_get_uint_32(buf);
+
+   if (uint_x > 80000L || uint_y > 80000L ||
+      uint_x + uint_y > 100000L)
+   {
+      png_warning(png_ptr, "Invalid cHRM green point");
+      png_crc_finish(png_ptr, 8);
+      return;
+   }
+   int_x_green = (png_fixed_point)uint_x;
+   int_y_green = (png_fixed_point)uint_y;
+
+   png_crc_read(png_ptr, buf, 4);
+   uint_x = png_get_uint_32(buf);
+
+   png_crc_read(png_ptr, buf, 4);
+   uint_y = png_get_uint_32(buf);
+
+   if (uint_x > 80000L || uint_y > 80000L ||
+      uint_x + uint_y > 100000L)
+   {
+      png_warning(png_ptr, "Invalid cHRM blue point");
+      png_crc_finish(png_ptr, 0);
+      return;
+   }
+   int_x_blue = (png_fixed_point)uint_x;
+   int_y_blue = (png_fixed_point)uint_y;
+
+#ifdef PNG_FLOATING_POINT_SUPPORTED
+   white_x = (float)int_x_white / (float)100000.0;
+   white_y = (float)int_y_white / (float)100000.0;
+   red_x   = (float)int_x_red   / (float)100000.0;
+   red_y   = (float)int_y_red   / (float)100000.0;
+   green_x = (float)int_x_green / (float)100000.0;
+   green_y = (float)int_y_green / (float)100000.0;
+   blue_x  = (float)int_x_blue  / (float)100000.0;
+   blue_y  = (float)int_y_blue  / (float)100000.0;
+#endif
+
+#if defined(PNG_READ_sRGB_SUPPORTED)
+   if (info_ptr->valid & PNG_INFO_sRGB)
+      {
+      if (abs(int_x_white - 31270L) > 1000 ||
+          abs(int_y_white - 32900L) > 1000 ||
+          abs(int_x_red   - 64000L) > 1000 ||
+          abs(int_y_red   - 33000L) > 1000 ||
+          abs(int_x_green - 30000L) > 1000 ||
+          abs(int_y_green - 60000L) > 1000 ||
+          abs(int_x_blue  - 15000L) > 1000 ||
+          abs(int_y_blue  -  6000L) > 1000)
+         {
+
+            png_warning(png_ptr,
+              "Ignoring incorrect cHRM value when sRGB is also present");
+#ifndef PNG_NO_CONSOLE_IO
+#ifdef PNG_FLOATING_POINT_SUPPORTED
+            fprintf(stderr,"wx=%f, wy=%f, rx=%f, ry=%f\n",
+               white_x, white_y, red_x, red_y);
+            fprintf(stderr,"gx=%f, gy=%f, bx=%f, by=%f\n",
+               green_x, green_y, blue_x, blue_y);
+#else
+            fprintf(stderr,"wx=%ld, wy=%ld, rx=%ld, ry=%ld\n",
+               int_x_white, int_y_white, int_x_red, int_y_red);
+            fprintf(stderr,"gx=%ld, gy=%ld, bx=%ld, by=%ld\n",
+               int_x_green, int_y_green, int_x_blue, int_y_blue);
+#endif
+#endif /* PNG_NO_CONSOLE_IO */
+         }
+         png_crc_finish(png_ptr, 0);
+         return;
+      }
+#endif /* PNG_READ_sRGB_SUPPORTED */
+
+#ifdef PNG_FLOATING_POINT_SUPPORTED
+   png_set_cHRM(png_ptr, info_ptr,
+      white_x, white_y, red_x, red_y, green_x, green_y, blue_x, blue_y);
+#endif
+#ifdef PNG_FIXED_POINT_SUPPORTED
+   png_set_cHRM_fixed(png_ptr, info_ptr,
+      int_x_white, int_y_white, int_x_red, int_y_red, int_x_green,
+      int_y_green, int_x_blue, int_y_blue);
+#endif
+   if (png_crc_finish(png_ptr, 0))
+      return;
+}
+#endif
+
+#if defined(PNG_READ_sRGB_SUPPORTED)
+void /* PRIVATE */
+png_handle_sRGB(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
+{
+   int intent;
+   png_byte buf[1];
+
+   png_debug(1, "in png_handle_sRGB\n");
+
+   if (!(png_ptr->mode & PNG_HAVE_IHDR))
+      png_error(png_ptr, "Missing IHDR before sRGB");
+   else if (png_ptr->mode & PNG_HAVE_IDAT)
+   {
+      png_warning(png_ptr, "Invalid sRGB after IDAT");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+   else if (png_ptr->mode & PNG_HAVE_PLTE)
+      /* Should be an error, but we can cope with it */
+      png_warning(png_ptr, "Out of place sRGB chunk");
+
+   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sRGB))
+   {
+      png_warning(png_ptr, "Duplicate sRGB chunk");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+
+   if (length != 1)
+   {
+      png_warning(png_ptr, "Incorrect sRGB chunk length");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+
+   png_crc_read(png_ptr, buf, 1);
+   if (png_crc_finish(png_ptr, 0))
+      return;
+
+   intent = buf[0];
+   /* check for bad intent */
+   if (intent >= PNG_sRGB_INTENT_LAST)
+   {
+      png_warning(png_ptr, "Unknown sRGB intent");
+      return;
+   }
+
+#if defined(PNG_READ_gAMA_SUPPORTED) && defined(PNG_READ_GAMMA_SUPPORTED)
+   if ((info_ptr->valid & PNG_INFO_gAMA))
+   {
+   int igamma;
+#ifdef PNG_FIXED_POINT_SUPPORTED
+      igamma=(int)info_ptr->int_gamma;
+#else
+#  ifdef PNG_FLOATING_POINT_SUPPORTED
+      igamma=(int)(info_ptr->gamma * 100000.);
+#  endif
+#endif
+      if(igamma < 45000L || igamma > 46000L)
+      {
+         png_warning(png_ptr,
+           "Ignoring incorrect gAMA value when sRGB is also present");
+#ifndef PNG_NO_CONSOLE_IO
+#  ifdef PNG_FIXED_POINT_SUPPORTED
+         fprintf(stderr,"incorrect gamma=(%d/100000)\n",(int)png_ptr->int_gamma);
+#  else
+#    ifdef PNG_FLOATING_POINT_SUPPORTED
+         fprintf(stderr,"incorrect gamma=%f\n",png_ptr->gamma);
+#    endif
+#  endif
+#endif
+      }
+   }
+#endif /* PNG_READ_gAMA_SUPPORTED */
+
+#ifdef PNG_READ_cHRM_SUPPORTED
+#ifdef PNG_FIXED_POINT_SUPPORTED
+   if (info_ptr->valid & PNG_INFO_cHRM)
+      if (abs(info_ptr->int_x_white - 31270L) > 1000 ||
+          abs(info_ptr->int_y_white - 32900L) > 1000 ||
+          abs(info_ptr->int_x_red   - 64000L) > 1000 ||
+          abs(info_ptr->int_y_red   - 33000L) > 1000 ||
+          abs(info_ptr->int_x_green - 30000L) > 1000 ||
+          abs(info_ptr->int_y_green - 60000L) > 1000 ||
+          abs(info_ptr->int_x_blue  - 15000L) > 1000 ||
+          abs(info_ptr->int_y_blue  -  6000L) > 1000)
+         {
+            png_warning(png_ptr,
+              "Ignoring incorrect cHRM value when sRGB is also present");
+         }
+#endif /* PNG_FIXED_POINT_SUPPORTED */
+#endif /* PNG_READ_cHRM_SUPPORTED */
+
+   png_set_sRGB_gAMA_and_cHRM(png_ptr, info_ptr, intent);
+}
+#endif /* PNG_READ_sRGB_SUPPORTED */
+
+#if defined(PNG_READ_iCCP_SUPPORTED)
+void /* PRIVATE */
+png_handle_iCCP(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
+/* Note: this does not properly handle chunks that are > 64K under DOS */
+{
+   png_charp chunkdata;
+   png_byte compression_type;
+   png_bytep pC;
+   png_charp profile;
+   png_uint_32 skip = 0;
+   png_uint_32 profile_size = 0;
+   png_uint_32 profile_length = 0;
+   png_size_t slength, prefix_length, data_length;
+
+   png_debug(1, "in png_handle_iCCP\n");
+
+   if (!(png_ptr->mode & PNG_HAVE_IHDR))
+      png_error(png_ptr, "Missing IHDR before iCCP");
+   else if (png_ptr->mode & PNG_HAVE_IDAT)
+   {
+      png_warning(png_ptr, "Invalid iCCP after IDAT");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+   else if (png_ptr->mode & PNG_HAVE_PLTE)
+      /* Should be an error, but we can cope with it */
+      png_warning(png_ptr, "Out of place iCCP chunk");
+
+   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_iCCP))
+   {
+      png_warning(png_ptr, "Duplicate iCCP chunk");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+
+#ifdef PNG_MAX_MALLOC_64K
+   if (length > (png_uint_32)65535L)
+   {
+      png_warning(png_ptr, "iCCP chunk too large to fit in memory");
+      skip = length - (png_uint_32)65535L;
+      length = (png_uint_32)65535L;
+   }
+#endif
+
+   chunkdata = (png_charp)png_malloc(png_ptr, length + 1);
+   slength = (png_size_t)length;
+   png_crc_read(png_ptr, (png_bytep)chunkdata, slength);
+
+   if (png_crc_finish(png_ptr, skip))
+   {
+      png_free(png_ptr, chunkdata);
+      return;
+   }
+
+   chunkdata[slength] = 0x00;
+
+   for (profile = chunkdata; *profile; profile++)
+      /* empty loop to find end of name */ ;
+
+   ++profile;
+
+   /* there should be at least one zero (the compression type byte)
+      following the separator, and we should be on it  */
+   if ( profile >= chunkdata + slength)
+   {
+      png_free(png_ptr, chunkdata);
+      png_warning(png_ptr, "Malformed iCCP chunk");
+      return;
+   }
+
+   /* compression_type should always be zero */
+   compression_type = *profile++;
+   if (compression_type)
+   {
+      png_warning(png_ptr, "Ignoring nonzero compression type in iCCP chunk");
+      compression_type=0x00;  /* Reset it to zero (libpng-1.0.6 through 1.0.8
+                                 wrote nonzero) */
+   }
+
+   prefix_length = profile - chunkdata;
+   chunkdata = png_decompress_chunk(png_ptr, compression_type, chunkdata,
+                                    slength, prefix_length, &data_length);
+
+   profile_length = data_length - prefix_length;
+
+   if ( prefix_length > data_length || profile_length < 4)
+   {
+      png_free(png_ptr, chunkdata);
+      png_warning(png_ptr, "Profile size field missing from iCCP chunk");
+      return;
+   }
+
+   /* Check the profile_size recorded in the first 32 bits of the ICC profile */
+   pC = (png_bytep)(chunkdata+prefix_length);
+   profile_size = ((*(pC  ))<<24) |
+                  ((*(pC+1))<<16) |
+                  ((*(pC+2))<< 8) |
+                  ((*(pC+3))    );
+
+   if(profile_size < profile_length)
+      profile_length = profile_size;
+
+   if(profile_size > profile_length)
+   {
+      png_free(png_ptr, chunkdata);
+      png_warning(png_ptr, "Ignoring truncated iCCP profile.\n");
+      return;
+   }
+
+   png_set_iCCP(png_ptr, info_ptr, chunkdata, compression_type,
+                chunkdata + prefix_length, profile_length);
+   png_free(png_ptr, chunkdata);
+}
+#endif /* PNG_READ_iCCP_SUPPORTED */
+
+#if defined(PNG_READ_sPLT_SUPPORTED)
+void /* PRIVATE */
+png_handle_sPLT(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
+/* Note: this does not properly handle chunks that are > 64K under DOS */
+{
+   png_bytep chunkdata;
+   png_bytep entry_start;
+   png_sPLT_t new_palette;
+#ifdef PNG_NO_POINTER_INDEXING
+   png_sPLT_entryp pp;
+#endif
+   int data_length, entry_size, i;
+   png_uint_32 skip = 0;
+   png_size_t slength;
+
+   png_debug(1, "in png_handle_sPLT\n");
+
+   if (!(png_ptr->mode & PNG_HAVE_IHDR))
+      png_error(png_ptr, "Missing IHDR before sPLT");
+   else if (png_ptr->mode & PNG_HAVE_IDAT)
+   {
+      png_warning(png_ptr, "Invalid sPLT after IDAT");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+
+#ifdef PNG_MAX_MALLOC_64K
+   if (length > (png_uint_32)65535L)
+   {
+      png_warning(png_ptr, "sPLT chunk too large to fit in memory");
+      skip = length - (png_uint_32)65535L;
+      length = (png_uint_32)65535L;
+   }
+#endif
+
+   chunkdata = (png_bytep)png_malloc(png_ptr, length + 1);
+   slength = (png_size_t)length;
+   png_crc_read(png_ptr, (png_bytep)chunkdata, slength);
+
+   if (png_crc_finish(png_ptr, skip))
+   {
+      png_free(png_ptr, chunkdata);
+      return;
+   }
+
+   chunkdata[slength] = 0x00;
+
+   for (entry_start = chunkdata; *entry_start; entry_start++)
+      /* empty loop to find end of name */ ;
+   ++entry_start;
+
+   /* a sample depth should follow the separator, and we should be on it  */
+   if (entry_start > chunkdata + slength)
+   {
+      png_free(png_ptr, chunkdata);
+      png_warning(png_ptr, "malformed sPLT chunk");
+      return;
+   }
+
+   new_palette.depth = *entry_start++;
+   entry_size = (new_palette.depth == 8 ? 6 : 10);
+   data_length = (slength - (entry_start - chunkdata));
+
+   /* integrity-check the data length */
+   if (data_length % entry_size)
+   {
+      png_free(png_ptr, chunkdata);
+      png_warning(png_ptr, "sPLT chunk has bad length");
+      return;
+   }
+
+   new_palette.nentries = data_length / entry_size;
+   if (new_palette.nentries > PNG_SIZE_MAX / sizeof(png_sPLT_entry))
+   {
+       png_warning(png_ptr, "sPLT chunk too long");
+       return;
+   }
+   new_palette.entries = (png_sPLT_entryp)png_malloc_warn(
+       png_ptr, new_palette.nentries * sizeof(png_sPLT_entry));
+   if (new_palette.entries == NULL)
+   {
+       png_warning(png_ptr, "sPLT chunk requires too much memory");
+       return;
+   }
+
+#ifndef PNG_NO_POINTER_INDEXING
+   for (i = 0; i < new_palette.nentries; i++)
+   {
+      png_sPLT_entryp pp = new_palette.entries + i;
+
+      if (new_palette.depth == 8)
+      {
+          pp->red = *entry_start++;
+          pp->green = *entry_start++;
+          pp->blue = *entry_start++;
+          pp->alpha = *entry_start++;
+      }
+      else
+      {
+          pp->red   = png_get_uint_16(entry_start); entry_start += 2;
+          pp->green = png_get_uint_16(entry_start); entry_start += 2;
+          pp->blue  = png_get_uint_16(entry_start); entry_start += 2;
+          pp->alpha = png_get_uint_16(entry_start); entry_start += 2;
+      }
+      pp->frequency = png_get_uint_16(entry_start); entry_start += 2;
+   }
+#else
+   pp = new_palette.entries;
+   for (i = 0; i < new_palette.nentries; i++)
+   {
+
+      if (new_palette.depth == 8)
+      {
+          pp[i].red   = *entry_start++;
+          pp[i].green = *entry_start++;
+          pp[i].blue  = *entry_start++;
+          pp[i].alpha = *entry_start++;
+      }
+      else
+      {
+          pp[i].red   = png_get_uint_16(entry_start); entry_start += 2;
+          pp[i].green = png_get_uint_16(entry_start); entry_start += 2;
+          pp[i].blue  = png_get_uint_16(entry_start); entry_start += 2;
+          pp[i].alpha = png_get_uint_16(entry_start); entry_start += 2;
+      }
+      pp->frequency = png_get_uint_16(entry_start); entry_start += 2;
+   }
+#endif
+
+   /* discard all chunk data except the name and stash that */
+   new_palette.name = (png_charp)chunkdata;
+
+   png_set_sPLT(png_ptr, info_ptr, &new_palette, 1);
+
+   png_free(png_ptr, chunkdata);
+   png_free(png_ptr, new_palette.entries);
+}
+#endif /* PNG_READ_sPLT_SUPPORTED */
+
+#if defined(PNG_READ_tRNS_SUPPORTED)
+void /* PRIVATE */
+png_handle_tRNS(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
+{
+   png_byte readbuf[PNG_MAX_PALETTE_LENGTH];
+
+   png_debug(1, "in png_handle_tRNS\n");
+
+   if (!(png_ptr->mode & PNG_HAVE_IHDR))
+      png_error(png_ptr, "Missing IHDR before tRNS");
+   else if (png_ptr->mode & PNG_HAVE_IDAT)
+   {
+      png_warning(png_ptr, "Invalid tRNS after IDAT");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS))
+   {
+      png_warning(png_ptr, "Duplicate tRNS chunk");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+
+   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
+   {
+      if (!(png_ptr->mode & PNG_HAVE_PLTE))
+      {
+         /* Should be an error, but we can cope with it */
+         png_warning(png_ptr, "Missing PLTE before tRNS");
+      }
+      if (length > (png_uint_32)png_ptr->num_palette ||
+          length > PNG_MAX_PALETTE_LENGTH)
+      {
+         png_warning(png_ptr, "Incorrect tRNS chunk length");
+         png_crc_finish(png_ptr, length);
+         return;
+      }
+      if (length == 0)
+      {
+         png_warning(png_ptr, "Zero length tRNS chunk");
+         png_crc_finish(png_ptr, length);
+         return;
+      }
+
+      png_crc_read(png_ptr, readbuf, (png_size_t)length);
+      png_ptr->num_trans = (png_uint_16)length;
+   }
+   else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)
+   {
+      png_byte buf[6];
+
+      if (length != 6)
+      {
+         png_warning(png_ptr, "Incorrect tRNS chunk length");
+         png_crc_finish(png_ptr, length);
+         return;
+      }
+
+      png_crc_read(png_ptr, buf, (png_size_t)length);
+      png_ptr->num_trans = 1;
+      png_ptr->trans_values.red = png_get_uint_16(buf);
+      png_ptr->trans_values.green = png_get_uint_16(buf + 2);
+      png_ptr->trans_values.blue = png_get_uint_16(buf + 4);
+   }
+   else if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)
+   {
+      png_byte buf[6];
+
+      if (length != 2)
+      {
+         png_warning(png_ptr, "Incorrect tRNS chunk length");
+         png_crc_finish(png_ptr, length);
+         return;
+      }
+
+      png_crc_read(png_ptr, buf, 2);
+      png_ptr->num_trans = 1;
+      png_ptr->trans_values.gray = png_get_uint_16(buf);
+   }
+   else
+   {
+      png_warning(png_ptr, "tRNS chunk not allowed with alpha channel");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+
+   if (png_crc_finish(png_ptr, 0))
+      return;
+
+   png_set_tRNS(png_ptr, info_ptr, readbuf, png_ptr->num_trans,
+      &(png_ptr->trans_values));
+}
+#endif
+
+#if defined(PNG_READ_bKGD_SUPPORTED)
+void /* PRIVATE */
+png_handle_bKGD(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
+{
+   png_size_t truelen;
+   png_byte buf[6];
+
+   png_debug(1, "in png_handle_bKGD\n");
+
+   if (!(png_ptr->mode & PNG_HAVE_IHDR))
+      png_error(png_ptr, "Missing IHDR before bKGD");
+   else if (png_ptr->mode & PNG_HAVE_IDAT)
+   {
+      png_warning(png_ptr, "Invalid bKGD after IDAT");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+   else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&
+            !(png_ptr->mode & PNG_HAVE_PLTE))
+   {
+      png_warning(png_ptr, "Missing PLTE before bKGD");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_bKGD))
+   {
+      png_warning(png_ptr, "Duplicate bKGD chunk");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+
+   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
+      truelen = 1;
+   else if (png_ptr->color_type & PNG_COLOR_MASK_COLOR)
+      truelen = 6;
+   else
+      truelen = 2;
+
+   if (length != truelen)
+   {
+      png_warning(png_ptr, "Incorrect bKGD chunk length");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+
+   png_crc_read(png_ptr, buf, truelen);
+   if (png_crc_finish(png_ptr, 0))
+      return;
+
+   /* We convert the index value into RGB components so that we can allow
+    * arbitrary RGB values for background when we have transparency, and
+    * so it is easy to determine the RGB values of the background color
+    * from the info_ptr struct. */
+   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
+   {
+      png_ptr->background.index = buf[0];
+      if(info_ptr->num_palette)
+      {
+          if(buf[0] > info_ptr->num_palette)
+          {
+             png_warning(png_ptr, "Incorrect bKGD chunk index value");
+             return;
+          }
+          png_ptr->background.red =
+             (png_uint_16)png_ptr->palette[buf[0]].red;
+          png_ptr->background.green =
+             (png_uint_16)png_ptr->palette[buf[0]].green;
+          png_ptr->background.blue =
+             (png_uint_16)png_ptr->palette[buf[0]].blue;
+      }
+   }
+   else if (!(png_ptr->color_type & PNG_COLOR_MASK_COLOR)) /* GRAY */
+   {
+      png_ptr->background.red =
+      png_ptr->background.green =
+      png_ptr->background.blue =
+      png_ptr->background.gray = png_get_uint_16(buf);
+   }
+   else
+   {
+      png_ptr->background.red = png_get_uint_16(buf);
+      png_ptr->background.green = png_get_uint_16(buf + 2);
+      png_ptr->background.blue = png_get_uint_16(buf + 4);
+   }
+
+   png_set_bKGD(png_ptr, info_ptr, &(png_ptr->background));
+}
+#endif
+
+#if defined(PNG_READ_hIST_SUPPORTED)
+void /* PRIVATE */
+png_handle_hIST(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
+{
+   int num, i;
+   png_uint_16 readbuf[PNG_MAX_PALETTE_LENGTH];
+
+   png_debug(1, "in png_handle_hIST\n");
+
+   if (!(png_ptr->mode & PNG_HAVE_IHDR))
+      png_error(png_ptr, "Missing IHDR before hIST");
+   else if (png_ptr->mode & PNG_HAVE_IDAT)
+   {
+      png_warning(png_ptr, "Invalid hIST after IDAT");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+   else if (!(png_ptr->mode & PNG_HAVE_PLTE))
+   {
+      png_warning(png_ptr, "Missing PLTE before hIST");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_hIST))
+   {
+      png_warning(png_ptr, "Duplicate hIST chunk");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+
+   num = (int)length / 2 ;
+   if (num != png_ptr->num_palette)
+   {
+      png_warning(png_ptr, "Incorrect hIST chunk length");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+
+   for (i = 0; i < num; i++)
+   {
+      png_byte buf[2];
+
+      png_crc_read(png_ptr, buf, 2);
+      readbuf[i] = png_get_uint_16(buf);
+   }
+
+   if (png_crc_finish(png_ptr, 0))
+      return;
+
+   png_set_hIST(png_ptr, info_ptr, readbuf);
+}
+#endif
+
+#if defined(PNG_READ_pHYs_SUPPORTED)
+void /* PRIVATE */
+png_handle_pHYs(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
+{
+   png_byte buf[9];
+   png_uint_32 res_x, res_y;
+   int unit_type;
+
+   png_debug(1, "in png_handle_pHYs\n");
+
+   if (!(png_ptr->mode & PNG_HAVE_IHDR))
+      png_error(png_ptr, "Missing IHDR before pHYs");
+   else if (png_ptr->mode & PNG_HAVE_IDAT)
+   {
+      png_warning(png_ptr, "Invalid pHYs after IDAT");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_pHYs))
+   {
+      png_warning(png_ptr, "Duplicate pHYs chunk");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+
+   if (length != 9)
+   {
+      png_warning(png_ptr, "Incorrect pHYs chunk length");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+
+   png_crc_read(png_ptr, buf, 9);
+   if (png_crc_finish(png_ptr, 0))
+      return;
+
+   res_x = png_get_uint_32(buf);
+   res_y = png_get_uint_32(buf + 4);
+   unit_type = buf[8];
+   png_set_pHYs(png_ptr, info_ptr, res_x, res_y, unit_type);
+}
+#endif
+
+#if defined(PNG_READ_oFFs_SUPPORTED)
+void /* PRIVATE */
+png_handle_oFFs(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
+{
+   png_byte buf[9];
+   png_int_32 offset_x, offset_y;
+   int unit_type;
+
+   png_debug(1, "in png_handle_oFFs\n");
+
+   if (!(png_ptr->mode & PNG_HAVE_IHDR))
+      png_error(png_ptr, "Missing IHDR before oFFs");
+   else if (png_ptr->mode & PNG_HAVE_IDAT)
+   {
+      png_warning(png_ptr, "Invalid oFFs after IDAT");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_oFFs))
+   {
+      png_warning(png_ptr, "Duplicate oFFs chunk");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+
+   if (length != 9)
+   {
+      png_warning(png_ptr, "Incorrect oFFs chunk length");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+
+   png_crc_read(png_ptr, buf, 9);
+   if (png_crc_finish(png_ptr, 0))
+      return;
+
+   offset_x = png_get_int_32(buf);
+   offset_y = png_get_int_32(buf + 4);
+   unit_type = buf[8];
+   png_set_oFFs(png_ptr, info_ptr, offset_x, offset_y, unit_type);
+}
+#endif
+
+#if defined(PNG_READ_pCAL_SUPPORTED)
+/* read the pCAL chunk (described in the PNG Extensions document) */
+void /* PRIVATE */
+png_handle_pCAL(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
+{
+   png_charp purpose;
+   png_int_32 X0, X1;
+   png_byte type, nparams;
+   png_charp buf, units, endptr;
+   png_charpp params;
+   png_size_t slength;
+   int i;
+
+   png_debug(1, "in png_handle_pCAL\n");
+
+   if (!(png_ptr->mode & PNG_HAVE_IHDR))
+      png_error(png_ptr, "Missing IHDR before pCAL");
+   else if (png_ptr->mode & PNG_HAVE_IDAT)
+   {
+      png_warning(png_ptr, "Invalid pCAL after IDAT");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_pCAL))
+   {
+      png_warning(png_ptr, "Duplicate pCAL chunk");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+
+   png_debug1(2, "Allocating and reading pCAL chunk data (%lu bytes)\n",
+      length + 1);
+   purpose = (png_charp)png_malloc_warn(png_ptr, length + 1);
+   if (purpose == NULL)
+     {
+       png_warning(png_ptr, "No memory for pCAL purpose.");
+       return;
+     }
+   slength = (png_size_t)length;
+   png_crc_read(png_ptr, (png_bytep)purpose, slength);
+
+   if (png_crc_finish(png_ptr, 0))
+   {
+      png_free(png_ptr, purpose);
+      return;
+   }
+
+   purpose[slength] = 0x00; /* null terminate the last string */
+
+   png_debug(3, "Finding end of pCAL purpose string\n");
+   for (buf = purpose; *buf; buf++)
+      /* empty loop */ ;
+
+   endptr = purpose + slength;
+
+   /* We need to have at least 12 bytes after the purpose string
+      in order to get the parameter information. */
+   if (endptr <= buf + 12)
+   {
+      png_warning(png_ptr, "Invalid pCAL data");
+      png_free(png_ptr, purpose);
+      return;
+   }
+
+   png_debug(3, "Reading pCAL X0, X1, type, nparams, and units\n");
+   X0 = png_get_int_32((png_bytep)buf+1);
+   X1 = png_get_int_32((png_bytep)buf+5);
+   type = buf[9];
+   nparams = buf[10];
+   units = buf + 11;
+
+   png_debug(3, "Checking pCAL equation type and number of parameters\n");
+   /* Check that we have the right number of parameters for known
+      equation types. */
+   if ((type == PNG_EQUATION_LINEAR && nparams != 2) ||
+       (type == PNG_EQUATION_BASE_E && nparams != 3) ||
+       (type == PNG_EQUATION_ARBITRARY && nparams != 3) ||
+       (type == PNG_EQUATION_HYPERBOLIC && nparams != 4))
+   {
+      png_warning(png_ptr, "Invalid pCAL parameters for equation type");
+      png_free(png_ptr, purpose);
+      return;
+   }
+   else if (type >= PNG_EQUATION_LAST)
+   {
+      png_warning(png_ptr, "Unrecognized equation type for pCAL chunk");
+   }
+
+   for (buf = units; *buf; buf++)
+      /* Empty loop to move past the units string. */ ;
+
+   png_debug(3, "Allocating pCAL parameters array\n");
+   params = (png_charpp)png_malloc_warn(png_ptr, (png_uint_32)(nparams
+      *sizeof(png_charp))) ;
+   if (params == NULL)
+     {
+       png_free(png_ptr, purpose);
+       png_warning(png_ptr, "No memory for pCAL params.");
+       return;
+     }
+
+   /* Get pointers to the start of each parameter string. */
+   for (i = 0; i < (int)nparams; i++)
+   {
+      buf++; /* Skip the null string terminator from previous parameter. */
+
+      png_debug1(3, "Reading pCAL parameter %d\n", i);
+      for (params[i] = buf; *buf != 0x00 && buf <= endptr; buf++)
+         /* Empty loop to move past each parameter string */ ;
+
+      /* Make sure we haven't run out of data yet */
+      if (buf > endptr)
+      {
+         png_warning(png_ptr, "Invalid pCAL data");
+         png_free(png_ptr, purpose);
+         png_free(png_ptr, params);
+         return;
+      }
+   }
+
+   png_set_pCAL(png_ptr, info_ptr, purpose, X0, X1, type, nparams,
+      units, params);
+
+   png_free(png_ptr, purpose);
+   png_free(png_ptr, params);
+}
+#endif
+
+#if defined(PNG_READ_sCAL_SUPPORTED)
+/* read the sCAL chunk */
+void /* PRIVATE */
+png_handle_sCAL(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
+{
+   png_charp buffer, ep;
+#ifdef PNG_FLOATING_POINT_SUPPORTED
+   double width, height;
+   png_charp vp;
+#else
+#ifdef PNG_FIXED_POINT_SUPPORTED
+   png_charp swidth, sheight;
+#endif
+#endif
+   png_size_t slength;
+
+   png_debug(1, "in png_handle_sCAL\n");
+
+   if (!(png_ptr->mode & PNG_HAVE_IHDR))
+      png_error(png_ptr, "Missing IHDR before sCAL");
+   else if (png_ptr->mode & PNG_HAVE_IDAT)
+   {
+      png_warning(png_ptr, "Invalid sCAL after IDAT");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sCAL))
+   {
+      png_warning(png_ptr, "Duplicate sCAL chunk");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+
+   png_debug1(2, "Allocating and reading sCAL chunk data (%lu bytes)\n",
+      length + 1);
+   buffer = (png_charp)png_malloc_warn(png_ptr, length + 1);
+   if (buffer == NULL)
+     {
+       png_warning(png_ptr, "Out of memory while processing sCAL chunk");
+       return;
+     }
+   slength = (png_size_t)length;
+   png_crc_read(png_ptr, (png_bytep)buffer, slength);
+
+   if (png_crc_finish(png_ptr, 0))
+   {
+      png_free(png_ptr, buffer);
+      return;
+   }
+
+   buffer[slength] = 0x00; /* null terminate the last string */
+
+   ep = buffer + 1;        /* skip unit byte */
+
+#ifdef PNG_FLOATING_POINT_SUPPORTED
+   width = strtod(ep, &vp);
+   if (*vp)
+   {
+       png_warning(png_ptr, "malformed width string in sCAL chunk");
+       return;
+   }
+#else
+#ifdef PNG_FIXED_POINT_SUPPORTED
+   swidth = (png_charp)png_malloc_warn(png_ptr, png_strlen(ep) + 1);
+   if (swidth == NULL)
+     {
+       png_warning(png_ptr, "Out of memory while processing sCAL chunk width");
+       return;
+     }
+   png_memcpy(swidth, ep, (png_size_t)png_strlen(ep));
+#endif
+#endif
+
+   for (ep = buffer; *ep; ep++)
+      /* empty loop */ ;
+   ep++;
+
+#ifdef PNG_FLOATING_POINT_SUPPORTED
+   height = strtod(ep, &vp);
+   if (*vp)
+   {
+       png_warning(png_ptr, "malformed height string in sCAL chunk");
+       return;
+   }
+#else
+#ifdef PNG_FIXED_POINT_SUPPORTED
+   sheight = (png_charp)png_malloc_warn(png_ptr, png_strlen(ep) + 1);
+   if (swidth == NULL)
+     {
+       png_warning(png_ptr, "Out of memory while processing sCAL chunk height");
+       return;
+     }
+   png_memcpy(sheight, ep, (png_size_t)png_strlen(ep));
+#endif
+#endif
+
+   if (buffer + slength < ep
+#ifdef PNG_FLOATING_POINT_SUPPORTED
+      || width <= 0. || height <= 0.
+#endif
+      )
+   {
+      png_warning(png_ptr, "Invalid sCAL data");
+      png_free(png_ptr, buffer);
+#if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED)
+      png_free(png_ptr, swidth);
+      png_free(png_ptr, sheight);
+#endif
+      return;
+   }
+
+
+#ifdef PNG_FLOATING_POINT_SUPPORTED
+   png_set_sCAL(png_ptr, info_ptr, buffer[0], width, height);
+#else
+#ifdef PNG_FIXED_POINT_SUPPORTED
+   png_set_sCAL_s(png_ptr, info_ptr, buffer[0], swidth, sheight);
+#endif
+#endif
+
+   png_free(png_ptr, buffer);
+#if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED)
+   png_free(png_ptr, swidth);
+   png_free(png_ptr, sheight);
+#endif
+}
+#endif
+
+#if defined(PNG_READ_tIME_SUPPORTED)
+void /* PRIVATE */
+png_handle_tIME(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
+{
+   png_byte buf[7];
+   png_time mod_time;
+
+   png_debug(1, "in png_handle_tIME\n");
+
+   if (!(png_ptr->mode & PNG_HAVE_IHDR))
+      png_error(png_ptr, "Out of place tIME chunk");
+   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tIME))
+   {
+      png_warning(png_ptr, "Duplicate tIME chunk");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+
+   if (png_ptr->mode & PNG_HAVE_IDAT)
+      png_ptr->mode |= PNG_AFTER_IDAT;
+
+   if (length != 7)
+   {
+      png_warning(png_ptr, "Incorrect tIME chunk length");
+      png_crc_finish(png_ptr, length);
+      return;
+   }
+
+   png_crc_read(png_ptr, buf, 7);
+   if (png_crc_finish(png_ptr, 0))
+      return;
+
+   mod_time.second = buf[6];
+   mod_time.minute = buf[5];
+   mod_time.hour = buf[4];
+   mod_time.day = buf[3];
+   mod_time.month = buf[2];
+   mod_time.year = png_get_uint_16(buf);
+
+   png_set_tIME(png_ptr, info_ptr, &mod_time);
+}
+#endif
+
+#if defined(PNG_READ_tEXt_SUPPORTED)
+/* Note: this does not properly handle chunks that are > 64K under DOS */
+void /* PRIVATE */
+png_handle_tEXt(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
+{
+   png_textp text_ptr;
+   png_charp key;
+   png_charp text;
+   png_uint_32 skip = 0;
+   png_size_t slength;
+   int ret;
+
+   png_debug(1, "in png_handle_tEXt\n");
+
+   if (!(png_ptr->mode & PNG_HAVE_IHDR))
+      png_error(png_ptr, "Missing IHDR before tEXt");
+
+   if (png_ptr->mode & PNG_HAVE_IDAT)
+      png_ptr->mode |= PNG_AFTER_IDAT;
+
+#ifdef PNG_MAX_MALLOC_64K
+   if (length > (png_uint_32)65535L)
+   {
+      png_warning(png_ptr, "tEXt chunk too large to fit in memory");
+      skip = length - (png_uint_32)65535L;
+      length = (png_uint_32)65535L;
+   }
+#endif
+
+   key = (png_charp)png_malloc_warn(png_ptr, length + 1);
+   if (key == NULL)
+   {
+     png_warning(png_ptr, "No memory to process text chunk.");
+     return;
+   }
+   slength = (png_size_t)length;
+   png_crc_read(png_ptr, (png_bytep)key, slength);
+
+   if (png_crc_finish(png_ptr, skip))
+   {
+      png_free(png_ptr, key);
+      return;
+   }
+
+   key[slength] = 0x00;
+
+   for (text = key; *text; text++)
+      /* empty loop to find end of key */ ;
+
+   if (text != key + slength)
+      text++;
+
+   text_ptr = (png_textp)png_malloc_warn(png_ptr, (png_uint_32)sizeof(png_text));
+   if (text_ptr == NULL)
+   {
+     png_warning(png_ptr, "Not enough memory to process text chunk.");
+     png_free(png_ptr, key);
+     return;
+   }
+   text_ptr->compression = PNG_TEXT_COMPRESSION_NONE;
+   text_ptr->key = key;
+#ifdef PNG_iTXt_SUPPORTED
+   text_ptr->lang = NULL;
+   text_ptr->lang_key = NULL;
+   text_ptr->itxt_length = 0;
+#endif
+   text_ptr->text = text;
+   text_ptr->text_length = png_strlen(text);
+
+   ret=png_set_text_2(png_ptr, info_ptr, text_ptr, 1);
+
+   png_free(png_ptr, key);
+   png_free(png_ptr, text_ptr);
+   if (ret)
+     png_warning(png_ptr, "Insufficient memory to process text chunk.");
+}
+#endif
+
+#if defined(PNG_READ_zTXt_SUPPORTED)
+/* note: this does not correctly handle chunks that are > 64K under DOS */
+void /* PRIVATE */
+png_handle_zTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
+{
+   png_textp text_ptr;
+   png_charp chunkdata;
+   png_charp text;
+   int comp_type;
+   int ret;
+   png_size_t slength, prefix_len, data_len;
+
+   png_debug(1, "in png_handle_zTXt\n");
+   if (!(png_ptr->mode & PNG_HAVE_IHDR))
+      png_error(png_ptr, "Missing IHDR before zTXt");
+
+   if (png_ptr->mode & PNG_HAVE_IDAT)
+      png_ptr->mode |= PNG_AFTER_IDAT;
+
+#ifdef PNG_MAX_MALLOC_64K
+   /* We will no doubt have problems with chunks even half this size, but
+      there is no hard and fast rule to tell us where to stop. */
+   if (length > (png_uint_32)65535L)
+   {
+     png_warning(png_ptr,"zTXt chunk too large to fit in memory");
+     png_crc_finish(png_ptr, length);
+     return;
+   }
+#endif
+
+   chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1);
+   if (chunkdata == NULL)
+   {
+     png_warning(png_ptr,"Out of memory processing zTXt chunk.");
+     return;
+   }
+   slength = (png_size_t)length;
+   png_crc_read(png_ptr, (png_bytep)chunkdata, slength);
+   if (png_crc_finish(png_ptr, 0))
+   {
+      png_free(png_ptr, chunkdata);
+      return;
+   }
+
+   chunkdata[slength] = 0x00;
+
+   for (text = chunkdata; *text; text++)
+      /* empty loop */ ;
+
+   /* zTXt must have some text after the chunkdataword */
+   if (text == chunkdata + slength)
+   {
+      comp_type = PNG_TEXT_COMPRESSION_NONE;
+      png_warning(png_ptr, "Zero length zTXt chunk");
+   }
+   else
+   {
+       comp_type = *(++text);
+       if (comp_type != PNG_TEXT_COMPRESSION_zTXt)
+       {
+          png_warning(png_ptr, "Unknown compression type in zTXt chunk");
+          comp_type = PNG_TEXT_COMPRESSION_zTXt;
+       }
+       text++;        /* skip the compression_method byte */
+   }
+   prefix_len = text - chunkdata;
+
+   chunkdata = (png_charp)png_decompress_chunk(png_ptr, comp_type, chunkdata,
+                                    (png_size_t)length, prefix_len, &data_len);
+
+   text_ptr = (png_textp)png_malloc_warn(png_ptr, (png_uint_32)sizeof(png_text));
+   if (text_ptr == NULL)
+   {
+     png_warning(png_ptr,"Not enough memory to process zTXt chunk.");
+     png_free(png_ptr, chunkdata);
+     return;
+   }
+   text_ptr->compression = comp_type;
+   text_ptr->key = chunkdata;
+#ifdef PNG_iTXt_SUPPORTED
+   text_ptr->lang = NULL;
+   text_ptr->lang_key = NULL;
+   text_ptr->itxt_length = 0;
+#endif
+   text_ptr->text = chunkdata + prefix_len;
+   text_ptr->text_length = data_len;
+
+   ret=png_set_text_2(png_ptr, info_ptr, text_ptr, 1);
+
+   png_free(png_ptr, text_ptr);
+   png_free(png_ptr, chunkdata);
+   if (ret)
+     png_error(png_ptr, "Insufficient memory to store zTXt chunk.");
+}
+#endif
+
+#if defined(PNG_READ_iTXt_SUPPORTED)
+/* note: this does not correctly handle chunks that are > 64K under DOS */
+void /* PRIVATE */
+png_handle_iTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
+{
+   png_textp text_ptr;
+   png_charp chunkdata;
+   png_charp key, lang, text, lang_key;
+   int comp_flag;
+   int comp_type = 0;
+   int ret;
+   png_size_t slength, prefix_len, data_len;
+
+   png_debug(1, "in png_handle_iTXt\n");
+
+   if (!(png_ptr->mode & PNG_HAVE_IHDR))
+      png_error(png_ptr, "Missing IHDR before iTXt");
+
+   if (png_ptr->mode & PNG_HAVE_IDAT)
+      png_ptr->mode |= PNG_AFTER_IDAT;
+
+#ifdef PNG_MAX_MALLOC_64K
+   /* We will no doubt have problems with chunks even half this size, but
+      there is no hard and fast rule to tell us where to stop. */
+   if (length > (png_uint_32)65535L)
+   {
+     png_warning(png_ptr,"iTXt chunk too large to fit in memory");
+     png_crc_finish(png_ptr, length);
+     return;
+   }
+#endif
+
+   chunkdata = (png_charp)png_malloc_warn(png_ptr, length + 1);
+   if (chunkdata == NULL)
+   {
+     png_warning(png_ptr, "No memory to process iTXt chunk.");
+     return;
+   }
+   slength = (png_size_t)length;
+   png_crc_read(png_ptr, (png_bytep)chunkdata, slength);
+   if (png_crc_finish(png_ptr, 0))
+   {
+      png_free(png_ptr, chunkdata);
+      return;
+   }
+
+   chunkdata[slength] = 0x00;
+
+   for (lang = chunkdata; *lang; lang++)
+      /* empty loop */ ;
+   lang++;        /* skip NUL separator */
+
+   /* iTXt must have a language tag (possibly empty), two compression bytes,
+      translated keyword (possibly empty), and possibly some text after the
+      keyword */
+
+   if (lang >= chunkdata + slength)
+   {
+      comp_flag = PNG_TEXT_COMPRESSION_NONE;
+      png_warning(png_ptr, "Zero length iTXt chunk");
+   }
+   else
+   {
+       comp_flag = *lang++;
+       comp_type = *lang++;
+   }
+
+   for (lang_key = lang; *lang_key; lang_key++)
+      /* empty loop */ ;
+   lang_key++;        /* skip NUL separator */
+
+   for (text = lang_key; *text; text++)
+      /* empty loop */ ;
+   text++;        /* skip NUL separator */
+
+   prefix_len = text - chunkdata;
+
+   key=chunkdata;
+   if (comp_flag)
+       chunkdata = png_decompress_chunk(png_ptr, comp_type, chunkdata,
+          (size_t)length, prefix_len, &data_len);
+   else
+       data_len=png_strlen(chunkdata + prefix_len);
+   text_ptr = (png_textp)png_malloc_warn(png_ptr, (png_uint_32)sizeof(png_text));
+   if (text_ptr == NULL)
+   {
+     png_warning(png_ptr,"Not enough memory to process iTXt chunk.");
+     png_free(png_ptr, chunkdata);
+     return;
+   }
+   text_ptr->compression = (int)comp_flag + 1;
+   text_ptr->lang_key = chunkdata+(lang_key-key);
+   text_ptr->lang = chunkdata+(lang-key);
+   text_ptr->itxt_length = data_len;
+   text_ptr->text_length = 0;
+   text_ptr->key = chunkdata;
+   text_ptr->text = chunkdata + prefix_len;
+
+   ret=png_set_text_2(png_ptr, info_ptr, text_ptr, 1);
+
+   png_free(png_ptr, text_ptr);
+   png_free(png_ptr, chunkdata);
+   if (ret)
+     png_error(png_ptr, "Insufficient memory to store iTXt chunk.");
+}
+#endif
+
+/* This function is called when we haven't found a handler for a
+   chunk.  If there isn't a problem with the chunk itself (ie bad
+   chunk name, CRC, or a critical chunk), the chunk is silently ignored
+   -- unless the PNG_FLAG_UNKNOWN_CHUNKS_SUPPORTED flag is on in which
+   case it will be saved away to be written out later. */
+void /* PRIVATE */
+png_handle_unknown(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
+{
+   png_uint_32 skip = 0;
+
+   png_debug(1, "in png_handle_unknown\n");
+
+   if (png_ptr->mode & PNG_HAVE_IDAT)
+   {
+#ifdef PNG_USE_LOCAL_ARRAYS
+      PNG_IDAT;
+#endif
+      if (png_memcmp(png_ptr->chunk_name, png_IDAT, 4))  /* not an IDAT */
+         png_ptr->mode |= PNG_AFTER_IDAT;
+   }
+
+   png_check_chunk_name(png_ptr, png_ptr->chunk_name);
+
+   if (!(png_ptr->chunk_name[0] & 0x20))
+   {
+#if defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)
+      if(png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
+           HANDLE_CHUNK_ALWAYS
+#if defined(PNG_READ_USER_CHUNKS_SUPPORTED)
+           && png_ptr->read_user_chunk_fn == NULL
+#endif
+        )
+#endif
+          png_chunk_error(png_ptr, "unknown critical chunk");
+   }
+
+#if defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)
+   if (png_ptr->flags & PNG_FLAG_KEEP_UNKNOWN_CHUNKS)
+   {
+       png_unknown_chunk chunk;
+
+#ifdef PNG_MAX_MALLOC_64K
+       if (length > (png_uint_32)65535L)
+       {
+           png_warning(png_ptr, "unknown chunk too large to fit in memory");
+           skip = length - (png_uint_32)65535L;
+           length = (png_uint_32)65535L;
+       }
+#endif
+       png_strcpy((png_charp)chunk.name, (png_charp)png_ptr->chunk_name);
+       chunk.data = (png_bytep)png_malloc(png_ptr, length);
+       chunk.size = (png_size_t)length;
+       png_crc_read(png_ptr, (png_bytep)chunk.data, length);
+#if defined(PNG_READ_USER_CHUNKS_SUPPORTED)
+       if(png_ptr->read_user_chunk_fn != NULL)
+       {
+          /* callback to user unknown chunk handler */
+          if ((*(png_ptr->read_user_chunk_fn)) (png_ptr, &chunk) <= 0)
+          {
+             if (!(png_ptr->chunk_name[0] & 0x20))
+                if(png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
+                     HANDLE_CHUNK_ALWAYS)
+                 {
+                   png_free(png_ptr, chunk.data);
+                   png_chunk_error(png_ptr, "unknown critical chunk");
+                 }
+             png_set_unknown_chunks(png_ptr, info_ptr, &chunk, 1);
+          }
+       }
+       else
+#endif
+          png_set_unknown_chunks(png_ptr, info_ptr, &chunk, 1);
+       png_free(png_ptr, chunk.data);
+   }
+   else
+#endif
+      skip = length;
+
+   png_crc_finish(png_ptr, skip);
+
+#if !defined(PNG_READ_USER_CHUNKS_SUPPORTED)
+   info_ptr = info_ptr; /* quiet compiler warnings about unused info_ptr */
+#endif
+}
+
+/* This function is called to verify that a chunk name is valid.
+   This function can't have the "critical chunk check" incorporated
+   into it, since in the future we will need to be able to call user
+   functions to handle unknown critical chunks after we check that
+   the chunk name itself is valid. */
+
+#define isnonalpha(c) ((c) < 41 || (c) > 122 || ((c) > 90 && (c) < 97))
+
+void /* PRIVATE */
+png_check_chunk_name(png_structp png_ptr, png_bytep chunk_name)
+{
+   png_debug(1, "in png_check_chunk_name\n");
+   if (isnonalpha(chunk_name[0]) || isnonalpha(chunk_name[1]) ||
+       isnonalpha(chunk_name[2]) || isnonalpha(chunk_name[3]))
+   {
+      png_chunk_error(png_ptr, "invalid chunk type");
+   }
+}
+
+/* Combines the row recently read in with the existing pixels in the
+   row.  This routine takes care of alpha and transparency if requested.
+   This routine also handles the two methods of progressive display
+   of interlaced images, depending on the mask value.
+   The mask value describes which pixels are to be combined with
+   the row.  The pattern always repeats every 8 pixels, so just 8
+   bits are needed.  A one indicates the pixel is to be combined,
+   a zero indicates the pixel is to be skipped.  This is in addition
+   to any alpha or transparency value associated with the pixel.  If
+   you want all pixels to be combined, pass 0xff (255) in mask.  */
+#ifndef PNG_HAVE_ASSEMBLER_COMBINE_ROW
+void /* PRIVATE */
+png_combine_row(png_structp png_ptr, png_bytep row, int mask)
+{
+   png_debug(1,"in png_combine_row\n");
+   if (mask == 0xff)
+   {
+      png_memcpy(row, png_ptr->row_buf + 1,
+         (png_size_t)((png_ptr->width *
+         png_ptr->row_info.pixel_depth + 7) >> 3));
+   }
+   else
+   {
+      switch (png_ptr->row_info.pixel_depth)
+      {
+         case 1:
+         {
+            png_bytep sp = png_ptr->row_buf + 1;
+            png_bytep dp = row;
+            int s_inc, s_start, s_end;
+            int m = 0x80;
+            int shift;
+            png_uint_32 i;
+            png_uint_32 row_width = png_ptr->width;
+
+#if defined(PNG_READ_PACKSWAP_SUPPORTED)
+            if (png_ptr->transformations & PNG_PACKSWAP)
+            {
+                s_start = 0;
+                s_end = 7;
+                s_inc = 1;
+            }
+            else
+#endif
+            {
+                s_start = 7;
+                s_end = 0;
+                s_inc = -1;
+            }
+
+            shift = s_start;
+
+            for (i = 0; i < row_width; i++)
+            {
+               if (m & mask)
+               {
+                  int value;
+
+                  value = (*sp >> shift) & 0x01;
+                  *dp &= (png_byte)((0x7f7f >> (7 - shift)) & 0xff);
+                  *dp |= (png_byte)(value << shift);
+               }
+
+               if (shift == s_end)
+               {
+                  shift = s_start;
+                  sp++;
+                  dp++;
+               }
+               else
+                  shift += s_inc;
+
+               if (m == 1)
+                  m = 0x80;
+               else
+                  m >>= 1;
+            }
+            break;
+         }
+         case 2:
+         {
+            png_bytep sp = png_ptr->row_buf + 1;
+            png_bytep dp = row;
+            int s_start, s_end, s_inc;
+            int m = 0x80;
+            int shift;
+            png_uint_32 i;
+            png_uint_32 row_width = png_ptr->width;
+            int value;
+
+#if defined(PNG_READ_PACKSWAP_SUPPORTED)
+            if (png_ptr->transformations & PNG_PACKSWAP)
+            {
+               s_start = 0;
+               s_end = 6;
+               s_inc = 2;
+            }
+            else
+#endif
+            {
+               s_start = 6;
+               s_end = 0;
+               s_inc = -2;
+            }
+
+            shift = s_start;
+
+            for (i = 0; i < row_width; i++)
+            {
+               if (m & mask)
+               {
+                  value = (*sp >> shift) & 0x03;
+                  *dp &= (png_byte)((0x3f3f >> (6 - shift)) & 0xff);
+                  *dp |= (png_byte)(value << shift);
+               }
+
+               if (shift == s_end)
+               {
+                  shift = s_start;
+                  sp++;
+                  dp++;
+               }
+               else
+                  shift += s_inc;
+               if (m == 1)
+                  m = 0x80;
+               else
+                  m >>= 1;
+            }
+            break;
+         }
+         case 4:
+         {
+            png_bytep sp = png_ptr->row_buf + 1;
+            png_bytep dp = row;
+            int s_start, s_end, s_inc;
+            int m = 0x80;
+            int shift;
+            png_uint_32 i;
+            png_uint_32 row_width = png_ptr->width;
+            int value;
+
+#if defined(PNG_READ_PACKSWAP_SUPPORTED)
+            if (png_ptr->transformations & PNG_PACKSWAP)
+            {
+               s_start = 0;
+               s_end = 4;
+               s_inc = 4;
+            }
+            else
+#endif
+            {
+               s_start = 4;
+               s_end = 0;
+               s_inc = -4;
+            }
+            shift = s_start;
+
+            for (i = 0; i < row_width; i++)
+            {
+               if (m & mask)
+               {
+                  value = (*sp >> shift) & 0xf;
+                  *dp &= (png_byte)((0xf0f >> (4 - shift)) & 0xff);
+                  *dp |= (png_byte)(value << shift);
+               }
+
+               if (shift == s_end)
+               {
+                  shift = s_start;
+                  sp++;
+                  dp++;
+               }
+               else
+                  shift += s_inc;
+               if (m == 1)
+                  m = 0x80;
+               else
+                  m >>= 1;
+            }
+            break;
+         }
+         default:
+         {
+            png_bytep sp = png_ptr->row_buf + 1;
+            png_bytep dp = row;
+            png_size_t pixel_bytes = (png_ptr->row_info.pixel_depth >> 3);
+            png_uint_32 i;
+            png_uint_32 row_width = png_ptr->width;
+            png_byte m = 0x80;
+
+
+            for (i = 0; i < row_width; i++)
+            {
+               if (m & mask)
+               {
+                  png_memcpy(dp, sp, pixel_bytes);
+               }
+
+               sp += pixel_bytes;
+               dp += pixel_bytes;
+
+               if (m == 1)
+                  m = 0x80;
+               else
+                  m >>= 1;
+            }
+            break;
+         }
+      }
+   }
+}
+#endif /* !PNG_HAVE_ASSEMBLER_COMBINE_ROW */
+
+#ifdef PNG_READ_INTERLACING_SUPPORTED
+#ifndef PNG_HAVE_ASSEMBLER_READ_INTERLACE   /* else in pngvcrd.c, pnggccrd.c */
+/* OLD pre-1.0.9 interface:
+void png_do_read_interlace(png_row_infop row_info, png_bytep row, int pass,
+   png_uint_32 transformations)
+ */
+void /* PRIVATE */
+png_do_read_interlace(png_structp png_ptr)
+{
+   png_row_infop row_info = &(png_ptr->row_info);
+   png_bytep row = png_ptr->row_buf + 1;
+   int pass = png_ptr->pass;
+   png_uint_32 transformations = png_ptr->transformations;
+#ifdef PNG_USE_LOCAL_ARRAYS
+   /* arrays to facilitate easy interlacing - use pass (0 - 6) as index */
+   /* offset to next interlace block */
+   const int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
+#endif
+
+   png_debug(1,"in png_do_read_interlace (stock C version)\n");
+   if (row != NULL && row_info != NULL)
+   {
+      png_uint_32 final_width;
+
+      final_width = row_info->width * png_pass_inc[pass];
+
+      switch (row_info->pixel_depth)
+      {
+         case 1:
+         {
+            png_bytep sp = row + (png_size_t)((row_info->width - 1) >> 3);
+            png_bytep dp = row + (png_size_t)((final_width - 1) >> 3);
+            int sshift, dshift;
+            int s_start, s_end, s_inc;
+            int jstop = png_pass_inc[pass];
+            png_byte v;
+            png_uint_32 i;
+            int j;
+
+#if defined(PNG_READ_PACKSWAP_SUPPORTED)
+            if (transformations & PNG_PACKSWAP)
+            {
+                sshift = (int)((row_info->width + 7) & 0x07);
+                dshift = (int)((final_width + 7) & 0x07);
+                s_start = 7;
+                s_end = 0;
+                s_inc = -1;
+            }
+            else
+#endif
+            {
+                sshift = 7 - (int)((row_info->width + 7) & 0x07);
+                dshift = 7 - (int)((final_width + 7) & 0x07);
+                s_start = 0;
+                s_end = 7;
+                s_inc = 1;
+            }
+
+            for (i = 0; i < row_info->width; i++)
+            {
+               v = (png_byte)((*sp >> sshift) & 0x01);
+               for (j = 0; j < jstop; j++)
+               {
+                  *dp &= (png_byte)((0x7f7f >> (7 - dshift)) & 0xff);
+                  *dp |= (png_byte)(v << dshift);
+                  if (dshift == s_end)
+                  {
+                     dshift = s_start;
+                     dp--;
+                  }
+                  else
+                     dshift += s_inc;
+               }
+               if (sshift == s_end)
+               {
+                  sshift = s_start;
+                  sp--;
+               }
+               else
+                  sshift += s_inc;
+            }
+            break;
+         }
+         case 2:
+         {
+            png_bytep sp = row + (png_uint_32)((row_info->width - 1) >> 2);
+            png_bytep dp = row + (png_uint_32)((final_width - 1) >> 2);
+            int sshift, dshift;
+            int s_start, s_end, s_inc;
+            int jstop = png_pass_inc[pass];
+            png_uint_32 i;
+
+#if defined(PNG_READ_PACKSWAP_SUPPORTED)
+            if (transformations & PNG_PACKSWAP)
+            {
+               sshift = (int)(((row_info->width + 3) & 0x03) << 1);
+               dshift = (int)(((final_width + 3) & 0x03) << 1);
+               s_start = 6;
+               s_end = 0;
+               s_inc = -2;
+            }
+            else
+#endif
+            {
+               sshift = (int)((3 - ((row_info->width + 3) & 0x03)) << 1);
+               dshift = (int)((3 - ((final_width + 3) & 0x03)) << 1);
+               s_start = 0;
+               s_end = 6;
+               s_inc = 2;
+            }
+
+            for (i = 0; i < row_info->width; i++)
+            {
+               png_byte v;
+               int j;
+
+               v = (png_byte)((*sp >> sshift) & 0x03);
+               for (j = 0; j < jstop; j++)
+               {
+                  *dp &= (png_byte)((0x3f3f >> (6 - dshift)) & 0xff);
+                  *dp |= (png_byte)(v << dshift);
+                  if (dshift == s_end)
+                  {
+                     dshift = s_start;
+                     dp--;
+                  }
+                  else
+                     dshift += s_inc;
+               }
+               if (sshift == s_end)
+               {
+                  sshift = s_start;
+                  sp--;
+               }
+               else
+                  sshift += s_inc;
+            }
+            break;
+         }
+         case 4:
+         {
+            png_bytep sp = row + (png_size_t)((row_info->width - 1) >> 1);
+            png_bytep dp = row + (png_size_t)((final_width - 1) >> 1);
+            int sshift, dshift;
+            int s_start, s_end, s_inc;
+            png_uint_32 i;
+            int jstop = png_pass_inc[pass];
+
+#if defined(PNG_READ_PACKSWAP_SUPPORTED)
+            if (transformations & PNG_PACKSWAP)
+            {
+               sshift = (int)(((row_info->width + 1) & 0x01) << 2);
+               dshift = (int)(((final_width + 1) & 0x01) << 2);
+               s_start = 4;
+               s_end = 0;
+               s_inc = -4;
+            }
+            else
+#endif
+            {
+               sshift = (int)((1 - ((row_info->width + 1) & 0x01)) << 2);
+               dshift = (int)((1 - ((final_width + 1) & 0x01)) << 2);
+               s_start = 0;
+               s_end = 4;
+               s_inc = 4;
+            }
+
+            for (i = 0; i < row_info->width; i++)
+            {
+               png_byte v = (png_byte)((*sp >> sshift) & 0xf);
+               int j;
+
+               for (j = 0; j < jstop; j++)
+               {
+                  *dp &= (png_byte)((0xf0f >> (4 - dshift)) & 0xff);
+                  *dp |= (png_byte)(v << dshift);
+                  if (dshift == s_end)
+                  {
+                     dshift = s_start;
+                     dp--;
+                  }
+                  else
+                     dshift += s_inc;
+               }
+               if (sshift == s_end)
+               {
+                  sshift = s_start;
+                  sp--;
+               }
+               else
+                  sshift += s_inc;
+            }
+            break;
+         }
+         default:
+         {
+            png_size_t pixel_bytes = (row_info->pixel_depth >> 3);
+            png_bytep sp = row + (png_size_t)(row_info->width - 1) * pixel_bytes;
+            png_bytep dp = row + (png_size_t)(final_width - 1) * pixel_bytes;
+
+            int jstop = png_pass_inc[pass];
+            png_uint_32 i;
+
+            for (i = 0; i < row_info->width; i++)
+            {
+               png_byte v[8];
+               int j;
+
+               png_memcpy(v, sp, pixel_bytes);
+               for (j = 0; j < jstop; j++)
+               {
+                  png_memcpy(dp, v, pixel_bytes);
+                  dp -= pixel_bytes;
+               }
+               sp -= pixel_bytes;
+            }
+            break;
+         }
+      }
+      row_info->width = final_width;
+      row_info->rowbytes = ((final_width *
+         (png_uint_32)row_info->pixel_depth + 7) >> 3);
+   }
+#if !defined(PNG_READ_PACKSWAP_SUPPORTED)
+   transformations = transformations; /* silence compiler warning */
+#endif
+}
+#endif /* !PNG_HAVE_ASSEMBLER_READ_INTERLACE */
+#endif /* PNG_READ_INTERLACING_SUPPORTED */
+
+#ifndef PNG_HAVE_ASSEMBLER_READ_FILTER_ROW
+void /* PRIVATE */
+png_read_filter_row(png_structp png_ptr, png_row_infop row_info, png_bytep row,
+   png_bytep prev_row, int filter)
+{
+   png_debug(1, "in png_read_filter_row\n");
+   png_debug2(2,"row = %lu, filter = %d\n", png_ptr->row_number, filter);
+   switch (filter)
+   {
+      case PNG_FILTER_VALUE_NONE:
+         break;
+      case PNG_FILTER_VALUE_SUB:
+      {
+         png_uint_32 i;
+         png_uint_32 istop = row_info->rowbytes;
+         png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;
+         png_bytep rp = row + bpp;
+         png_bytep lp = row;
+
+         for (i = bpp; i < istop; i++)
+         {
+            *rp = (png_byte)(((int)(*rp) + (int)(*lp++)) & 0xff);
+            rp++;
+         }
+         break;
+      }
+      case PNG_FILTER_VALUE_UP:
+      {
+         png_uint_32 i;
+         png_uint_32 istop = row_info->rowbytes;
+         png_bytep rp = row;
+         png_bytep pp = prev_row;
+
+         for (i = 0; i < istop; i++)
+         {
+            *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);
+            rp++;
+         }
+         break;
+      }
+      case PNG_FILTER_VALUE_AVG:
+      {
+         png_uint_32 i;
+         png_bytep rp = row;
+         png_bytep pp = prev_row;
+         png_bytep lp = row;
+         png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;
+         png_uint_32 istop = row_info->rowbytes - bpp;
+
+         for (i = 0; i < bpp; i++)
+         {
+            *rp = (png_byte)(((int)(*rp) +
+               ((int)(*pp++) / 2 )) & 0xff);
+            rp++;
+         }
+
+         for (i = 0; i < istop; i++)
+         {
+            *rp = (png_byte)(((int)(*rp) +
+               (int)(*pp++ + *lp++) / 2 ) & 0xff);
+            rp++;
+         }
+         break;
+      }
+      case PNG_FILTER_VALUE_PAETH:
+      {
+         png_uint_32 i;
+         png_bytep rp = row;
+         png_bytep pp = prev_row;
+         png_bytep lp = row;
+         png_bytep cp = prev_row;
+         png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;
+         png_uint_32 istop=row_info->rowbytes - bpp;
+
+         for (i = 0; i < bpp; i++)
+         {
+            *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);
+            rp++;
+         }
+
+         for (i = 0; i < istop; i++)   /* use leftover rp,pp */
+         {
+            int a, b, c, pa, pb, pc, p;
+
+            a = *lp++;
+            b = *pp++;
+            c = *cp++;
+
+            p = b - c;
+            pc = a - c;
+
+#ifdef PNG_USE_ABS
+            pa = abs(p);
+            pb = abs(pc);
+            pc = abs(p + pc);
+#else
+            pa = p < 0 ? -p : p;
+            pb = pc < 0 ? -pc : pc;
+            pc = (p + pc) < 0 ? -(p + pc) : p + pc;
+#endif
+
+            /*
+               if (pa <= pb && pa <= pc)
+                  p = a;
+               else if (pb <= pc)
+                  p = b;
+               else
+                  p = c;
+             */
+
+            p = (pa <= pb && pa <=pc) ? a : (pb <= pc) ? b : c;
+
+            *rp = (png_byte)(((int)(*rp) + p) & 0xff);
+            rp++;
+         }
+         break;
+      }
+      default:
+         png_warning(png_ptr, "Ignoring bad adaptive filter type");
+         *row=0;
+         break;
+   }
+}
+#endif /* !PNG_HAVE_ASSEMBLER_READ_FILTER_ROW */
+
+void /* PRIVATE */
+png_read_finish_row(png_structp png_ptr)
+{
+#ifdef PNG_USE_LOCAL_ARRAYS
+   /* arrays to facilitate easy interlacing - use pass (0 - 6) as index */
+
+   /* start of interlace block */
+   const int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
+
+   /* offset to next interlace block */
+   const int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
+
+   /* start of interlace block in the y direction */
+   const int png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};
+
+   /* offset to next interlace block in the y direction */
+   const int png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
+#endif
+
+   png_debug(1, "in png_read_finish_row\n");
+   png_ptr->row_number++;
+   if (png_ptr->row_number < png_ptr->num_rows)
+      return;
+
+   if (png_ptr->interlaced)
+   {
+      png_ptr->row_number = 0;
+      png_memset_check(png_ptr, png_ptr->prev_row, 0, png_ptr->rowbytes + 1);
+      do
+      {
+         png_ptr->pass++;
+         if (png_ptr->pass >= 7)
+            break;
+         png_ptr->iwidth = (png_ptr->width +
+            png_pass_inc[png_ptr->pass] - 1 -
+            png_pass_start[png_ptr->pass]) /
+            png_pass_inc[png_ptr->pass];
+            png_ptr->irowbytes = ((png_ptr->iwidth *
+               (png_uint_32)png_ptr->pixel_depth + 7) >> 3) +1;
+
+         if (!(png_ptr->transformations & PNG_INTERLACE))
+         {
+            png_ptr->num_rows = (png_ptr->height +
+               png_pass_yinc[png_ptr->pass] - 1 -
+               png_pass_ystart[png_ptr->pass]) /
+               png_pass_yinc[png_ptr->pass];
+            if (!(png_ptr->num_rows))
+               continue;
+         }
+         else  /* if (png_ptr->transformations & PNG_INTERLACE) */
+            break;
+      } while (png_ptr->iwidth == 0);
+
+      if (png_ptr->pass < 7)
+         return;
+   }
+
+   if (!(png_ptr->flags & PNG_FLAG_ZLIB_FINISHED))
+   {
+#ifdef PNG_USE_LOCAL_ARRAYS
+      PNG_IDAT;
+#endif
+      char extra;
+      int ret;
+
+      png_ptr->zstream.next_out = (Byte *)&extra;
+      png_ptr->zstream.avail_out = (uInt)1;
+      for(;;)
+      {
+         if (!(png_ptr->zstream.avail_in))
+         {
+            while (!png_ptr->idat_size)
+            {
+               png_byte chunk_length[4];
+
+               png_crc_finish(png_ptr, 0);
+
+               png_read_data(png_ptr, chunk_length, 4);
+               png_ptr->idat_size = png_get_uint_32(chunk_length);
+
+               png_reset_crc(png_ptr);
+               png_crc_read(png_ptr, png_ptr->chunk_name, 4);
+               if (png_memcmp(png_ptr->chunk_name, (png_bytep)png_IDAT, 4))
+                  png_error(png_ptr, "Not enough image data");
+
+            }
+            png_ptr->zstream.avail_in = (uInt)png_ptr->zbuf_size;
+            png_ptr->zstream.next_in = png_ptr->zbuf;
+            if (png_ptr->zbuf_size > png_ptr->idat_size)
+               png_ptr->zstream.avail_in = (uInt)png_ptr->idat_size;
+            png_crc_read(png_ptr, png_ptr->zbuf, png_ptr->zstream.avail_in);
+            png_ptr->idat_size -= png_ptr->zstream.avail_in;
+         }
+         ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH);
+         if (ret == Z_STREAM_END)
+         {
+            if (!(png_ptr->zstream.avail_out) || png_ptr->zstream.avail_in ||
+               png_ptr->idat_size)
+               png_warning(png_ptr, "Extra compressed data");
+            png_ptr->mode |= PNG_AFTER_IDAT;
+            png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;
+            break;
+         }
+         if (ret != Z_OK)
+            png_error(png_ptr, png_ptr->zstream.msg ? png_ptr->zstream.msg :
+                      "Decompression Error");
+
+         if (!(png_ptr->zstream.avail_out))
+         {
+            png_warning(png_ptr, "Extra compressed data.");
+            png_ptr->mode |= PNG_AFTER_IDAT;
+            png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;
+            break;
+         }
+
+      }
+      png_ptr->zstream.avail_out = 0;
+   }
+
+   if (png_ptr->idat_size || png_ptr->zstream.avail_in)
+      png_warning(png_ptr, "Extra compression data");
+
+   inflateReset(&png_ptr->zstream);
+
+   png_ptr->mode |= PNG_AFTER_IDAT;
+}
+
+void /* PRIVATE */
+png_read_start_row(png_structp png_ptr)
+{
+#ifdef PNG_USE_LOCAL_ARRAYS
+   /* arrays to facilitate easy interlacing - use pass (0 - 6) as index */
+
+   /* start of interlace block */
+   const int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
+
+   /* offset to next interlace block */
+   const int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
+
+   /* start of interlace block in the y direction */
+   const int png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};
+
+   /* offset to next interlace block in the y direction */
+   const int png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
+#endif
+
+   int max_pixel_depth;
+   png_uint_32 row_bytes;
+
+   png_debug(1, "in png_read_start_row\n");
+   png_ptr->zstream.avail_in = 0;
+   png_init_read_transformations(png_ptr);
+   if (png_ptr->interlaced)
+   {
+      if (!(png_ptr->transformations & PNG_INTERLACE))
+         png_ptr->num_rows = (png_ptr->height + png_pass_yinc[0] - 1 -
+            png_pass_ystart[0]) / png_pass_yinc[0];
+      else
+         png_ptr->num_rows = png_ptr->height;
+
+      png_ptr->iwidth = (png_ptr->width +
+         png_pass_inc[png_ptr->pass] - 1 -
+         png_pass_start[png_ptr->pass]) /
+         png_pass_inc[png_ptr->pass];
+
+         row_bytes = ((png_ptr->iwidth *
+            (png_uint_32)png_ptr->pixel_depth + 7) >> 3) +1;
+         png_ptr->irowbytes = (png_size_t)row_bytes;
+         if((png_uint_32)png_ptr->irowbytes != row_bytes)
+            png_error(png_ptr, "Rowbytes overflow in png_read_start_row");
+   }
+   else
+   {
+      png_ptr->num_rows = png_ptr->height;
+      png_ptr->iwidth = png_ptr->width;
+      png_ptr->irowbytes = png_ptr->rowbytes + 1;
+   }
+   max_pixel_depth = png_ptr->pixel_depth;
+
+#if defined(PNG_READ_PACK_SUPPORTED)
+   if ((png_ptr->transformations & PNG_PACK) && png_ptr->bit_depth < 8)
+      max_pixel_depth = 8;
+#endif
+
+#if defined(PNG_READ_EXPAND_SUPPORTED)
+   if (png_ptr->transformations & PNG_EXPAND)
+   {
+      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
+      {
+         if (png_ptr->num_trans)
+            max_pixel_depth = 32;
+         else
+            max_pixel_depth = 24;
+      }
+      else if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)
+      {
+         if (max_pixel_depth < 8)
+            max_pixel_depth = 8;
+         if (png_ptr->num_trans)
+            max_pixel_depth *= 2;
+      }
+      else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)
+      {
+         if (png_ptr->num_trans)
+         {
+            max_pixel_depth *= 4;
+            max_pixel_depth /= 3;
+         }
+      }
+   }
+#endif
+
+#if defined(PNG_READ_FILLER_SUPPORTED)
+   if (png_ptr->transformations & (PNG_FILLER))
+   {
+      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
+         max_pixel_depth = 32;
+      else if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)
+      {
+         if (max_pixel_depth <= 8)
+            max_pixel_depth = 16;
+         else
+            max_pixel_depth = 32;
+      }
+      else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)
+      {
+         if (max_pixel_depth <= 32)
+            max_pixel_depth = 32;
+         else
+            max_pixel_depth = 64;
+      }
+   }
+#endif
+
+#if defined(PNG_READ_GRAY_TO_RGB_SUPPORTED)
+   if (png_ptr->transformations & PNG_GRAY_TO_RGB)
+   {
+      if (
+#if defined(PNG_READ_EXPAND_SUPPORTED)
+        (png_ptr->num_trans && (png_ptr->transformations & PNG_EXPAND)) ||
+#endif
+#if defined(PNG_READ_FILLER_SUPPORTED)
+        (png_ptr->transformations & (PNG_FILLER)) ||
+#endif
+        png_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
+      {
+         if (max_pixel_depth <= 16)
+            max_pixel_depth = 32;
+         else
+            max_pixel_depth = 64;
+      }
+      else
+      {
+         if (max_pixel_depth <= 8)
+           {
+             if (png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
+               max_pixel_depth = 32;
+             else
+               max_pixel_depth = 24;
+           }
+         else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
+            max_pixel_depth = 64;
+         else
+            max_pixel_depth = 48;
+      }
+   }
+#endif
+
+#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) && \
+defined(PNG_USER_TRANSFORM_PTR_SUPPORTED)
+   if(png_ptr->transformations & PNG_USER_TRANSFORM)
+     {
+       int user_pixel_depth=png_ptr->user_transform_depth*
+         png_ptr->user_transform_channels;
+       if(user_pixel_depth > max_pixel_depth)
+         max_pixel_depth=user_pixel_depth;
+     }
+#endif
+
+   /* align the width on the next larger 8 pixels.  Mainly used
+      for interlacing */
+   row_bytes = ((png_ptr->width + 7) & ~((png_uint_32)7));
+   /* calculate the maximum bytes needed, adding a byte and a pixel
+      for safety's sake */
+   row_bytes = ((row_bytes * (png_uint_32)max_pixel_depth + 7) >> 3) +
+      1 + ((max_pixel_depth + 7) >> 3);
+#ifdef PNG_MAX_MALLOC_64K
+   if (row_bytes > (png_uint_32)65536L)
+      png_error(png_ptr, "This image requires a row greater than 64KB");
+#endif
+   png_ptr->big_row_buf = (png_bytep)png_malloc(png_ptr, row_bytes+64);
+   png_ptr->row_buf = png_ptr->big_row_buf+32;
+#if defined(PNG_DEBUG) && defined(PNG_USE_PNGGCCRD)
+   png_ptr->row_buf_size = row_bytes;
+#endif
+
+#ifdef PNG_MAX_MALLOC_64K
+   if ((png_uint_32)png_ptr->rowbytes + 1 > (png_uint_32)65536L)
+      png_error(png_ptr, "This image requires a row greater than 64KB");
+#endif
+   png_ptr->prev_row = (png_bytep)png_malloc(png_ptr, (png_uint_32)(
+      png_ptr->rowbytes + 1));
+
+   png_memset_check(png_ptr, png_ptr->prev_row, 0, png_ptr->rowbytes + 1);
+
+   png_debug1(3, "width = %lu,\n", png_ptr->width);
+   png_debug1(3, "height = %lu,\n", png_ptr->height);
+   png_debug1(3, "iwidth = %lu,\n", png_ptr->iwidth);
+   png_debug1(3, "num_rows = %lu\n", png_ptr->num_rows);
+   png_debug1(3, "rowbytes = %lu,\n", png_ptr->rowbytes);
+   png_debug1(3, "irowbytes = %lu,\n", png_ptr->irowbytes);
+
+   png_ptr->flags |= PNG_FLAG_ROW_INIT;
+}
diff -Nru qt-x11-free-3.3.3.orig/src/iconview/qiconview.cpp qt-x11-free-3.3.3/src/iconview/qiconview.cpp
--- qt-x11-free-3.3.3.orig/src/iconview/qiconview.cpp	2004-08-22 13:20:57.132011168 +0200
+++ qt-x11-free-3.3.3/src/iconview/qiconview.cpp	2004-08-22 13:24:20.323593343 +0200
@@ -236,6 +236,7 @@
     QPoint dragStartPos;
     QFontMetrics *fm;
     int minLeftBearing, minRightBearing;
+    int rubberStartX, rubberStartY;
 
     uint mousePressed		:1;
     uint cleared		:1;
@@ -255,9 +256,11 @@
     uint firstSizeHint : 1;
     uint showTips		:1;
     uint pressedSelected	:1;
+    uint canStartRubber		:1;
     uint dragging		:1;
     uint drawActiveSelection	:1;
     uint inMenuMode		:1;
+    uint controlPressed         :1;
 
     QIconViewToolTip *toolTip;
     QPixmapCache maskCache;
@@ -1060,7 +1063,7 @@
 
     if ( view ) {
 	if ( QRect( view->contentsX(), view->contentsY(),
-		    view->visibleWidth(), view->visibleHeight() ).
+		    view->visibleWidthSB(), view->visibleHeightSB() ).
 	     intersects( oR ) )
 	    view->repaintContents( oR.x() - 1, oR.y() - 1,
 				   oR.width() + 2, oR.height() + 2, FALSE );
@@ -1104,7 +1107,7 @@
 
     if ( view ) {
 	if ( QRect( view->contentsX(), view->contentsY(),
-		    view->visibleWidth(), view->visibleHeight() ).
+		    view->visibleWidthSB(), view->visibleHeightSB() ).
 	     intersects( oR ) )
 	    view->repaintContents( oR.x() - 1, oR.y() - 1,
 				   oR.width() + 2, oR.height() + 2, FALSE );
@@ -1140,7 +1143,7 @@
 
     if ( view ) {
 	if ( QRect( view->contentsX(), view->contentsY(),
-		    view->visibleWidth(), view->visibleHeight() ).
+		    view->visibleWidthSB(), view->visibleHeightSB() ).
 	     intersects( oR ) )
 	    view->repaintContents( oR.x() - 1, oR.y() - 1,
 				   oR.width() + 2, oR.height() + 2, FALSE );
@@ -1200,7 +1203,7 @@
 
 	    if ( view ) {
 		if ( QRect( view->contentsX(), view->contentsY(),
-			    view->visibleWidth(), view->visibleHeight() ).
+			    view->visibleWidthSB(), view->visibleHeightSB() ).
 		     intersects( oR ) )
 		    view->repaintContents( oR.x() - 1, oR.y() - 1,
 					   oR.width() + 2, oR.height() + 2, FALSE );
@@ -2727,10 +2730,12 @@
     d->lastItem = 0;
     d->count = 0;
     d->mousePressed = FALSE;
+    d->controlPressed = FALSE;
     d->selectionMode = Single;
     d->currentItem = 0;
     d->highlightedItem = 0;
     d->rubber = 0;
+    d->canStartRubber = FALSE;
     d->scrollTimer = 0;
     d->startDragItem = 0;
     d->tmpCurrentItem = 0;
@@ -3292,9 +3297,18 @@
 	    alreadyIntersected = TRUE;
 	    QIconViewItem *item = c->items.first();
 	    for ( ; item; item = c->items.next() ) {
-		if ( d->selectedItems.find( item ) )
-		    continue;
-		if ( !item->intersects( nr ) ) {
+               if ( d->selectedItems.find( item ) ) {
+                   if ( item->intersects( nr ) && item->isSelected() && d->controlPressed ) {
+                       item->setSelected( FALSE );
+                       changed = TRUE;
+                       rr = rr.unite( item->rect() );
+                   } else if ( !item->intersects( nr ) && !item->isSelected() && d->controlPressed ) {
+                       item->setSelected( TRUE, TRUE );
+                       changed = TRUE;
+                       rr = rr.unite( item->rect() );
+                   } else
+                       continue;
+               } else if ( !item->intersects( nr ) ) {
 		    if ( item->isSelected() ) {
 			item->setSelected( FALSE );
 			changed = TRUE;
@@ -4485,34 +4499,25 @@
 	    }
 	}
     } else if ( ( d->selectionMode != Single || e->button() == RightButton )
-		&& !( e->state() & ControlButton ) )
+		&& !( e->state() & ControlButton ) && !( e->state() & ShiftButton ) )
 	selectAll( FALSE );
 
     setCurrentItem( item );
 
+    d->canStartRubber = FALSE;
     if ( e->button() == LeftButton ) {
-	if ( !item && ( d->selectionMode == Multi ||
-				  d->selectionMode == Extended ) ) {
-	    d->tmpCurrentItem = d->currentItem;
-	    d->currentItem = 0;
-	    repaintItem( d->tmpCurrentItem );
-	    if ( d->rubber )
-		delete d->rubber;
-	    d->rubber = 0;
-	    d->rubber = new QRect( e->x(), e->y(), 0, 0 );
-	    d->selectedItems.clear();
-	    if ( ( e->state() & ControlButton ) == ControlButton ) {
-		for ( QIconViewItem *i = firstItem(); i; i = i->nextItem() )
-		    if ( i->isSelected() )
-			d->selectedItems.insert( i, i );
-	    }
+	if ( !item && ( d->selectionMode == Multi || d->selectionMode == Extended ) )
+	{
+	    d->canStartRubber = TRUE;
+	    d->rubberStartX = e->x();
+	    d->rubberStartY = e->y();
 	}
-
 	d->mousePressed = TRUE;
+	d->controlPressed = ( ( e->state() & ControlButton ) == ControlButton );
     }
 
  emit_signals:
-    if ( !d->rubber ) {
+    if ( !d->canStartRubber ) {
 	emit mouseButtonPressed( e->button(), item, e->globalPos() );
 	emit pressed( item );
 	emit pressed( item, e->globalPos() );
@@ -4556,6 +4561,7 @@
     d->mousePressed = FALSE;
     d->startDragItem = 0;
 
+    d->canStartRubber = FALSE;
     if ( d->rubber ) {
 	QPainter p;
 	p.begin( viewport() );
@@ -4645,7 +4651,22 @@
 	    if ( d->tmpCurrentItem )
 		repaintItem( d->tmpCurrentItem );
 	}
-    } else if ( d->mousePressed && !d->currentItem && d->rubber ) {
+    } else if ( d->mousePressed && ((!d->currentItem && d->rubber) || d->canStartRubber) ) {
+	if ( d->canStartRubber ) {
+	    d->canStartRubber = FALSE;
+	    d->tmpCurrentItem = d->currentItem;
+	    d->currentItem = 0;
+	    repaintItem( d->tmpCurrentItem );
+	    delete d->rubber;
+	    d->rubber = new QRect( d->rubberStartX, d->rubberStartY, 0, 0 );
+	    d->selectedItems.clear();
+	    if ( ( e->state() & ControlButton ) == ControlButton ||
+	         ( e->state() & ShiftButton ) == ShiftButton ) {
+		for ( QIconViewItem *i = firstItem(); i; i = i->nextItem() )
+		    if ( i->isSelected() )
+			d->selectedItems.insert( i, i );
+	    }
+	}
 	doAutoScroll();
     }
 }
@@ -4775,7 +4796,7 @@
 
     QIconViewItem *i = findItem( e->pos() );
 
-    if ( !i && e->source() == viewport() && d->currentItem && !d->cleared ) {
+    if ( (!i || i == d->currentItem) && e->source() == viewport() && d->currentItem && !d->cleared ) {
 	if ( !d->rearrangeEnabled )
 	    return;
 	QRect r = d->currentItem->rect();
@@ -5222,11 +5243,11 @@
 	d->findContainers( dir, relativeTo, searchRect);
 
     cList->first();
-    while ( cList->current() && !centerMatch ) {
+    while ( cList->current() ) {
 	QPtrList<QIconViewItem> &list = (cList->current())->items;
 	for ( item = list.first(); item; item = list.next() ) {
 	    if ( neighbourItem( dir, relativeTo, item ) &&
-		 searchRect.contains( item->rect().center() ) &&
+		 searchRect.intersects( item->rect() ) &&
 		 item != currentItem() ) {
  		int ml = (relativeTo - item->rect().center()).manhattanLength();
 		if ( centerMatch ) {
@@ -5448,8 +5469,8 @@
 	}
 	item->dirty = FALSE;
     } else {
-	QRegion r( QRect( 0, 0, QMAX( contentsWidth(), visibleWidth() ),
-			  QMAX( contentsHeight(), visibleHeight() ) ) );
+	QRegion r( QRect( 0, 0, QMAX( contentsWidth(), visibleWidthSB() ),
+			  QMAX( contentsHeight(), visibleHeightSB() ) ) );
 
 	QIconViewItem *i = d->firstItem;
 	int y = -1;
@@ -5707,7 +5728,7 @@
 	    QIconViewItem *item = begin;
 	    for (;;) {
 		x += d->spacing + item->width();
-		if ( x > visibleWidth() && item != begin ) {
+		if ( x > visibleWidthSB() && item != begin ) {
 		    item = item->prev;
 		    break;
 		}
@@ -5732,7 +5753,7 @@
 		int x;
 		if ( item == begin ) {
 		    if ( reverse )
-			x = visibleWidth() - d->spacing - item->width();
+			x = visibleWidthSB() - d->spacing - item->width();
 		    else
 			x = d->spacing;
 		} else {
@@ -5768,7 +5789,7 @@
 		    i += r;
 		    x = i * d->rastX + sp * d->spacing;
 		}
-		if ( x > visibleWidth() && item != begin ) {
+		if ( x > visibleWidthSB() && item != begin ) {
 		    item = item->prev;
 		    break;
 		}
@@ -5831,7 +5852,7 @@
 	    QIconViewItem *item = begin;
 	    for (;;) {
 		y += d->spacing + item->height();
-		if ( y > visibleHeight() && item != begin ) {
+		if ( y > visibleHeightSB() && item != begin ) {
 		    item = item->prev;
 		    break;
 		}
@@ -6145,7 +6166,9 @@
 	    item->d->container2 = 0;
 	    c->items.append( item );
 	    item = item->next;
-	} else if ( c->rect.intersects( item->rect() ) ) {
+	} else if ( c->rect.intersects( item->rect() ) && (
+			( d->arrangement == LeftToRight && item->y() >= c->rect.y() ) ||
+			( d->arrangement == TopToBottom && item->x() >= c->rect.x() ) ) ) {
 	    item->d->container1 = c;
 	    c->items.append( item );
 	    c = c->n;
@@ -6378,4 +6401,24 @@
 #endif
 }
 
+int QIconView::visibleWidthSB() const
+{
+    if ( vScrollBarMode() != Auto )
+        return visibleWidth();
+
+    int offset = verticalScrollBar()->isVisible() ? 0
+        : style().pixelMetric( QStyle::PM_ScrollBarExtent, verticalScrollBar() );
+    return QMAX( 0, visibleWidth() - offset );
+}
+
+int QIconView::visibleHeightSB() const
+{
+    if ( hScrollBarMode() != Auto )
+        return visibleHeight();
+
+    int offset = horizontalScrollBar()->isVisible() ? 0
+        : style().pixelMetric( QStyle::PM_ScrollBarExtent, horizontalScrollBar() );
+    return QMAX( 0, visibleHeight() - offset );
+}
+
 #endif // QT_NO_ICONVIEW
diff -Nru qt-x11-free-3.3.3.orig/src/iconview/qiconview.cpp~ qt-x11-free-3.3.3/src/iconview/qiconview.cpp~
--- qt-x11-free-3.3.3.orig/src/iconview/qiconview.cpp~	1970-01-01 01:00:00.000000000 +0100
+++ qt-x11-free-3.3.3/src/iconview/qiconview.cpp~	2004-08-22 13:23:13.888143248 +0200
@@ -0,0 +1,6394 @@
+/****************************************************************************
+** $Id: qt/qiconview.cpp   3.3.3   edited Feb 13 08:04 $
+**
+** Implementation of QIconView widget class
+**
+** Created : 990707
+**
+** Copyright (C) 1992-2000 Trolltech AS.  All rights reserved.
+**
+** This file is part of the iconview module of the Qt GUI Toolkit.
+**
+** This file may be distributed under the terms of the Q Public License
+** as defined by Trolltech AS of Norway and appearing in the file
+** LICENSE.QPL included in the packaging of this file.
+**
+** This file may be distributed and/or modified under the terms of the
+** GNU General Public License version 2 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.
+**
+** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
+** licenses may use this file in accordance with the Qt Commercial License
+** Agreement provided with the Software.
+**
+** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+**
+** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
+**   information about Qt Commercial License Agreements.
+** See http://www.trolltech.com/qpl/ for QPL licensing information.
+** See http://www.trolltech.com/gpl/ for GPL licensing information.
+**
+** Contact info@trolltech.com if any conditions of this licensing are
+** not clear to you.
+**
+**********************************************************************/
+
+#include "qglobal.h"
+#if defined(Q_CC_BOR)
+// needed for qsort() because of a std namespace problem on Borland
+#include "qplatformdefs.h"
+#endif
+
+#include "qiconview.h"
+
+#ifndef QT_NO_ICONVIEW
+
+#include "qfontmetrics.h"
+#include "qpainter.h"
+#include "qevent.h"
+#include "qpalette.h"
+#include "qmime.h"
+#include "qimage.h"
+#include "qpen.h"
+#include "qbrush.h"
+#include "qtimer.h"
+#include "qcursor.h"
+#include "qapplication.h"
+#include "qtextedit.h"
+#include "qmemarray.h"
+#include "qptrlist.h"
+#include "qvbox.h"
+#include "qtooltip.h"
+#include "qbitmap.h"
+#include "qpixmapcache.h"
+#include "qptrdict.h"
+#include "qstringlist.h"
+#include "qcleanuphandler.h"
+#include "private/qrichtext_p.h"
+#include "qstyle.h"
+
+#include <limits.h>
+#include <stdlib.h>
+
+#define RECT_EXTENSION 300
+
+static const char * const unknown_xpm[] = {
+    "32 32 11 1",
+    "c c #ffffff",
+    "g c #c0c0c0",
+    "a c #c0ffc0",
+    "h c #a0a0a4",
+    "d c #585858",
+    "f c #303030",
+    "i c #400000",
+    "b c #00c000",
+    "e c #000000",
+    "# c #000000",
+    ". c None",
+    "...###..........................",
+    "...#aa##........................",
+    ".###baaa##......................",
+    ".#cde#baaa##....................",
+    ".#cccdeebaaa##..##f.............",
+    ".#cccccdeebaaa##aaa##...........",
+    ".#cccccccdeebaaaaaaaa##.........",
+    ".#cccccccccdeebaaaaaaa#.........",
+    ".#cccccgcgghhebbbbaaaaa#........",
+    ".#ccccccgcgggdebbbbbbaa#........",
+    ".#cccgcgcgcgghdeebiebbba#.......",
+    ".#ccccgcggggggghdeddeeba#.......",
+    ".#cgcgcgcggggggggghghdebb#......",
+    ".#ccgcggggggggghghghghd#b#......",
+    ".#cgcgcggggggggghghghhd#b#......",
+    ".#gcggggggggghghghhhhhd#b#......",
+    ".#cgcggggggggghghghhhhd#b#......",
+    ".#ggggggggghghghhhhhhhdib#......",
+    ".#gggggggggghghghhhhhhd#b#......",
+    ".#hhggggghghghhhhhhhhhd#b#......",
+    ".#ddhhgggghghghhhhhhhhd#b#......",
+    "..##ddhhghghhhhhhhhhhhdeb#......",
+    "....##ddhhhghhhhhhhhhhd#b#......",
+    "......##ddhhhhhhhhhhhhd#b#......",
+    "........##ddhhhhhhhhhhd#b#......",
+    "..........##ddhhhhhhhhd#b#......",
+    "............##ddhhhhhhd#b###....",
+    "..............##ddhhhhd#b#####..",
+    "................##ddhhd#b######.",
+    "..................##dddeb#####..",
+    "....................##d#b###....",
+    "......................####......"};
+
+static QPixmap *unknown_icon = 0;
+static QPixmap *qiv_buffer_pixmap = 0;
+#if !defined(Q_WS_X11)
+static QPixmap *qiv_selection = 0;
+#endif
+static bool optimize_layout = FALSE;
+
+static QCleanupHandler<QPixmap> qiv_cleanup_pixmap;
+
+#if !defined(Q_WS_X11)
+static void createSelectionPixmap( const QColorGroup &cg )
+{
+    QBitmap m( 2, 2 );
+    m.fill( Qt::color1 );
+    QPainter p( &m );
+    p.setPen( Qt::color0 );
+    for ( int j = 0; j < 2; ++j ) {
+	p.drawPoint( j % 2, j );
+    }
+    p.end();
+
+    qiv_selection = new QPixmap( 2, 2 );
+    qiv_cleanup_pixmap.add( &qiv_selection );
+    qiv_selection->fill( Qt::color0 );
+    qiv_selection->setMask( m );
+    qiv_selection->fill( cg.highlight() );
+}
+#endif
+
+static QPixmap *get_qiv_buffer_pixmap( const QSize &s )
+{
+    if ( !qiv_buffer_pixmap ) {
+	qiv_buffer_pixmap = new QPixmap( s );
+	qiv_cleanup_pixmap.add( &qiv_buffer_pixmap );
+	return qiv_buffer_pixmap;
+    }
+
+    qiv_buffer_pixmap->resize( s );
+    return qiv_buffer_pixmap;
+}
+
+#ifndef QT_NO_DRAGANDDROP
+
+class QM_EXPORT_ICONVIEW QIconDragData
+{
+public:
+    QIconDragData();
+    QIconDragData( const QRect &ir, const QRect &tr );
+
+    QRect pixmapRect() const;
+    QRect textRect() const;
+
+    void setPixmapRect( const QRect &r );
+    void setTextRect( const QRect &r );
+
+    QRect iconRect_, textRect_;
+    QString key_;
+
+    bool operator==( const QIconDragData &i ) const;
+};
+
+class QM_EXPORT_ICONVIEW QIconDragDataItem
+{
+public:
+    QIconDragDataItem() {}
+    QIconDragDataItem( const QIconDragItem &i1, const QIconDragData &i2 ) : data( i1 ), item( i2 ) {}
+    QIconDragItem data;
+    QIconDragData item;
+    bool operator== ( const QIconDragDataItem& ) const;
+};
+
+class QIconDragPrivate
+{
+public:
+    QValueList<QIconDragDataItem> items;
+    static bool decode( QMimeSource* e, QValueList<QIconDragDataItem> &lst );
+};
+
+#endif
+
+class QIconViewToolTip;
+
+class QIconViewPrivate
+{
+public:
+    QIconViewItem *firstItem, *lastItem;
+    uint count;
+    QIconView::SelectionMode selectionMode;
+    QIconViewItem *currentItem, *tmpCurrentItem, *highlightedItem,
+	*startDragItem, *pressedItem, *selectAnchor, *renamingItem;
+    QRect *rubber;
+    QTimer *scrollTimer, *adjustTimer, *updateTimer, *inputTimer,
+	*fullRedrawTimer;
+    int rastX, rastY, spacing;
+    int dragItems;
+    QPoint oldDragPos;
+    QIconView::Arrangement arrangement;
+    QIconView::ResizeMode resizeMode;
+    QSize oldSize;
+#ifndef QT_NO_DRAGANDDROP
+    QValueList<QIconDragDataItem> iconDragData;
+#endif
+    int numDragItems, cachedW, cachedH;
+    int maxItemWidth, maxItemTextLength;
+    QPoint dragStart;
+    QString currInputString;
+    QIconView::ItemTextPos itemTextPos;
+#ifndef QT_NO_CURSOR
+    QCursor oldCursor;
+#endif
+    int cachedContentsX, cachedContentsY;
+    QBrush itemTextBrush;
+    QRegion clipRegion;
+    QPoint dragStartPos;
+    QFontMetrics *fm;
+    int minLeftBearing, minRightBearing;
+
+    uint mousePressed		:1;
+    uint cleared		:1;
+    uint dropped		:1;
+    uint clearing		:1;
+    uint oldDragAcceptAction	:1;
+    uint isIconDrag		:1;
+    uint drawDragShapes		:1;
+    uint dirty			:1;
+    uint rearrangeEnabled	:1;
+    uint reorderItemsWhenInsert	:1;
+    uint drawAllBack		:1;
+    uint resortItemsWhenInsert	:1;
+    uint sortDirection		:1;
+    uint wordWrapIconText	:1;
+    uint containerUpdateLocked	:1;
+    uint firstSizeHint : 1;
+    uint showTips		:1;
+    uint pressedSelected	:1;
+    uint dragging		:1;
+    uint drawActiveSelection	:1;
+    uint inMenuMode		:1;
+    uint controlPressed         :1;
+
+    QIconViewToolTip *toolTip;
+    QPixmapCache maskCache;
+    QPtrDict<QIconViewItem> selectedItems;
+
+    struct ItemContainer {
+	ItemContainer( ItemContainer *pr, ItemContainer *nx, const QRect &r )
+	    : p( pr ), n( nx ), rect( r ) {
+		items.setAutoDelete( FALSE );
+		if ( p )
+		    p->n = this;
+		if ( n )
+		    n->p = this;
+	}
+	ItemContainer *p, *n;
+	QRect rect;
+	QPtrList<QIconViewItem> items;
+    } *firstContainer, *lastContainer;
+
+    struct SortableItem {
+	QIconViewItem *item;
+    };
+
+public:
+
+    /* finds the containers that intersect with \a searchRect in the direction \a dir relative to \a relativeTo */
+    QPtrList<ItemContainer>* findContainers(
+	QIconView:: Direction dir,
+	const QPoint &relativeTo,
+	const QRect &searchRect ) const;
+    //    friend int cmpIconViewItems( const void *n1, const void *n2 );
+};
+
+
+QPtrList<QIconViewPrivate::ItemContainer>* QIconViewPrivate::findContainers(
+	QIconView:: Direction dir,
+	const QPoint &relativeTo,
+	const QRect &searchRect ) const
+{
+
+    QPtrList<QIconViewPrivate::ItemContainer>* list =
+	new QPtrList<QIconViewPrivate::ItemContainer>();
+
+    if ( arrangement == QIconView::LeftToRight ) {
+	if ( dir == QIconView::DirLeft || dir == QIconView::DirRight ) {
+	    ItemContainer *c = firstContainer;
+	    for ( ; c; c = c->n )
+		if ( c->rect.intersects( searchRect ) )
+		    list->append( c );
+	} else {
+	    if ( dir == QIconView::DirDown ) {
+		ItemContainer *c = firstContainer;
+		for ( ; c; c = c->n )
+		    if ( c->rect.intersects( searchRect ) &&
+			 c->rect.bottom() >= relativeTo.y() )
+			list->append( c );
+	    } else {
+		ItemContainer *c = lastContainer;
+		for ( ; c; c = c->p )
+		    if ( c->rect.intersects( searchRect ) &&
+			 c->rect.top() <= relativeTo.y() )
+			list->append( c );
+	    }
+	}
+    } else {
+	if ( dir == QIconView::DirUp || dir == QIconView::DirDown ) {
+	    ItemContainer *c = firstContainer;
+	    for ( ; c; c = c->n )
+		if ( c->rect.intersects( searchRect ) )
+		    list->append( c );
+	} else {
+	    if ( dir == QIconView::DirRight ) {
+		ItemContainer *c = firstContainer;
+		for ( ; c; c = c->n )
+		    if ( c->rect.intersects( searchRect ) &&
+			 c->rect.right() >= relativeTo.x() )
+			list->append( c );
+	    } else {
+		ItemContainer *c = lastContainer;
+		for ( ; c; c = c->p )
+		    if ( c->rect.intersects( searchRect ) &&
+			 c->rect.left() <= relativeTo.x() )
+			list->append( c );
+	    }
+	}
+    }
+    return list;
+}
+
+
+#if defined(Q_C_CALLBACKS)
+extern "C" {
+#endif
+
+#ifdef Q_OS_TEMP
+static int _cdecl cmpIconViewItems( const void *n1, const void *n2 )
+#else
+static int cmpIconViewItems( const void *n1, const void *n2 )
+#endif
+{
+    if ( !n1 || !n2 )
+	return 0;
+
+    QIconViewPrivate::SortableItem *i1 = (QIconViewPrivate::SortableItem *)n1;
+    QIconViewPrivate::SortableItem *i2 = (QIconViewPrivate::SortableItem *)n2;
+
+    return i1->item->compare( i2->item );
+}
+
+#if defined(Q_C_CALLBACKS)
+}
+#endif
+
+
+#ifndef QT_NO_TOOLTIP
+class QIconViewToolTip : public QToolTip
+{
+public:
+    QIconViewToolTip( QWidget *parent, QIconView *iv );
+
+    void maybeTip( const QPoint &pos );
+
+private:
+    QIconView *view;
+};
+
+QIconViewToolTip::QIconViewToolTip( QWidget *parent, QIconView *iv )
+    : QToolTip( parent ), view( iv )
+{
+}
+
+void QIconViewToolTip::maybeTip( const QPoint &pos )
+{
+    if ( !parentWidget() || !view || view->wordWrapIconText() || !view->showToolTips() )
+	return;
+
+    QIconViewItem *item = view->findItem( view->viewportToContents( pos ) );
+    if ( !item || item->tmpText == item->itemText )
+	return;
+
+    QRect r( item->textRect( FALSE ) );
+    QRect r2 = item->pixmapRect( FALSE );
+    /* this probably should be | r, but QToolTip does not handle that
+     * well */
+
+    // At this point the rectangle is too small (it is the width of the icon)
+    // since we need it to be bigger than that, extend it here.
+    r.setWidth( view->d->fm->boundingRect( item->itemText ).width() + 4 );
+    r = QRect( view->contentsToViewport( QPoint( r.x(), r.y() ) ), QSize( r.width(), r.height() ) );
+
+    r2 = QRect( view->contentsToViewport( QPoint( r2.x(), r2.y() ) ), QSize( r2.width(), r2.height() ) );
+    tip( r2, item->itemText, r );
+}
+#endif
+
+
+class QIconViewItemPrivate
+{
+public:
+    QIconViewPrivate::ItemContainer *container1, *container2;
+};
+
+#ifndef QT_NO_TEXTEDIT
+
+class QIconViewItemLineEdit : public QTextEdit
+{
+    friend class QIconViewItem;
+
+public:
+    QIconViewItemLineEdit( const QString &text, QWidget *parent, QIconViewItem *theItem, const char* name=0 );
+
+protected:
+    void keyPressEvent( QKeyEvent *e );
+    void focusOutEvent( QFocusEvent *e );
+
+protected:
+    QIconViewItem *item;
+    QString startText;
+private:
+#if defined(Q_DISABLE_COPY) // Disabled copy constructor and operator=
+    QIconViewItemLineEdit( const QIconViewItemLineEdit & );
+    QIconViewItemLineEdit &operator=( const QIconViewItemLineEdit & );
+#endif
+
+};
+
+QIconViewItemLineEdit::QIconViewItemLineEdit( const QString &text, QWidget *parent,
+					      QIconViewItem *theItem, const char *name )
+    : QTextEdit( parent, name ), item( theItem ), startText( text )
+{
+    setFrameStyle( QFrame::Plain | QFrame::Box );
+    setLineWidth( 1 );
+
+    setHScrollBarMode( AlwaysOff );
+    setVScrollBarMode( AlwaysOff );
+
+    setWordWrap( WidgetWidth );
+    setWrapColumnOrWidth( item->iconView()->maxItemWidth() -
+			  ( item->iconView()->itemTextPos() == QIconView::Bottom ?
+			    0 : item->pixmapRect().width() ) );
+    document()->formatter()->setAllowBreakInWords( TRUE );
+    resize( 200, 200 ); // ### some size, there should be a forceReformat()
+    setTextFormat( PlainText );
+    setText( text );
+    setAlignment( Qt::AlignCenter );
+
+    resize( wrapColumnOrWidth() + 2, heightForWidth( wrapColumnOrWidth() ) + 2 );
+}
+
+void QIconViewItemLineEdit::keyPressEvent( QKeyEvent *e )
+{
+    if ( e->key()  == Key_Escape ) {
+	item->QIconViewItem::setText( startText );
+	item->cancelRenameItem();
+    } else if ( e->key() == Key_Enter ||
+		e->key() == Key_Return ) {
+	item->renameItem();
+    } else {
+	QTextEdit::keyPressEvent( e );
+	sync();
+	resize( width(), document()->height() + 2 );
+
+    }
+}
+
+void QIconViewItemLineEdit::focusOutEvent( QFocusEvent *e )
+{
+    Q_UNUSED(e) // I need this to get rid of a Borland warning
+    if ( e->reason() != QFocusEvent::Popup )
+	item->cancelRenameItem();
+}
+#endif
+
+#ifndef QT_NO_DRAGANDDROP
+
+
+/*!
+    \class QIconDragItem qiconview.h
+    \ingroup draganddrop
+
+    \brief The QIconDragItem class encapsulates a drag item.
+
+    \module iconview
+
+    The QIconDrag class uses a list of QIconDragItems to support drag
+    and drop operations.
+
+    In practice a QIconDragItem object (or an object of a class derived
+    from QIconDragItem) is created for each icon view item which is
+    dragged. Each of these QIconDragItems is stored in a QIconDrag
+    object.
+
+    See QIconView::dragObject() for more information.
+
+    See the \l fileiconview/qfileiconview.cpp and
+    \l iconview/simple_dd/main.cpp examples.
+*/
+
+/*!
+    Constructs a QIconDragItem with no data.
+*/
+
+QIconDragItem::QIconDragItem()
+    : ba( (int)strlen( "no data" ) )
+{
+    memcpy( ba.data(), "no data", strlen( "no data" ) );
+}
+
+/*!
+    Destructor.
+*/
+
+QIconDragItem::~QIconDragItem()
+{
+}
+
+/*!
+    Returns the data contained in the QIconDragItem.
+*/
+
+QByteArray QIconDragItem::data() const
+{
+    return ba;
+}
+
+/*!
+    Sets the data for the QIconDragItem to the data stored in the
+    QByteArray \a d.
+*/
+
+void QIconDragItem::setData( const QByteArray &d )
+{
+    ba = d;
+}
+
+/*!
+    \reimp
+*/
+
+bool QIconDragItem::operator==( const QIconDragItem &i ) const
+{
+    return ba == i.ba;
+}
+
+/*!
+    \reimp
+*/
+
+bool QIconDragDataItem::operator==( const QIconDragDataItem &i ) const
+{
+    return ( i.item == item &&
+	     i.data == data );
+}
+
+/*!
+    \reimp
+*/
+
+bool QIconDragData::operator==( const QIconDragData &i ) const
+{
+    return key_ == i.key_;
+}
+
+
+/*!
+    \class QIconDrag qiconview.h
+
+    \brief The QIconDrag class supports drag and drop operations
+    within a QIconView.
+
+    \ingroup draganddrop
+    \module iconview
+
+    A QIconDrag object is used to maintain information about the
+    positions of dragged items and the data associated with the
+    dragged items. QIconViews are able to use this information to
+    paint the dragged items in the correct positions. Internally
+    QIconDrag stores the data associated with drag items in
+    QIconDragItem objects.
+
+    If you want to use the extended drag-and-drop functionality of
+    QIconView, create a QIconDrag object in a reimplementation of
+    QIconView::dragObject(). Then create a QIconDragItem for each item
+    which should be dragged, set the data it represents with
+    QIconDragItem::setData(), and add each QIconDragItem to the drag
+    object using append().
+
+    The data in QIconDragItems is stored in a QByteArray and is
+    mime-typed (see QMimeSource and the
+    \link http://doc.trolltech.com/dnd.html Drag and Drop\endlink
+    overview). If you want to use your own mime-types derive a class
+    from QIconDrag and reimplement format(), encodedData() and
+    canDecode().
+
+    The fileiconview example program demonstrates the use of the
+    QIconDrag class including subclassing and reimplementing
+    dragObject(), format(), encodedData() and canDecode(). See the files
+    \c qt/examples/fileiconview/qfileiconview.h and
+    \c qt/examples/fileiconview/qfileiconview.cpp.
+
+    \sa QMimeSource::format()
+*/
+// ### consider using \dontinclude and friends there
+// ### Not here in the module overview instead...
+
+/*!
+    Constructs a drag object called \a name, which is a child of \a
+    dragSource.
+
+    Note that the drag object will be deleted when \a dragSource is deleted.
+*/
+
+QIconDrag::QIconDrag( QWidget * dragSource, const char* name )
+    : QDragObject( dragSource, name )
+{
+    d = new QIconDragPrivate;
+}
+
+/*!
+    Destructor.
+*/
+
+QIconDrag::~QIconDrag()
+{
+    delete d;
+}
+
+/*!
+    Append the QIconDragItem, \a i, to the QIconDrag object's list of
+    items. You must also supply the geometry of the pixmap, \a pr, and
+    the textual caption, \a tr.
+
+    \sa QIconDragItem
+*/
+
+void QIconDrag::append( const QIconDragItem &i, const QRect &pr, const QRect &tr )
+{
+    d->items.append( QIconDragDataItem( i, QIconDragData( pr, tr ) ) );
+}
+
+/*!
+    \reimp
+*/
+
+const char* QIconDrag::format( int i ) const
+{
+    if ( i == 0 )
+	return "application/x-qiconlist";
+    return 0;
+}
+
+/*!
+    Returns the encoded data of the drag object if \a mime is
+    application/x-qiconlist.
+*/
+
+QByteArray QIconDrag::encodedData( const char* mime ) const
+{
+    if ( d->items.count() <= 0 || QString( mime ) !=
+	 "application/x-qiconlist" )
+	return QByteArray();
+
+    QValueList<QIconDragDataItem>::ConstIterator it = d->items.begin();
+    QString s;
+    for ( ; it != d->items.end(); ++it ) {
+	QString k( "%1$@@$%2$@@$%3$@@$%4$@@$%5$@@$%6$@@$%7$@@$%8$@@$" );
+	k = k.arg( (*it).item.pixmapRect().x() ).arg(
+	    (*it).item.pixmapRect().y() ).arg( (*it).item.pixmapRect().width() ).
+	    arg( (*it).item.pixmapRect().height() ).arg(
+		(*it).item.textRect().x() ).arg( (*it).item.textRect().y() ).
+	    arg( (*it).item.textRect().width() ).arg(
+		(*it).item.textRect().height() );
+	k += QString( (*it).data.data() ) + "$@@$";
+	s += k;
+    }
+
+    QByteArray a( s.length() + 1 );
+    memcpy( a.data(), s.latin1(), a.size() );
+    return a;
+}
+
+/*!
+    Returns TRUE if \a e can be decoded by the QIconDrag, otherwise
+    return FALSE.
+*/
+
+bool QIconDrag::canDecode( QMimeSource* e )
+{
+    if ( e->provides( "application/x-qiconlist" ) )
+	return TRUE;
+    return FALSE;
+}
+
+/*!
+    Decodes the data which is stored (encoded) in \a e and, if
+    successful, fills the \a list of icon drag items with the decoded
+    data. Returns TRUE if there was some data, FALSE otherwise.
+*/
+
+bool QIconDragPrivate::decode( QMimeSource* e, QValueList<QIconDragDataItem> &lst )
+{
+    QByteArray ba = e->encodedData( "application/x-qiconlist" );
+    if ( ba.size() ) {
+	lst.clear();
+	QString s = ba.data();
+	QIconDragDataItem item;
+	QRect ir, tr;
+	QStringList l = QStringList::split( "$@@$", s );
+
+	int i = 0;
+	QStringList::Iterator it = l.begin();
+	for ( ; it != l.end(); ++it ) {
+	    if ( i == 0 ) {
+		ir.setX( ( *it ).toInt() );
+	    } else if ( i == 1 ) {
+		ir.setY( ( *it ).toInt() );
+	    } else if ( i == 2 ) {
+		ir.setWidth( ( *it ).toInt() );
+	    } else if ( i == 3 ) {
+		ir.setHeight( ( *it ).toInt() );
+	    } else if ( i == 4 ) {
+		tr.setX( ( *it ).toInt() );
+	    } else if ( i == 5 ) {
+		tr.setY( ( *it ).toInt() );
+	    } else if ( i == 6 ) {
+		tr.setWidth( ( *it ).toInt() );
+	    } else if ( i == 7 ) {
+		tr.setHeight( ( *it ).toInt() );
+	    } else if ( i == 8 ) {
+		QByteArray d( ( *it ).length() );
+		memcpy( d.data(), ( *it ).latin1(), ( *it ).length() );
+		item.item.setPixmapRect( ir );
+		item.item.setTextRect( tr );
+		item.data.setData( d );
+		lst.append( item );
+	    }
+	    ++i;
+	    if ( i > 8 )
+		i = 0;
+	}
+	return TRUE;
+    }
+
+    return FALSE;
+}
+
+QIconDragData::QIconDragData()
+    : iconRect_(), textRect_()
+{
+}
+
+QIconDragData::QIconDragData( const QRect &ir, const QRect &tr )
+    : iconRect_( ir ), textRect_( tr )
+{
+}
+
+QRect QIconDragData::textRect() const
+{
+    return textRect_;
+}
+
+QRect QIconDragData::pixmapRect() const
+{
+    return iconRect_;
+}
+
+void QIconDragData::setPixmapRect( const QRect &r )
+{
+    iconRect_ = r;
+}
+
+void QIconDragData::setTextRect( const QRect &r )
+{
+    textRect_ = r;
+}
+
+#endif
+
+
+/*!
+    \class QIconViewItem qiconview.h
+    \brief The QIconViewItem class provides a single item in a QIconView.
+
+    \ingroup advanced
+    \module iconview
+
+    A QIconViewItem contains an icon, a string and optionally a sort
+    key, and can display itself in a QIconView.
+
+    The simplest way to create a QIconViewItem and insert it into a
+    QIconView is to construct the item passing the constructor a
+    pointer to the icon view, a string and an icon:
+
+    \code
+    (void) new QIconViewItem(
+		    iconView,	// A pointer to a QIconView
+		    "This is the text of the item",
+		    aPixmap );
+    \endcode
+
+    By default the text of an icon view item may not be edited by the
+    user but calling setRenameEnabled(TRUE) will allow the user to
+    perform in-place editing of the item's text.
+
+    When the icon view is deleted all items in it are deleted
+    automatically.
+
+    The QIconView::firstItem() and QIconViewItem::nextItem() functions
+    provide a means of iterating over all the items in a QIconView:
+
+    \code
+    QIconViewItem *item;
+    for ( item = iconView->firstItem(); item; item = item->nextItem() )
+	do_something_with( item );
+    \endcode
+
+    The item's icon view is available from iconView(), and its
+    position in the icon view from index().
+
+    The item's selection status is available from isSelected() and is
+    set and controlled by setSelected() and isSelectable().
+
+    The text and icon can be set with setText() and setPixmap() and
+    retrieved with text() and pixmap(). The item's sort key defaults
+    to text() but may be set with setKey() and retrieved with key().
+    The comparison function, compare() uses key().
+
+    Items may be repositioned with move() and moveBy(). An item's
+    geometry is available from rect(), x(), y(), width(), height(),
+    size(), pos(), textRect() and pixmapRect(). You can also test
+    against the position of a point with contains() and intersects().
+
+    To remove an item from an icon view, just delete the item. The
+    QIconViewItem destructor removes it cleanly from its icon view.
+
+    Because the icon view is designed to use drag-and-drop, the icon
+    view item also has functions for drag-and-drop which may be
+    reimplemented.
+
+    The class is designed to be very similar to QListView and QListBox
+    in use, both via instantiation and subclassing.
+*/
+
+/*!
+    Constructs a QIconViewItem and inserts it into icon view \a parent
+    with no text and a default icon.
+*/
+
+QIconViewItem::QIconViewItem( QIconView *parent )
+    : view( parent ), itemText(), itemIcon( unknown_icon )
+{
+    init();
+}
+
+/*!
+    Constructs a QIconViewItem and inserts it into the icon view \a
+    parent with no text and a default icon, after the icon view item
+    \a after.
+*/
+
+QIconViewItem::QIconViewItem( QIconView *parent, QIconViewItem *after )
+    : view( parent ), itemText(), itemIcon( unknown_icon ),
+      prev( 0 ), next( 0 )
+{
+    init( after );
+}
+
+/*!
+    Constructs an icon view item  and inserts it into the icon view \a
+    parent using \a text as the text and a default icon.
+*/
+
+QIconViewItem::QIconViewItem( QIconView *parent, const QString &text )
+    : view( parent ), itemText( text ), itemIcon( unknown_icon )
+{
+    init( 0 );
+}
+
+/*!
+    Constructs an icon view item and inserts it into the icon view \a
+    parent using \a text as the text and a default icon, after the
+    icon view item \a after.
+*/
+
+QIconViewItem::QIconViewItem( QIconView *parent, QIconViewItem *after,
+			      const QString &text )
+    : view( parent ), itemText( text ), itemIcon( unknown_icon )
+{
+    init( after );
+}
+
+/*!
+    Constructs an icon view item and inserts it into the icon view \a
+    parent using \a text as the text and \a icon as the icon.
+*/
+
+QIconViewItem::QIconViewItem( QIconView *parent, const QString &text,
+			      const QPixmap &icon )
+    : view( parent ),
+      itemText( text ), itemIcon( new QPixmap( icon ) )
+{
+    init( 0 );
+}
+
+
+/*!
+    Constructs an icon view item and inserts it into the icon view \a
+    parent using \a text as the text and \a icon as the icon, after
+    the icon view item \a after.
+*/
+
+QIconViewItem::QIconViewItem( QIconView *parent, QIconViewItem *after,
+			      const QString &text, const QPixmap &icon )
+    : view( parent ), itemText( text ), itemIcon( new QPixmap( icon ) )
+{
+    init( after );
+}
+
+/*!
+    Constructs an icon view item and inserts it into the icon view \a
+    parent using \a text as the text and \a picture as the icon.
+*/
+
+#ifndef QT_NO_PICTURE
+QIconViewItem::QIconViewItem( QIconView *parent, const QString &text,
+			      const QPicture &picture )
+    : view( parent ), itemText( text ), itemIcon( 0 )
+{
+    init( 0, new QPicture( picture ) );
+}
+
+/*!
+    Constructs an icon view item and inserts it into the icon view \a
+    parent using \a text as the text and \a picture as the icon, after
+    the icon view item \a after.
+*/
+
+QIconViewItem::QIconViewItem( QIconView *parent, QIconViewItem *after,
+			      const QString &text, const QPicture &picture )
+    : view( parent ), itemText( text ), itemIcon( 0 )
+{
+    init( after, new QPicture( picture ) );
+}
+#endif
+
+/*!
+  This private function initializes the icon view item and inserts it
+  into the icon view.
+*/
+
+void QIconViewItem::init( QIconViewItem *after
+#ifndef QT_NO_PICTURE
+			  , QPicture *pic
+#endif
+			  )
+{
+    d = new QIconViewItemPrivate;
+    d->container1 = 0;
+    d->container2 = 0;
+    prev = next = 0;
+    allow_rename = FALSE;
+    allow_drag = TRUE;
+    allow_drop = TRUE;
+    selected = FALSE;
+    selectable = TRUE;
+#ifndef QT_NO_TEXTEDIT
+    renameBox = 0;
+#endif
+#ifndef QT_NO_PICTURE
+    itemPic = pic;
+#endif
+    if ( view ) {
+	itemKey = itemText;
+	dirty = TRUE;
+	wordWrapDirty = TRUE;
+	itemRect = QRect( -1, -1, 0, 0 );
+	calcRect();
+	view->insertItem( this, after );
+    }
+}
+
+/*!
+    Destroys the icon view item and tells the parent icon view that
+    the item has been destroyed.
+*/
+
+QIconViewItem::~QIconViewItem()
+{
+#ifndef QT_NO_TEXTEDIT
+    removeRenameBox();
+#endif
+    if ( view && !view->d->clearing )
+	view->takeItem( this );
+    view = 0;
+    if ( itemIcon && itemIcon->serialNumber() != unknown_icon->serialNumber() )
+	delete itemIcon;
+#ifndef QT_NO_PICTURE
+    delete itemPic;
+#endif
+    delete d;
+}
+
+int QIconViewItem::RTTI = 0;
+
+/*!
+    Returns 0.
+
+    Make your derived classes return their own values for rtti(), so
+    that you can distinguish between icon view item types. You should
+    use values greater than 1000, preferably a large random number, to
+    allow for extensions to this class.
+*/
+
+int QIconViewItem::rtti() const
+{
+    return RTTI;
+}
+
+
+/*!
+    Sets \a text as the text of the icon view item. This function
+    might be a no-op if you reimplement text().
+
+    \sa text()
+*/
+
+void QIconViewItem::setText( const QString &text )
+{
+    if ( text == itemText )
+	return;
+
+    wordWrapDirty = TRUE;
+    itemText = text;
+    if ( itemKey.isEmpty() )
+	itemKey = itemText;
+
+    QRect oR = rect();
+    calcRect();
+    oR = oR.unite( rect() );
+
+    if ( view ) {
+	if ( QRect( view->contentsX(), view->contentsY(),
+		    view->visibleWidth(), view->visibleHeight() ).
+	     intersects( oR ) )
+	    view->repaintContents( oR.x() - 1, oR.y() - 1,
+				   oR.width() + 2, oR.height() + 2, FALSE );
+    }
+}
+
+/*!
+    Sets \a k as the sort key of the icon view item. By default
+    text() is used for sorting.
+
+    \sa compare()
+*/
+
+void QIconViewItem::setKey( const QString &k )
+{
+    if ( k == itemKey )
+	return;
+
+    itemKey = k;
+}
+
+/*!
+    Sets \a icon as the item's icon in the icon view. This function
+    might be a no-op if you reimplement pixmap().
+
+    \sa pixmap()
+*/
+
+void QIconViewItem::setPixmap( const QPixmap &icon )
+{
+    if ( itemIcon && itemIcon == unknown_icon )
+	itemIcon = 0;
+
+    if ( itemIcon )
+	*itemIcon = icon;
+    else
+	itemIcon = new QPixmap( icon );
+    QRect oR = rect();
+    calcRect();
+    oR = oR.unite( rect() );
+
+    if ( view ) {
+	if ( QRect( view->contentsX(), view->contentsY(),
+		    view->visibleWidth(), view->visibleHeight() ).
+	     intersects( oR ) )
+	    view->repaintContents( oR.x() - 1, oR.y() - 1,
+				   oR.width() + 2, oR.height() + 2, FALSE );
+    }
+}
+
+/*!
+    Sets \a icon as the item's icon in the icon view. This function
+    might be a no-op if you reimplement picture().
+
+    \sa picture()
+*/
+
+#ifndef QT_NO_PICTURE
+void QIconViewItem::setPicture( const QPicture &icon )
+{
+    // clear assigned pixmap if any
+    if ( itemIcon ) {
+	if ( itemIcon == unknown_icon ) {
+	    itemIcon = 0;
+	} else {
+	    delete itemIcon;
+	    itemIcon = 0;
+	}
+    }
+    if ( itemPic )
+	delete itemPic;
+    itemPic = new QPicture( icon );
+
+    QRect oR = rect();
+    calcRect();
+    oR = oR.unite( rect() );
+
+    if ( view ) {
+	if ( QRect( view->contentsX(), view->contentsY(),
+		    view->visibleWidth(), view->visibleHeight() ).
+	     intersects( oR ) )
+	    view->repaintContents( oR.x() - 1, oR.y() - 1,
+				   oR.width() + 2, oR.height() + 2, FALSE );
+    }
+}
+#endif
+
+/*!
+    \overload
+
+    Sets \a text as the text of the icon view item. If \a recalc is
+    TRUE, the icon view's layout is recalculated. If \a redraw is TRUE
+    (the default), the icon view is repainted.
+
+    \sa text()
+*/
+
+void QIconViewItem::setText( const QString &text, bool recalc, bool redraw )
+{
+    if ( text == itemText )
+	return;
+
+    wordWrapDirty = TRUE;
+    itemText = text;
+
+    if ( recalc )
+	calcRect();
+    if ( redraw )
+	repaint();
+}
+
+/*!
+    \overload
+
+    Sets \a icon as the item's icon in the icon view. If \a recalc is
+    TRUE, the icon view's layout is recalculated. If \a redraw is TRUE
+    (the default), the icon view is repainted.
+
+    \sa pixmap()
+*/
+
+void QIconViewItem::setPixmap( const QPixmap &icon, bool recalc, bool redraw )
+{
+    if ( itemIcon && itemIcon == unknown_icon )
+	itemIcon = 0;
+
+    if ( itemIcon )
+	*itemIcon = icon;
+    else
+	itemIcon = new QPixmap( icon );
+
+    if ( redraw ) {
+	if ( recalc ) {
+	    QRect oR = rect();
+	    calcRect();
+	    oR = oR.unite( rect() );
+
+	    if ( view ) {
+		if ( QRect( view->contentsX(), view->contentsY(),
+			    view->visibleWidth(), view->visibleHeight() ).
+		     intersects( oR ) )
+		    view->repaintContents( oR.x() - 1, oR.y() - 1,
+					   oR.width() + 2, oR.height() + 2, FALSE );
+	    }
+	} else {
+	    repaint();
+	}
+    } else if ( recalc ) {
+	calcRect();
+    }
+}
+
+/*!
+    If \a allow is TRUE, the user can rename the icon view item by
+    clicking on the text (or pressing F2) while the item is selected
+    (in-place renaming). If \a allow is FALSE, in-place renaming is
+    not possible.
+*/
+
+void QIconViewItem::setRenameEnabled( bool allow )
+{
+    allow_rename = (uint)allow;
+}
+
+/*!
+    If \a allow is TRUE, the icon view permits the user to drag the
+    icon view item either to another position within the icon view or
+    to somewhere outside of it. If \a allow is FALSE, the item cannot
+    be dragged.
+*/
+
+void QIconViewItem::setDragEnabled( bool allow )
+{
+    allow_drag = (uint)allow;
+}
+
+/*!
+    If \a allow is TRUE, the icon view lets the user drop something on
+    this icon view item.
+*/
+
+void QIconViewItem::setDropEnabled( bool allow )
+{
+    allow_drop = (uint)allow;
+}
+
+/*!
+    Returns the text of the icon view item. Normally you set the text
+    of the item with setText(), but sometimes it's inconvenient to
+    call setText() for every item; so you can subclass QIconViewItem,
+    reimplement this function, and return the text of the item. If you
+    do this, you must call calcRect() manually each time the text
+    (and therefore its size) changes.
+
+    \sa setText()
+*/
+
+QString QIconViewItem::text() const
+{
+    return itemText;
+}
+
+/*!
+    Returns the key of the icon view item or text() if no key has been
+    explicitly set.
+
+    \sa setKey(), compare()
+*/
+
+QString QIconViewItem::key() const
+{
+    return itemKey;
+}
+
+/*!
+    Returns the icon of the icon view item if it is a pixmap, or 0 if
+    it is a picture. In the latter case use picture() instead.
+    Normally you set the pixmap of the item with setPixmap(), but
+    sometimes it's inconvenient to call setPixmap() for every item. So
+    you can subclass QIconViewItem, reimplement this function and
+    return a pointer to the item's pixmap. If you do this, you \e must
+    call calcRect() manually each time the size of this pixmap
+    changes.
+
+    \sa setPixmap()
+*/
+
+QPixmap *QIconViewItem::pixmap() const
+{
+    return itemIcon;
+}
+
+/*!
+    Returns the icon of the icon view item if it is a picture, or 0 if
+    it is a pixmap. In the latter case use pixmap() instead. Normally
+    you set the picture of the item with setPicture(), but sometimes
+    it's inconvenient to call setPicture() for every item. So you can
+    subclass QIconViewItem, reimplement this function and return a
+    pointer to the item's picture. If you do this, you \e must call
+    calcRect() manually each time the size of this picture changes.
+
+    \sa setPicture()
+*/
+
+#ifndef QT_NO_PICTURE
+QPicture *QIconViewItem::picture() const
+{
+    return itemPic;
+}
+#endif
+
+/*!
+    Returns TRUE if the item can be renamed by the user with in-place
+    renaming; otherwise returns FALSE.
+
+    \sa setRenameEnabled()
+*/
+
+bool QIconViewItem::renameEnabled() const
+{
+    return (bool)allow_rename;
+}
+
+/*!
+    Returns TRUE if the user is allowed to drag the icon view item;
+    otherwise returns FALSE.
+
+    \sa setDragEnabled()
+*/
+
+bool QIconViewItem::dragEnabled() const
+{
+    return (bool)allow_drag;
+}
+
+/*!
+    Returns TRUE if the user is allowed to drop something onto the
+    item; otherwise returns FALSE.
+
+    \sa setDropEnabled()
+*/
+
+bool QIconViewItem::dropEnabled() const
+{
+    return (bool)allow_drop;
+}
+
+/*!
+    Returns a pointer to this item's icon view parent.
+*/
+
+QIconView *QIconViewItem::iconView() const
+{
+    return view;
+}
+
+/*!
+    Returns a pointer to the previous item, or 0 if this is the first
+    item in the icon view.
+
+    \sa nextItem() QIconView::firstItem()
+*/
+
+QIconViewItem *QIconViewItem::prevItem() const
+{
+    return prev;
+}
+
+/*!
+    Returns a pointer to the next item, or 0 if this is the last item
+    in the icon view.
+
+    To find the first item use QIconView::firstItem().
+
+    Example:
+    \code
+    QIconViewItem *item;
+    for ( item = iconView->firstItem(); item; item = item->nextItem() )
+	do_something_with( item );
+    \endcode
+
+    \sa prevItem()
+*/
+
+QIconViewItem *QIconViewItem::nextItem() const
+{
+    return next;
+}
+
+/*!
+    Returns the index of this item in the icon view, or -1 if an error
+    occurred.
+*/
+
+int QIconViewItem::index() const
+{
+    if ( view )
+	return view->index( this );
+
+    return -1;
+}
+
+
+
+/*!
+    \overload
+
+    This variant is equivalent to calling the other variant with \e cb
+    set to FALSE.
+*/
+
+void QIconViewItem::setSelected( bool s )
+{
+    setSelected( s, FALSE );
+}
+
+/*!
+    Selects or unselects the item, depending on \a s; it may also
+    unselect other items, depending on QIconView::selectionMode() and
+    \a cb.
+
+    If \a s is FALSE, the item is unselected.
+
+    If \a s is TRUE and QIconView::selectionMode() is \c Single, the
+    item is selected and the item previously selected is unselected.
+
+    If \a s is TRUE and QIconView::selectionMode() is \c Extended, the
+    item is selected. If \a cb is TRUE, the selection state of the
+    other items is left unchanged. If \a cb is FALSE (the default) all
+    other items are unselected.
+
+    If \a s is TRUE and QIconView::selectionMode() is \c Multi, the
+    item is selected.
+
+    Note that \a cb is used only if QIconView::selectionMode() is \c
+    Extended; cb defaults to FALSE.
+
+    All items whose selection status changes repaint themselves.
+*/
+
+void QIconViewItem::setSelected( bool s, bool cb )
+{
+    if ( !view )
+	return;
+    if ( view->selectionMode() != QIconView::NoSelection &&
+	 selectable && s != (bool)selected ) {
+
+	if ( view->d->selectionMode == QIconView::Single && this != view->d->currentItem ) {
+	    QIconViewItem *o = view->d->currentItem;
+	    if ( o && o->selected )
+		o->selected = FALSE;
+	    view->d->currentItem = this;
+	    if ( o )
+		o->repaint();
+	    emit view->currentChanged( this );
+	}
+
+	if ( !s ) {
+	    selected = FALSE;
+	} else {
+	    if ( view->d->selectionMode == QIconView::Single && view->d->currentItem ) {
+		view->d->currentItem->selected = FALSE;
+	    }
+	    if ( ( view->d->selectionMode == QIconView::Extended && !cb ) ||
+		 view->d->selectionMode == QIconView::Single ) {
+		bool b = view->signalsBlocked();
+		view->blockSignals( TRUE );
+		view->selectAll( FALSE );
+		view->blockSignals( b );
+	    }
+	    selected = s;
+	}
+
+ 	repaint();
+	if ( !view->signalsBlocked() ) {
+	    bool emitIt = view->d->selectionMode == QIconView::Single && s;
+	    QIconView *v = view;
+	    emit v->selectionChanged();
+	    if ( emitIt )
+		emit v->selectionChanged( this );
+	}
+    }
+}
+
+/*!
+    Sets this item to be selectable if \a enable is TRUE (the default)
+    or unselectable if \a enable is FALSE.
+
+    The user is unable to select a non-selectable item using either
+    the keyboard or the mouse. (The application programmer can select
+    an item in code regardless of this setting.)
+
+    \sa isSelectable()
+*/
+
+void QIconViewItem::setSelectable( bool enable )
+{
+    selectable = (uint)enable;
+}
+
+/*!
+    Returns TRUE if the item is selected; otherwise returns FALSE.
+
+    \sa setSelected()
+*/
+
+bool QIconViewItem::isSelected() const
+{
+    return (bool)selected;
+}
+
+/*!
+    Returns TRUE if the item is selectable; otherwise returns FALSE.
+
+    \sa setSelectable()
+*/
+
+bool QIconViewItem::isSelectable() const
+{
+    return (bool)selectable;
+}
+
+/*!
+    Repaints the item.
+*/
+
+void QIconViewItem::repaint()
+{
+    if ( view )
+	view->repaintItem( this );
+}
+
+/*!
+    Moves the item to position (\a x, \a y) in the icon view (these
+    are contents coordinates).
+*/
+
+bool QIconViewItem::move( int x, int y )
+{
+    if ( x == this->x() && y == this->y() )
+	return FALSE;
+    itemRect.setRect( x, y, itemRect.width(), itemRect.height() );
+    checkRect();
+    if ( view )
+	view->updateItemContainer( this );
+    return TRUE;
+}
+
+/*!
+    Moves the item \a dx pixels in the x-direction and \a dy pixels in
+    the y-direction.
+*/
+
+void QIconViewItem::moveBy( int dx, int dy )
+{
+    itemRect.moveBy( dx, dy );
+    checkRect();
+    if ( view )
+	view->updateItemContainer( this );
+}
+
+/*!
+    \overload
+
+    Moves the item to the point \a pnt.
+*/
+
+bool QIconViewItem::move( const QPoint &pnt )
+{
+    return move( pnt.x(), pnt.y() );
+}
+
+/*!
+    \overload
+
+    Moves the item by the x, y values in point \a pnt.
+*/
+
+void QIconViewItem::moveBy( const QPoint &pnt )
+{
+    moveBy( pnt.x(), pnt.y() );
+}
+
+/*!
+    Returns the bounding rectangle of the item (in contents
+    coordinates).
+*/
+
+QRect QIconViewItem::rect() const
+{
+    return itemRect;
+}
+
+/*!
+    Returns the x-coordinate of the item (in contents coordinates).
+*/
+
+int QIconViewItem::x() const
+{
+    return itemRect.x();
+}
+
+/*!
+    Returns the y-coordinate of the item (in contents coordinates).
+*/
+
+int QIconViewItem::y() const
+{
+    return itemRect.y();
+}
+
+/*!
+    Returns the width of the item.
+*/
+
+int QIconViewItem::width() const
+{
+    return QMAX( itemRect.width(), QApplication::globalStrut().width() );
+}
+
+/*!
+    Returns the height of the item.
+*/
+
+int QIconViewItem::height() const
+{
+    return QMAX( itemRect.height(), QApplication::globalStrut().height() );
+}
+
+/*!
+    Returns the size of the item.
+*/
+
+QSize QIconViewItem::size() const
+{
+    return QSize( itemRect.width(), itemRect.height() );
+}
+
+/*!
+    Returns the position of the item (in contents coordinates).
+*/
+
+QPoint QIconViewItem::pos() const
+{
+    return QPoint( itemRect.x(), itemRect.y() );
+}
+
+/*!
+    Returns the bounding rectangle of the item's text.
+
+    If \a relative is TRUE, (the default), the returned rectangle is
+    relative to the origin of the item's rectangle. If \a relative is
+    FALSE, the returned rectangle is relative to the origin of the
+    icon view's contents coordinate system.
+*/
+
+QRect QIconViewItem::textRect( bool relative ) const
+{
+    if ( relative )
+	return itemTextRect;
+    else
+	return QRect( x() + itemTextRect.x(), y() + itemTextRect.y(), itemTextRect.width(), itemTextRect.height() );
+}
+
+/*!
+    Returns the bounding rectangle of the item's icon.
+
+    If \a relative is TRUE, (the default), the rectangle is relative to
+    the origin of the item's rectangle. If \a relative is FALSE, the
+    returned rectangle is relative to the origin of the icon view's
+    contents coordinate system.
+*/
+
+QRect QIconViewItem::pixmapRect( bool relative ) const
+{
+    if ( relative )
+	return itemIconRect;
+    else
+	return QRect( x() + itemIconRect.x(), y() + itemIconRect.y(), itemIconRect.width(), itemIconRect.height() );
+}
+
+/*!
+    Returns TRUE if the item contains the point \a pnt (in contents
+    coordinates); otherwise returns FALSE.
+*/
+
+bool QIconViewItem::contains( const QPoint& pnt ) const
+{
+    QRect textArea = textRect( FALSE );
+    QRect pixmapArea = pixmapRect( FALSE );
+    if ( iconView()->itemTextPos() == QIconView::Bottom )
+	textArea.setTop( pixmapArea.bottom() );
+    else
+	textArea.setLeft( pixmapArea.right() );
+    return textArea.contains( pnt ) || pixmapArea.contains( pnt );
+}
+
+/*!
+    Returns TRUE if the item intersects the rectangle \a r (in
+    contents coordinates); otherwise returns FALSE.
+*/
+
+bool QIconViewItem::intersects( const QRect& r ) const
+{
+    return ( textRect( FALSE ).intersects( r ) ||
+	     pixmapRect( FALSE ).intersects( r ) );
+}
+
+/*!
+    \fn bool QIconViewItem::acceptDrop( const QMimeSource *mime ) const
+
+    Returns TRUE if you can drop things with a QMimeSource of \a mime
+    onto this item; otherwise returns FALSE.
+
+    The default implementation always returns FALSE. You must subclass
+    QIconViewItem and reimplement acceptDrop() to accept drops.
+*/
+
+bool QIconViewItem::acceptDrop( const QMimeSource * ) const
+{
+    return FALSE;
+}
+
+#ifndef QT_NO_TEXTEDIT
+/*!
+    Starts in-place renaming of an icon, if allowed.
+
+    This function sets up the icon view so that the user can edit the
+    item text, and then returns. When the user is done, setText() will
+    be called and QIconView::itemRenamed() will be emitted (unless the
+    user canceled, e.g. by pressing the Escape key).
+
+    \sa setRenameEnabled()
+*/
+
+void QIconViewItem::rename()
+{
+    if ( !view )
+	return;
+    if ( renameBox )
+	removeRenameBox();
+    oldRect = rect();
+    renameBox = new QIconViewItemLineEdit( itemText, view->viewport(), this, "qt_renamebox" );
+    iconView()->ensureItemVisible( this );
+    QRect tr( textRect( FALSE ) );
+    view->addChild( renameBox, tr.x() + ( tr.width() / 2 - renameBox->width() / 2 ), tr.y() - 3 );
+    renameBox->selectAll();
+    view->viewport()->setFocusProxy( renameBox );
+    renameBox->setFocus();
+    renameBox->show();
+    Q_ASSERT( view->d->renamingItem == 0L );
+    view->d->renamingItem = this;
+}
+#endif
+
+/*!
+    Compares this icon view item to \a i. Returns -1 if this item is
+    less than \a i, 0 if they are equal, and 1 if this icon view item
+    is greater than \a i.
+
+    The default implementation compares the item keys (key()) using
+    QString::localeAwareCompare(). A reimplementation may use
+    different values and a different comparison function. Here is a
+    reimplementation that uses plain Unicode comparison:
+
+    \code
+	int MyIconViewItem::compare( QIconViewItem *i ) const
+	{
+	    return key().compare( i->key() );
+	}
+    \endcode
+
+    \sa key() QString::localeAwareCompare() QString::compare()
+*/
+
+int QIconViewItem::compare( QIconViewItem *i ) const
+{
+    return key().localeAwareCompare( i->key() );
+}
+
+#ifndef QT_NO_TEXTEDIT
+/*!
+  This private function is called when the user pressed Return during
+  in-place renaming.
+*/
+
+void QIconViewItem::renameItem()
+{
+    if ( !renameBox || !view )
+	return;
+
+    if ( !view->d->wordWrapIconText ) {
+	wordWrapDirty = TRUE;
+	calcRect();
+    }
+    QRect r = itemRect;
+    setText( renameBox->text() );
+    view->repaintContents( oldRect.x() - 1, oldRect.y() - 1, oldRect.width() + 2, oldRect.height() + 2, FALSE );
+    view->repaintContents( r.x() - 1, r.y() - 1, r.width() + 2, r.height() + 2, FALSE );
+    removeRenameBox();
+
+    view->emitRenamed( this );
+}
+
+/*!
+    Cancels in-place renaming.
+*/
+
+void QIconViewItem::cancelRenameItem()
+{
+    if ( !view )
+	return;
+
+    QRect r = itemRect;
+    calcRect();
+    view->repaintContents( oldRect.x() - 1, oldRect.y() - 1, oldRect.width() + 2, oldRect.height() + 2, FALSE );
+    view->repaintContents( r.x() - 1, r.y() - 1, r.width() + 2, r.height() + 2, FALSE );
+
+    if ( !renameBox )
+	return;
+
+    removeRenameBox();
+}
+
+/*!
+    Removes the editbox that is used for in-place renaming.
+*/
+
+void QIconViewItem::removeRenameBox()
+{
+    if ( !renameBox || !view )
+	return;
+
+    bool resetFocus = view->viewport()->focusProxy() == renameBox;
+    delete renameBox;
+    renameBox = 0;
+    if ( resetFocus ) {
+	view->viewport()->setFocusProxy( view );
+	view->setFocus();
+    }
+    Q_ASSERT( view->d->renamingItem == this );
+    view->d->renamingItem = 0L;
+}
+#endif
+
+/*!
+    This virtual function is responsible for calculating the
+    rectangles returned by rect(), textRect() and pixmapRect().
+    setRect(), setTextRect() and setPixmapRect() are provided mainly
+    for reimplementations of this function.
+
+    \a text_ is an internal parameter which defaults to QString::null.
+*/
+
+void QIconViewItem::calcRect( const QString &text_ )
+{
+    if ( !view ) // #####
+	return;
+
+    wordWrapDirty = TRUE;
+    int pw = 0;
+    int ph = 0;
+
+#ifndef QT_NO_PICTURE
+    if ( picture() ) {
+	QRect br = picture()->boundingRect();
+	pw = br.width() + 2;
+	ph = br.height() + 2;
+    } else
+#endif
+    {
+	pw = ( pixmap() ? pixmap() : unknown_icon )->width() + 2;
+	ph = ( pixmap() ? pixmap() : unknown_icon )->height() + 2;
+    }
+
+    itemIconRect.setWidth( pw );
+    itemIconRect.setHeight( ph );
+
+    calcTmpText();
+
+    QString t = text_;
+    if ( t.isEmpty() ) {
+	if ( view->d->wordWrapIconText )
+	    t = itemText;
+	else
+	    t = tmpText;
+    }
+
+    int tw = 0;
+    int th = 0;
+    // ##### TODO: fix font bearings!
+    QRect r;
+    if ( view->d->wordWrapIconText ) {
+	r = QRect( view->d->fm->boundingRect( 0, 0, iconView()->maxItemWidth() -
+					      ( iconView()->itemTextPos() == QIconView::Bottom ? 0 :
+						pixmapRect().width() ),
+					      0xFFFFFFFF, AlignHCenter | WordBreak | BreakAnywhere, t ) );
+	r.setWidth( r.width() + 4 );
+    } else {
+	r = QRect( 0, 0, view->d->fm->width( t ), view->d->fm->height() );
+	r.setWidth( r.width() + 4 );
+    }
+
+    if ( r.width() > iconView()->maxItemWidth() -
+	 ( iconView()->itemTextPos() == QIconView::Bottom ? 0 :
+	   pixmapRect().width() ) )
+	r.setWidth( iconView()->maxItemWidth() - ( iconView()->itemTextPos() == QIconView::Bottom ? 0 :
+						   pixmapRect().width() ) );
+
+    tw = r.width();
+    th = r.height();
+    if ( tw < view->d->fm->width( "X" ) )
+	tw = view->d->fm->width( "X" );
+
+    itemTextRect.setWidth( tw );
+    itemTextRect.setHeight( th );
+
+    int w = 0;
+    int h = 0;
+    if ( view->itemTextPos() == QIconView::Bottom ) {
+	w = QMAX( itemTextRect.width(), itemIconRect.width() );
+	h = itemTextRect.height() + itemIconRect.height() + 1;
+
+	itemRect.setWidth( w );
+	itemRect.setHeight( h );
+
+	itemTextRect = QRect( ( width() - itemTextRect.width() ) / 2, height() - itemTextRect.height(),
+			      itemTextRect.width(), itemTextRect.height() );
+	itemIconRect = QRect( ( width() - itemIconRect.width() ) / 2, 0,
+			      itemIconRect.width(), itemIconRect.height() );
+    } else {
+	h = QMAX( itemTextRect.height(), itemIconRect.height() );
+	w = itemTextRect.width() + itemIconRect.width() + 1;
+
+	itemRect.setWidth( w );
+	itemRect.setHeight( h );
+
+	itemTextRect = QRect( width() - itemTextRect.width(), ( height() - itemTextRect.height() ) / 2,
+			      itemTextRect.width(), itemTextRect.height() );
+	itemIconRect = QRect( 0, ( height() - itemIconRect.height() ) / 2,
+			      itemIconRect.width(), itemIconRect.height() );
+    }
+    if ( view )
+	view->updateItemContainer( this );
+}
+
+/*!
+    Paints the item using the painter \a p and the color group \a cg.
+    If you want the item to be drawn with a different font or color,
+    reimplement this function, change the values of the color group or
+    the painter's font, and then call the QIconViewItem::paintItem()
+    with the changed values.
+*/
+
+void QIconViewItem::paintItem( QPainter *p, const QColorGroup &cg )
+{
+    if ( !view )
+	return;
+
+    p->save();
+
+    if ( isSelected() ) {
+	p->setPen( cg.highlightedText() );
+    } else {
+	p->setPen( cg.text() );
+    }
+
+    calcTmpText();
+
+#ifndef QT_NO_PICTURE
+    if ( picture() ) {
+	QPicture *pic = picture();
+	if ( isSelected() ) {
+	    p->fillRect( pixmapRect( FALSE ), QBrush( cg.highlight(), QBrush::Dense4Pattern) );
+	}
+	p->drawPicture( x()-pic->boundingRect().x(), y()-pic->boundingRect().y(), *pic );
+	if ( isSelected() ) {
+	    p->fillRect( textRect( FALSE ), cg.highlight() );
+	    p->setPen( QPen( cg.highlightedText() ) );
+	} else if ( view->d->itemTextBrush != NoBrush )
+	    p->fillRect( textRect( FALSE ), view->d->itemTextBrush );
+
+	int align = view->itemTextPos() == QIconView::Bottom ? AlignHCenter : AlignAuto;
+	if ( view->d->wordWrapIconText )
+	    align |= WordBreak | BreakAnywhere;
+	p->drawText( textRect( FALSE ), align, view->d->wordWrapIconText ? itemText : tmpText );
+	p->restore();
+	return;
+    }
+#endif
+    bool textOnBottom = ( view->itemTextPos() == QIconView::Bottom );
+    int dim;
+    if ( textOnBottom )
+	dim = ( pixmap() ? pixmap() : unknown_icon)->width();
+    else
+	dim = ( pixmap() ? pixmap() : unknown_icon)->height();
+    if ( isSelected() ) {
+	QPixmap *pix = pixmap() ? pixmap() : unknown_icon;
+	if ( pix && !pix->isNull() ) {
+	    QPixmap *buffer = get_qiv_buffer_pixmap( pix->size() );
+	    QBitmap mask = view->mask( pix );
+
+	    QPainter p2( buffer );
+	    p2.fillRect( pix->rect(), white );
+	    p2.drawPixmap( 0, 0, *pix );
+	    p2.end();
+	    buffer->setMask( mask );
+	    p2.begin( buffer );
+#if defined(Q_WS_X11)
+	    p2.fillRect( pix->rect(), QBrush( cg.highlight(), QBrush::Dense4Pattern) );
+#else // in WIN32 Dense4Pattern doesn't work correctly (transparency problem), so work around it
+	    if ( iconView()->d->drawActiveSelection ) {
+		if ( !qiv_selection )
+		    createSelectionPixmap( cg );
+		p2.drawTiledPixmap( 0, 0, pix->width(), pix->height(),
+				    *qiv_selection );
+	    }
+#endif
+	    p2.end();
+	    QRect cr = pix->rect();
+	    if ( textOnBottom )
+		p->drawPixmap( x() + ( width() - dim ) / 2, y(), *buffer, 0, 0,
+			       cr.width(), cr.height() );
+	    else
+		p->drawPixmap( x() , y() + ( height() - dim ) / 2, *buffer, 0, 0,
+			       cr.width(), cr.height() );
+	}
+    } else {
+	if ( textOnBottom )
+	    p->drawPixmap( x() + ( width() - dim ) / 2, y(),
+			   *( pixmap() ? pixmap() : unknown_icon ) );
+	else
+	    p->drawPixmap( x() , y() + ( height() - dim ) / 2,
+			   *( pixmap() ? pixmap() : unknown_icon ) );
+    }
+
+    p->save();
+    if ( isSelected() ) {
+	p->fillRect( textRect( FALSE ), cg.highlight() );
+	p->setPen( QPen( cg.highlightedText() ) );
+    } else if ( view->d->itemTextBrush != NoBrush )
+	p->fillRect( textRect( FALSE ), view->d->itemTextBrush );
+
+    int align = AlignHCenter;
+    if ( view->d->wordWrapIconText )
+	align |= WordBreak | BreakAnywhere;
+    p->drawText( textRect( FALSE ), align,
+		 view->d->wordWrapIconText ? itemText : tmpText );
+
+    p->restore();
+
+    p->restore();
+}
+
+/*!
+    Paints the focus rectangle of the item using the painter \a p and
+    the color group \a cg.
+*/
+
+void QIconViewItem::paintFocus( QPainter *p, const QColorGroup &cg )
+{
+    if ( !view )
+	return;
+
+    view->style().drawPrimitive(QStyle::PE_FocusRect, p,
+				QRect( textRect( FALSE ).x(), textRect( FALSE ).y(),
+				       textRect( FALSE ).width(),
+				       textRect( FALSE ).height() ), cg,
+				(isSelected() ?
+				 QStyle::Style_FocusAtBorder :
+				 QStyle::Style_Default),
+				QStyleOption(isSelected() ? cg.highlight() : cg.base()));
+
+    if ( this != view->d->currentItem ) {
+	view->style().drawPrimitive(QStyle::PE_FocusRect, p,
+				    QRect( pixmapRect( FALSE ).x(),
+					   pixmapRect( FALSE ).y(),
+					   pixmapRect( FALSE ).width(),
+					   pixmapRect( FALSE ).height() ),
+				    cg, QStyle::Style_Default,
+				    QStyleOption(cg.base()));
+    }
+}
+
+/*!
+    \fn void QIconViewItem::dropped( QDropEvent *e, const QValueList<QIconDragItem> &lst )
+
+    This function is called when something is dropped on the item. \a
+    e provides all the information about the drop. If the drag object
+    of the drop was a QIconDrag, \a lst contains the list of the
+    dropped items. You can get the data by calling
+    QIconDragItem::data() on each item. If the \a lst is empty, i.e.
+    the drag was not a QIconDrag, you must decode the data in \a e and
+    work with that.
+
+    The default implementation does nothing; subclasses may
+    reimplement this function.
+*/
+
+#ifndef QT_NO_DRAGANDDROP
+void QIconViewItem::dropped( QDropEvent *, const QValueList<QIconDragItem> & )
+{
+}
+#endif
+
+/*!
+    This function is called when a drag enters the item's bounding
+    rectangle.
+
+    The default implementation does nothing; subclasses may
+    reimplement this function.
+*/
+
+void QIconViewItem::dragEntered()
+{
+}
+
+/*!
+    This function is called when a drag leaves the item's bounding
+    rectangle.
+
+    The default implementation does nothing; subclasses may
+    reimplement this function.
+*/
+
+void QIconViewItem::dragLeft()
+{
+}
+
+/*!
+    Sets the bounding rectangle of the whole item to \a r. This
+    function is provided for subclasses which reimplement calcRect(),
+    so that they can set the calculated rectangle. \e{Any other use is
+    discouraged.}
+
+    \sa calcRect() textRect() setTextRect() pixmapRect() setPixmapRect()
+*/
+
+void QIconViewItem::setItemRect( const QRect &r )
+{
+    itemRect = r;
+    checkRect();
+    if ( view )
+	view->updateItemContainer( this );
+}
+
+/*!
+    Sets the bounding rectangle of the item's text to \a r. This
+    function is provided for subclasses which reimplement calcRect(),
+    so that they can set the calculated rectangle. \e{Any other use is
+    discouraged.}
+
+    \sa calcRect() textRect() setItemRect() setPixmapRect()
+*/
+
+void QIconViewItem::setTextRect( const QRect &r )
+{
+    itemTextRect = r;
+    if ( view )
+	view->updateItemContainer( this );
+}
+
+/*!
+    Sets the bounding rectangle of the item's icon to \a r. This
+    function is provided for subclasses which reimplement calcRect(),
+    so that they can set the calculated rectangle. \e{Any other use is
+    discouraged.}
+
+    \sa calcRect() pixmapRect() setItemRect() setTextRect()
+*/
+
+void QIconViewItem::setPixmapRect( const QRect &r )
+{
+    itemIconRect = r;
+    if ( view )
+	view->updateItemContainer( this );
+}
+
+/*!
+    \internal
+*/
+
+void QIconViewItem::calcTmpText()
+{
+    if ( !view || view->d->wordWrapIconText || !wordWrapDirty )
+	return;
+    wordWrapDirty = FALSE;
+
+    int w = iconView()->maxItemWidth() - ( iconView()->itemTextPos() == QIconView::Bottom ? 0 :
+					   pixmapRect().width() );
+    if ( view->d->fm->width( itemText ) < w ) {
+	tmpText = itemText;
+	return;
+    }
+
+    tmpText = "...";
+    int i = 0;
+    while ( view->d->fm->width( tmpText + itemText[ i ] ) < w )
+	tmpText += itemText[ i++ ];
+    tmpText.remove( (uint)0, 3 );
+    tmpText += "...";
+}
+
+/*! \internal */
+
+QString QIconViewItem::tempText() const
+{
+    return tmpText;
+}
+
+void QIconViewItem::checkRect()
+{
+    int x = itemRect.x();
+    int y = itemRect.y();
+    int w = itemRect.width();
+    int h = itemRect.height();
+
+    bool changed = FALSE;
+    if ( x < 0 ) {
+	x = 0;
+	changed = TRUE;
+    }
+    if ( y < 0 ) {
+	y = 0;
+	changed = TRUE;
+    }
+
+    if ( changed )
+	itemRect.setRect( x, y, w, h );
+}
+
+
+/*! \file iconview/simple_dd/main.h */
+/*! \file iconview/simple_dd/main.cpp */
+
+
+/*!
+    \class QIconView qiconview.h
+    \brief The QIconView class provides an area with movable labelled icons.
+
+    \module iconview
+    \ingroup advanced
+    \mainclass
+
+    A QIconView can display and manage a grid or other 2D layout of
+    labelled icons. Each labelled icon is a QIconViewItem. Items
+    (QIconViewItems) can be added or deleted at any time; items can be
+    moved within the QIconView. Single or multiple items can be
+    selected. Items can be renamed in-place. QIconView also supports
+    \link #draganddrop drag and drop\endlink.
+
+    Each item contains a label string, a pixmap or picture (the icon
+    itself) and optionally a sort key. The sort key is used for
+    sorting the items and defaults to the label string. The label
+    string can be displayed below or to the right of the icon (see \l
+    ItemTextPos).
+
+    The simplest way to create a QIconView is to create a QIconView
+    object and create some QIconViewItems with the QIconView as their
+    parent, set the icon view's geometry and show it.
+    For example:
+    \code
+    QIconView *iv = new QIconView( this );
+    QDir dir( path, "*.xpm" );
+    for ( uint i = 0; i < dir.count(); i++ ) {
+	(void) new QIconViewItem( iv, dir[i], QPixmap( path + dir[i] ) );
+    }
+    iv->resize( 600, 400 );
+    iv->show();
+    \endcode
+
+    The QIconViewItem call passes a pointer to the QIconView we wish to
+    populate, along with the label text and a QPixmap.
+
+    When an item is inserted the QIconView allocates a position for it.
+    Existing items are rearranged if autoArrange() is TRUE. The
+    default arrangement is \c LeftToRight -- the QIconView fills up
+    the \e left-most column from top to bottom, then moves one column
+    \e right and fills that from top to bottom and so on. The
+    arrangement can be modified with any of the following approaches:
+    \list
+    \i Call setArrangement(), e.g. with \c TopToBottom which will fill
+    the \e top-most row from left to right, then moves one row \e down
+    and fills that row from left to right and so on.
+    \i Construct each QIconViewItem using a constructor which allows
+    you to specify which item the new one is to follow.
+    \i Call setSorting() or sort() to sort the items.
+    \endlist
+
+    The spacing between items is set with setSpacing(). Items can be
+    laid out using a fixed grid using setGridX() and setGridY(); by
+    default the QIconView calculates a grid dynamically. The position
+    of items' label text is set with setItemTextPos(). The text's
+    background can be set with setItemTextBackground(). The maximum
+    width of an item and of its text are set with setMaxItemWidth()
+    and setMaxItemTextLength(). The label text will be word-wrapped if
+    it is too long; this is controlled by setWordWrapIconText(). If
+    the label text is truncated, the user can still see the entire
+    text in a tool tip if they hover the mouse over the item. This is
+    controlled with setShowToolTips().
+
+    Items which are \link QIconViewItem::isSelectable()
+    selectable\endlink may be selected depending on the SelectionMode;
+    the default is \c Single. Because QIconView offers multiple
+    selection it must display keyboard focus and selection state
+    separately. Therefore there are functions to set the selection
+    state of an item (setSelected()) and to select which item displays
+    keyboard focus (setCurrentItem()). When multiple items may be
+    selected the icon view provides a rubberband, too.
+
+    When in-place renaming is enabled (it is disabled by default), the
+    user may change the item's label. They do this by selecting the item
+    (single clicking it or navigating to it with the arrow keys), then
+    single clicking it (or pressing F2), and entering their text. If no
+    key has been set with QIconViewItem::setKey() the new text will also
+    serve as the key. (See QIconViewItem::setRenameEnabled().)
+
+    You can control whether users can move items themselves with
+    setItemsMovable().
+
+    Because the internal structure used to store the icon view items is
+    linear, no iterator class is needed to iterate over all the items.
+    Instead we iterate by getting the first item from the \e{icon view}
+    and then each subsequent (\l QIconViewItem::nextItem()) from each
+    \e item in turn:
+    \code
+	for ( QIconViewItem *item = iv->firstItem(); item; item = item->nextItem() )
+	    do_something( item );
+    \endcode
+    QIconView also provides currentItem(). You can search for an item
+    using findItem() (searching by position or for label text) and
+    with findFirstVisibleItem() and findLastVisibleItem(). The number
+    of items is returned by count(). An item can be removed from an
+    icon view using takeItem(); to delete an item use \c delete. All
+    the items can be deleted with clear().
+
+    The QIconView emits a wide range of useful signals, including
+    selectionChanged(), currentChanged(), clicked(), moved() and
+    itemRenamed().
+
+    \target draganddrop
+    \section1 Drag and Drop
+
+    QIconView supports the drag and drop of items within the QIconView
+    itself. It also supports the drag and drop of items out of or into
+    the QIconView and drag and drop onto items themselves. The drag and
+    drop of items outside the QIconView can be achieved in a simple way
+    with basic functionality, or in a more sophisticated way which
+    provides more power and control.
+
+    The simple approach to dragging items out of the icon view is to
+    subclass QIconView and reimplement QIconView::dragObject().
+
+    \code
+    QDragObject *MyIconView::dragObject()
+    {
+	return new QTextDrag( currentItem()->text(), this );
+    }
+    \endcode
+
+    In this example we create a QTextDrag object, (derived from
+    QDragObject), containing the item's label and return it as the drag
+    object. We could just as easily have created a QImageDrag from the
+    item's pixmap and returned that instead.
+
+    QIconViews and their QIconViewItems can also be the targets of drag
+    and drops. To make the QIconView itself able to accept drops connect
+    to the dropped() signal. When a drop occurs this signal will be
+    emitted with a QDragEvent and a QValueList of QIconDragItems. To
+    make a QIconViewItem into a drop target subclass QIconViewItem and
+    reimplement QIconViewItem::acceptDrop() and
+    QIconViewItem::dropped().
+
+    \code
+    bool MyIconViewItem::acceptDrop( const QMimeSource *mime ) const
+    {
+	if ( mime->provides( "text/plain" ) )
+	    return TRUE;
+	return FALSE;
+    }
+
+    void MyIconViewItem::dropped( QDropEvent *evt, const QValueList<QIconDragItem>& )
+    {
+	QString label;
+	if ( QTextDrag::decode( evt, label ) )
+	    setText( label );
+    }
+    \endcode
+
+    See \l iconview/simple_dd/main.h and \l
+    iconview/simple_dd/main.cpp for a simple drag and drop example
+    which demonstrates drag and drop between a QIconView and a
+    QListBox.
+
+    If you want to use extended drag-and-drop or have drag shapes drawn
+    you must take a more sophisticated approach.
+
+    The first part is starting drags -- you should use a QIconDrag (or a
+    class derived from it) for the drag object. In dragObject() create the
+    drag object, populate it with QIconDragItems and return it. Normally
+    such a drag should offer each selected item's data. So in dragObject()
+    you should iterate over all the items, and create a QIconDragItem for
+    each selected item, and append these items with QIconDrag::append() to
+    the QIconDrag object. You can use QIconDragItem::setData() to set the
+    data of each item that should be dragged. If you want to offer the
+    data in additional mime-types, it's best to use a class derived from
+    QIconDrag, which implements additional encoding and decoding
+    functions.
+
+    When a drag enters the icon view, there is little to do. Simply
+    connect to the dropped() signal and reimplement
+    QIconViewItem::acceptDrop() and QIconViewItem::dropped(). If you've
+    used a QIconDrag (or a subclass of it) the second argument to the
+    dropped signal contains a QValueList of QIconDragItems -- you can
+    access their data by calling QIconDragItem::data() on each one.
+
+    For an example implementation of complex drag-and-drop look at the
+    fileiconview example (qt/examples/fileiconview).
+
+    \sa QIconViewItem::setDragEnabled(), QIconViewItem::setDropEnabled(),
+	QIconViewItem::acceptDrop(), QIconViewItem::dropped().
+
+    <img src=qiconview-m.png> <img src=qiconview-w.png>
+*/
+
+/*! \enum QIconView::ResizeMode
+
+    This enum type is used to tell QIconView how it should treat the
+    positions of its icons when the widget is resized. The modes are:
+
+    \value Fixed  The icons' positions are not changed.
+    \value Adjust  The icons' positions are adjusted to be within the
+    new geometry, if possible.
+*/
+
+/*!
+    \enum QIconView::SelectionMode
+
+    This enumerated type is used by QIconView to indicate how it
+    reacts to selection by the user. It has four values:
+
+    \value Single  When the user selects an item, any already-selected
+    item becomes unselected and the user cannot unselect the selected
+    item. This means that the user can never clear the selection. (The
+    application programmer can, using QIconView::clearSelection().)
+
+    \value Multi  When the user selects an item, e.g. by navigating to
+    it with the keyboard arrow keys or by clicking it, the selection
+    status of that item is toggled and the other items are left alone.
+
+    \value Extended  When the user selects an item the selection is
+    cleared and the new item selected. However, if the user presses
+    the Ctrl key when clicking on an item, the clicked item gets
+    toggled and all other items are left untouched. If the user
+    presses the Shift key while clicking on an item, all items between
+    the current item and the clicked item get selected or unselected,
+    depending on the state of the clicked item. Also, multiple items
+    can be selected by dragging the mouse while the left mouse button
+    stays pressed.
+
+    \value NoSelection  Items cannot be selected.
+
+    To summarise: \c Single is a real single-selection icon view; \c
+    Multi a real multi-selection icon view; \c Extended is an icon
+    view in which users can select multiple items but usually want to
+    select either just one or a range of contiguous items; and \c
+    NoSelection mode is for an icon view where the user can look but
+    not touch.
+*/
+
+/*!
+    \enum QIconView::Arrangement
+
+    This enum type determines in which direction the items flow when
+    the view runs out of space.
+
+    \value LeftToRight  Items which don't fit into the view go further
+    down (you get a vertical scrollbar)
+
+    \value TopToBottom  Items which don't fit into the view go further
+    right (you get a horizontal scrollbar)
+*/
+
+/*!
+    \enum QIconView::ItemTextPos
+
+    This enum type specifies the position of the item text in relation
+    to the icon.
+
+    \value Bottom  The text is drawn below the icon.
+    \value Right  The text is drawn to the right of the icon.
+*/
+
+/*!
+    \fn void  QIconView::dropped ( QDropEvent * e, const QValueList<QIconDragItem> &lst )
+
+    This signal is emitted when a drop event occurs in the viewport
+    (but not on any icon) which the icon view itself can't handle.
+
+    \a e provides all the information about the drop. If the drag
+    object of the drop was a QIconDrag, \a lst contains the list of
+    the dropped items. You can get the data using
+    QIconDragItem::data() on each item. If the \a lst is empty, i.e.
+    the drag was not a QIconDrag, you have to decode the data in \a e
+    and work with that.
+
+    Note QIconViewItems may be drop targets; if a drop event occurs on
+    an item the item handles the drop.
+*/
+
+/*!
+    \fn void QIconView::moved()
+
+    This signal is emitted after successfully dropping one (or more)
+    items of the icon view. If the items should be removed, it's best
+    to do so in a slot connected to this signal.
+*/
+
+/*!
+    \fn void  QIconView::doubleClicked(QIconViewItem * item)
+
+    This signal is emitted when the user double-clicks on \a item.
+*/
+
+/*!
+    \fn void  QIconView::returnPressed (QIconViewItem * item)
+
+    This signal is emitted if the user presses the Return or Enter
+    key. \a item is the currentItem() at the time of the keypress.
+*/
+
+/*!
+    \fn void  QIconView::selectionChanged()
+
+    This signal is emitted when the selection has been changed. It's
+    emitted in each selection mode.
+*/
+
+/*!
+    \overload void QIconView::selectionChanged( QIconViewItem *item )
+
+    This signal is emitted when the selection changes. \a item is the
+    newly selected item. This signal is emitted only in single
+    selection mode.
+*/
+
+/*!
+    \fn void QIconView::currentChanged( QIconViewItem *item )
+
+    This signal is emitted when a new item becomes current. \a item is
+    the new current item (or 0 if no item is now current).
+
+    \sa currentItem()
+*/
+
+/*!
+    \fn void  QIconView::onItem( QIconViewItem *item )
+
+    This signal is emitted when the user moves the mouse cursor onto
+    an \a item, similar to the QWidget::enterEvent() function.
+*/
+
+// ### bug here - enter/leave event aren't considered. move the mouse
+// out of the window and back in, to the same item.
+
+/*!
+    \fn void QIconView::onViewport()
+
+    This signal is emitted when the user moves the mouse cursor from
+    an item to an empty part of the icon view.
+
+    \sa onItem()
+*/
+
+/*!
+    \overload void QIconView::itemRenamed (QIconViewItem * item)
+
+    This signal is emitted when \a item has been renamed, usually by
+    in-place renaming.
+
+    \sa QIconViewItem::setRenameEnabled() QIconViewItem::rename()
+*/
+
+/*!
+    \fn void QIconView::itemRenamed (QIconViewItem * item, const QString &name)
+
+    This signal is emitted when \a item has been renamed to \a name,
+    usually by in-place renaming.
+
+    \sa QIconViewItem::setRenameEnabled() QIconViewItem::rename()
+*/
+
+/*!
+    \fn void QIconView::rightButtonClicked (QIconViewItem * item, const QPoint & pos)
+
+    This signal is emitted when the user clicks the right mouse
+    button. If \a item is non-null, the cursor is on \a item. If \a
+    item is null, the mouse cursor isn't on any item.
+
+    \a pos is the position of the mouse cursor in the global
+    coordinate system (QMouseEvent::globalPos()). (If the click's
+    press and release differ by a pixel or two, \a pos is the
+    position at release time.)
+
+    \sa rightButtonPressed() mouseButtonClicked() clicked()
+*/
+
+/*!
+    \fn void QIconView::contextMenuRequested( QIconViewItem *item, const QPoint & pos )
+
+    This signal is emitted when the user invokes a context menu with
+    the right mouse button or with special system keys, with \a item
+    being the item under the mouse cursor or the current item,
+    respectively.
+
+    \a pos is the position for the context menu in the global
+    coordinate system.
+*/
+
+/*!
+    \fn void QIconView::mouseButtonPressed (int button, QIconViewItem * item, const QPoint & pos)
+
+    This signal is emitted when the user presses mouse button \a
+    button. If \a item is non-null, the cursor is on \a item. If \a
+    item is null, the mouse cursor isn't on any item.
+
+    \a pos is the position of the mouse cursor in the global
+    coordinate system (QMouseEvent::globalPos()).
+
+    \sa rightButtonClicked() mouseButtonPressed() pressed()
+*/
+
+/*!
+    \fn void QIconView::mouseButtonClicked (int button, QIconViewItem * item, const QPoint & pos )
+
+    This signal is emitted when the user clicks mouse button \a
+    button. If \a item is non-null, the cursor is on \a item. If \a
+    item is null, the mouse cursor isn't on any item.
+
+    \a pos is the position of the mouse cursor in the global
+    coordinate system (QMouseEvent::globalPos()). (If the click's
+    press and release differ by a pixel or two, \a pos is the
+    position at release time.)
+
+    \sa mouseButtonPressed() rightButtonClicked() clicked()
+*/
+
+/*!
+    \overload void QIconView::clicked ( QIconViewItem * item, const QPoint & pos )
+
+    This signal is emitted when the user clicks any mouse button on an
+    icon view item. \a item is a pointer to the item that has been
+    clicked.
+
+    \a pos is the position of the mouse cursor in the global coordinate
+    system (QMouseEvent::globalPos()). (If the click's press and release
+    differ by a pixel or two, \a pos is the  position at release time.)
+
+    \sa mouseButtonClicked() rightButtonClicked() pressed()
+*/
+
+/*!
+    \overload void QIconView::pressed ( QIconViewItem * item, const QPoint & pos )
+
+    This signal is emitted when the user presses any mouse button. If
+    \a item is non-null, the cursor is on \a item. If \a item is null,
+    the mouse cursor isn't on any item.
+
+    \a pos is the position of the mouse cursor in the global
+    coordinate system (QMouseEvent::globalPos()). (If the click's
+    press and release differ by a pixel or two, \a pos is the
+    position at release time.)
+
+    \sa mouseButtonPressed() rightButtonPressed() clicked()
+*/
+
+/*!
+    \fn void QIconView::clicked ( QIconViewItem * item )
+
+    This signal is emitted when the user clicks any mouse button. If
+    \a item is non-null, the cursor is on \a item. If \a item is null,
+    the mouse cursor isn't on any item.
+
+    \sa mouseButtonClicked() rightButtonClicked() pressed()
+*/
+
+/*!
+    \fn void QIconView::pressed ( QIconViewItem * item )
+
+    This signal is emitted when the user presses any mouse button. If
+    \a item is non-null, the cursor is on \a item. If \a item is null,
+    the mouse cursor isn't on any item.
+
+    \sa mouseButtonPressed() rightButtonPressed() clicked()
+*/
+
+/*!
+    \fn void QIconView::rightButtonPressed( QIconViewItem * item, const QPoint & pos )
+
+    This signal is emitted when the user presses the right mouse
+    button. If \a item is non-null, the cursor is on \a item. If \a
+    item is null, the mouse cursor isn't on any item.
+
+    \a pos is the position of the mouse cursor in the global
+    coordinate system (QMouseEvent::globalPos()).
+*/
+
+/*!
+    Constructs an empty icon view called \a name, with parent \a
+    parent and using the widget flags \a f.
+*/
+
+QIconView::QIconView( QWidget *parent, const char *name, WFlags f )
+    : QScrollView( parent, name, WStaticContents | WNoAutoErase  | f )
+{
+    if ( !unknown_icon ) {
+	unknown_icon = new QPixmap( (const char **)unknown_xpm );
+	qiv_cleanup_pixmap.add( &unknown_icon );
+    }
+
+    d = new QIconViewPrivate;
+    d->dragging = FALSE;
+    d->firstItem = 0;
+    d->lastItem = 0;
+    d->count = 0;
+    d->mousePressed = FALSE;
+    d->controlPressed = FALSE;
+    d->selectionMode = Single;
+    d->currentItem = 0;
+    d->highlightedItem = 0;
+    d->rubber = 0;
+    d->scrollTimer = 0;
+    d->startDragItem = 0;
+    d->tmpCurrentItem = 0;
+    d->rastX = d->rastY = -1;
+    d->spacing = 5;
+    d->cleared = FALSE;
+    d->arrangement = LeftToRight;
+    d->resizeMode = Fixed;
+    d->dropped = FALSE;
+    d->adjustTimer = new QTimer( this, "iconview adjust timer" );
+    d->isIconDrag = FALSE;
+    d->inMenuMode = FALSE;
+#ifndef QT_NO_DRAGANDDROP
+    d->iconDragData.clear();
+#endif
+    d->numDragItems = 0;
+    d->updateTimer = new QTimer( this, "iconview update timer" );
+    d->cachedW = d->cachedH = 0;
+    d->maxItemWidth = 100;
+    d->maxItemTextLength = 255;
+    d->inputTimer = new QTimer( this, "iconview input timer" );
+    d->currInputString = QString::null;
+    d->dirty = FALSE;
+    d->rearrangeEnabled = TRUE;
+    d->itemTextPos = Bottom;
+    d->reorderItemsWhenInsert = TRUE;
+#ifndef QT_NO_CURSOR
+    d->oldCursor = arrowCursor;
+#endif
+    d->resortItemsWhenInsert = FALSE;
+    d->sortDirection = TRUE;
+    d->wordWrapIconText = TRUE;
+    d->cachedContentsX = d->cachedContentsY = -1;
+    d->clearing = FALSE;
+    d->fullRedrawTimer = new QTimer( this, "iconview full redraw timer" );
+    d->itemTextBrush = NoBrush;
+    d->drawAllBack = TRUE;
+    d->fm = new QFontMetrics( font() );
+    d->minLeftBearing = d->fm->minLeftBearing();
+    d->minRightBearing = d->fm->minRightBearing();
+    d->firstContainer = d->lastContainer = 0;
+    d->containerUpdateLocked = FALSE;
+    d->firstSizeHint = FALSE;
+    d->selectAnchor = 0;
+    d->renamingItem = 0;
+    d->drawActiveSelection = TRUE;
+    d->drawDragShapes = FALSE;
+
+    connect( d->adjustTimer, SIGNAL( timeout() ),
+	     this, SLOT( adjustItems() ) );
+    connect( d->updateTimer, SIGNAL( timeout() ),
+	     this, SLOT( slotUpdate() ) );
+    connect( d->fullRedrawTimer, SIGNAL( timeout() ),
+	     this, SLOT( updateContents() ) );
+    connect( this, SIGNAL( contentsMoving(int,int) ),
+	     this, SLOT( movedContents(int,int) ) );
+
+    setAcceptDrops( TRUE );
+    viewport()->setAcceptDrops( TRUE );
+
+    setMouseTracking( TRUE );
+    viewport()->setMouseTracking( TRUE );
+
+    viewport()->setBackgroundMode( PaletteBase);
+    setBackgroundMode( PaletteBackground, PaletteBase );
+    viewport()->setFocusProxy( this );
+    viewport()->setFocusPolicy( QWidget::WheelFocus );
+
+#ifndef QT_NO_TOOLTIP
+    d->toolTip = new QIconViewToolTip( viewport(), this );
+#endif
+    d->showTips = TRUE;
+}
+
+/*!
+    \reimp
+*/
+
+void QIconView::styleChange( QStyle& old )
+{
+    QScrollView::styleChange( old );
+    *d->fm = QFontMetrics( font() );
+    d->minLeftBearing = d->fm->minLeftBearing();
+    d->minRightBearing = d->fm->minRightBearing();
+
+    QIconViewItem *item = d->firstItem;
+    for ( ; item; item = item->next ) {
+	item->wordWrapDirty = TRUE;
+	item->calcRect();
+    }
+
+#if !defined(Q_WS_X11)
+    delete qiv_selection;
+    qiv_selection = 0;
+#endif
+}
+
+/*!
+    \reimp
+*/
+
+void QIconView::setFont( const QFont & f )
+{
+    QScrollView::setFont( f );
+    *d->fm = QFontMetrics( font() );
+    d->minLeftBearing = d->fm->minLeftBearing();
+    d->minRightBearing = d->fm->minRightBearing();
+
+    QIconViewItem *item = d->firstItem;
+    for ( ; item; item = item->next ) {
+	item->wordWrapDirty = TRUE;
+	item->calcRect();
+    }
+}
+
+/*!
+    \reimp
+*/
+
+void QIconView::setPalette( const QPalette & p )
+{
+    QScrollView::setPalette( p );
+    *d->fm = QFontMetrics( font() );
+    d->minLeftBearing = d->fm->minLeftBearing();
+    d->minRightBearing = d->fm->minRightBearing();
+
+    QIconViewItem *item = d->firstItem;
+    for ( ; item; item = item->next ) {
+	item->wordWrapDirty = TRUE;
+	item->calcRect();
+    }
+}
+
+/*!
+    Destroys the icon view and deletes all items.
+*/
+
+QIconView::~QIconView()
+{
+    QIconViewItem *tmp, *item = d->firstItem;
+    d->clearing = TRUE;
+    QIconViewPrivate::ItemContainer *c = d->firstContainer, *tmpc;
+    while ( c ) {
+	tmpc = c->n;
+	delete c;
+	c = tmpc;
+    }
+    while ( item ) {
+	tmp = item->next;
+	delete item;
+	item = tmp;
+    }
+    delete d->fm;
+    d->fm = 0;
+#ifndef QT_NO_TOOLTIP
+    delete d->toolTip;
+    d->toolTip = 0;
+#endif
+    delete d;
+}
+
+/*!
+    Inserts the icon view item \a item after \a after. If \a after is
+    0, \a item is appended after the last item.
+
+    \e{You should never need to call this function.} Instead create
+    QIconViewItem's and associate them with your icon view like this:
+
+    \code
+	(void) new QIconViewItem( myIconview, "The text of the item", aPixmap );
+    \endcode
+*/
+
+void QIconView::insertItem( QIconViewItem *item, QIconViewItem *after )
+{
+    if ( !item )
+	return;
+
+    if ( d->firstItem == item || item->prev || item->next)
+	return;
+
+    if ( !item->view )
+	item->view = this;
+
+    if ( !d->firstItem ) {
+	d->firstItem = d->lastItem = item;
+	item->prev = 0;
+	item->next = 0;
+    } else {
+	if ( !after || after == d->lastItem ) {
+	    d->lastItem->next = item;
+	    item->prev = d->lastItem;
+	    item->next = 0;
+	    d->lastItem = item;
+	} else {
+	    QIconViewItem *i = d->firstItem;
+	    while ( i != after )
+		i = i->next;
+
+	    if ( i ) {
+		QIconViewItem *next = i->next;
+		item->next = next;
+		item->prev = i;
+		i->next = item;
+		next->prev = item;
+	    }
+	}
+    }
+
+    if ( isVisible() ) {
+	if ( d->reorderItemsWhenInsert ) {
+	    if ( d->updateTimer->isActive() )
+		d->updateTimer->stop();
+	    d->fullRedrawTimer->stop();
+	    // #### uncomment this ASA insertInGrid uses cached values and is efficient
+	    //insertInGrid( item );
+
+	    d->cachedW = QMAX( d->cachedW, item->x() + item->width() );
+	    d->cachedH= QMAX( d->cachedH, item->y() + item->height() );
+
+	    d->updateTimer->start( 0, TRUE );
+	} else {
+	    insertInGrid( item );
+
+	    viewport()->update(item->x() - contentsX(),
+			       item->y() - contentsY(),
+			       item->width(), item->height());
+	}
+    } else if ( !autoArrange() ) {
+	item->dirty = FALSE;
+    }
+
+    d->count++;
+    d->dirty = TRUE;
+}
+
+/*!
+    This slot is used for a slightly-delayed update.
+
+    The icon view is not redrawn immediately after inserting a new item
+    but after a very small delay using a QTimer. This means that when
+    many items are inserted in a loop the icon view is probably redrawn
+    only once at the end of the loop. This makes the insertions both
+    flicker-free and faster.
+*/
+
+void QIconView::slotUpdate()
+{
+    d->updateTimer->stop();
+    d->fullRedrawTimer->stop();
+
+    if ( !d->firstItem || !d->lastItem )
+	return;
+
+    // #### remove that ASA insertInGrid uses cached values and is efficient
+    if ( d->resortItemsWhenInsert )
+	sort( d->sortDirection );
+    else {
+	int y = d->spacing;
+	QIconViewItem *item = d->firstItem;
+	int w = 0, h = 0;
+	while ( item ) {
+	    bool changed;
+	    QIconViewItem *next = makeRowLayout( item, y, changed );
+	    if ( !next || !next->next )
+		break;
+
+	    if( !QApplication::reverseLayout() )
+		item = next;
+	    w = QMAX( w, item->x() + item->width() );
+	    h = QMAX( h, item->y() + item->height() );
+	    item = next;
+	    if ( d->arrangement == LeftToRight )
+		h = QMAX( h, y );
+
+	    item = item->next;
+	}
+
+	if ( d->lastItem && d->arrangement == TopToBottom ) {
+	    item = d->lastItem;
+	    int x = item->x();
+	    while ( item && item->x() >= x ) {
+		w = QMAX( w, item->x() + item->width() );
+		h = QMAX( h, item->y() + item->height() );
+		item = item->prev;
+	    }
+	}
+
+	w = QMAX( QMAX( d->cachedW, w ), d->lastItem->x() + d->lastItem->width() );
+	h = QMAX( QMAX( d->cachedH, h ), d->lastItem->y() + d->lastItem->height() );
+
+	if ( d->arrangement == TopToBottom )
+	    w += d->spacing;
+	else
+	    h += d->spacing;
+	viewport()->setUpdatesEnabled( FALSE );
+	resizeContents( w, h );
+	viewport()->setUpdatesEnabled( TRUE );
+	viewport()->repaint( FALSE );
+    }
+
+    int cx = d->cachedContentsX == -1 ? contentsX() : d->cachedContentsX;
+    int cy = d->cachedContentsY == -1 ? contentsY() : d->cachedContentsY;
+
+    if ( cx != contentsX() || cy != contentsY() )
+	setContentsPos( cx, cy );
+
+    d->cachedContentsX = d->cachedContentsY = -1;
+    d->cachedW = d->cachedH = 0;
+}
+
+/*!
+    Takes the icon view item \a item out of the icon view and causes
+    an update of the screen display. The item is not deleted. You
+    should normally not need to call this function because
+    QIconViewItem::~QIconViewItem() calls it. The normal way to delete
+    an item is to delete it.
+*/
+
+void QIconView::takeItem( QIconViewItem *item )
+{
+    if ( !item )
+	return;
+
+    if ( item->d->container1 )
+	item->d->container1->items.removeRef( item );
+    if ( item->d->container2 )
+	item->d->container2->items.removeRef( item );
+    item->d->container2 = 0;
+    item->d->container1 = 0;
+
+    bool block = signalsBlocked();
+    blockSignals( d->clearing );
+
+    QRect r = item->rect();
+
+    if ( d->currentItem == item ) {
+	if ( item->prev ) {
+	    d->currentItem = item->prev;
+	    emit currentChanged( d->currentItem );
+	    repaintItem( d->currentItem );
+	} else if ( item->next ) {
+	    d->currentItem = item->next;
+	    emit currentChanged( d->currentItem );
+	    repaintItem( d->currentItem );
+	} else {
+	    d->currentItem = 0;
+	    emit currentChanged( d->currentItem );
+	}
+    }
+    if ( item->isSelected() ) {
+	item->selected = FALSE;
+	emit selectionChanged();
+    }
+
+    if ( item == d->firstItem ) {
+	d->firstItem = d->firstItem->next;
+	if ( d->firstItem )
+	    d->firstItem->prev = 0;
+    } else if ( item == d->lastItem ) {
+	d->lastItem = d->lastItem->prev;
+	if ( d->lastItem )
+	    d->lastItem->next = 0;
+    } else {
+	QIconViewItem *i = item;
+	if ( i ) {
+	    if ( i->prev )
+		i->prev->next = i->next;
+	    if ( i->next )
+		i->next->prev = i->prev;
+	}
+    }
+
+    if ( d->selectAnchor == item )
+	d->selectAnchor = d->currentItem;
+
+    if ( !d->clearing )
+	repaintContents( r.x(), r.y(), r.width(), r.height(), TRUE );
+
+    item->view = 0;
+    item->prev = 0;
+    item->next = 0;
+    d->count--;
+
+    blockSignals( block );
+}
+
+/*!
+    Returns the index of \a item, or -1 if \a item doesn't exist in
+    this icon view.
+*/
+
+int QIconView::index( const QIconViewItem *item ) const
+{
+    if ( !item )
+	return -1;
+
+    if ( item == d->firstItem )
+	return 0;
+    else if ( item == d->lastItem )
+	return d->count - 1;
+    else {
+	QIconViewItem *i = d->firstItem;
+	int j = 0;
+	while ( i && i != item ) {
+	    i = i->next;
+	    ++j;
+	}
+
+	return i ? j : -1;
+    }
+}
+
+/*!
+    Returns a pointer to the first item of the icon view, or 0 if
+    there are no items in the icon view.
+
+    \sa lastItem() currentItem()
+*/
+
+QIconViewItem *QIconView::firstItem() const
+{
+    return d->firstItem;
+}
+
+/*!
+    Returns a pointer to the last item of the icon view, or 0 if there
+    are no items in the icon view.
+
+    \sa firstItem() currentItem()
+*/
+
+QIconViewItem *QIconView::lastItem() const
+{
+    return d->lastItem;
+}
+
+/*!
+    Returns a pointer to the current item of the icon view, or 0 if no
+    item is current.
+
+    \sa setCurrentItem() firstItem() lastItem()
+*/
+
+QIconViewItem *QIconView::currentItem() const
+{
+    return d->currentItem;
+}
+
+/*!
+    Makes \a item the new current item of the icon view.
+*/
+
+void QIconView::setCurrentItem( QIconViewItem *item )
+{
+    if ( !item || item == d->currentItem )
+	return;
+
+    setMicroFocusHint( item->x(), item->y(), item->width(), item->height(), FALSE );
+
+    QIconViewItem *old = d->currentItem;
+    d->currentItem = item;
+    emit currentChanged( d->currentItem );
+    if ( d->selectionMode == Single ) {
+	bool changed = FALSE;
+	if ( old && old->selected ) {
+	    old->selected = FALSE;
+	    changed = TRUE;
+	}
+	if ( item && !item->selected && item->isSelectable() && d->selectionMode != NoSelection ) {
+	    item->selected = TRUE;
+	    changed = TRUE;
+	    emit selectionChanged( item );
+	}
+	if ( changed )
+	    emit selectionChanged();
+    }
+
+    if ( old )
+	repaintItem( old );
+    repaintItem( d->currentItem );
+}
+
+/*!
+    Selects or unselects \a item depending on \a s, and may also
+    unselect other items, depending on QIconView::selectionMode() and
+    \a cb.
+
+    If \a s is FALSE, \a item is unselected.
+
+    If \a s is TRUE and QIconView::selectionMode() is \c Single, \a
+    item is selected, and the item which was selected is unselected.
+
+    If \a s is TRUE and QIconView::selectionMode() is \c Extended, \a
+    item is selected. If \a cb is TRUE, the selection state of the
+    icon view's other items is left unchanged. If \a cb is FALSE (the
+    default) all other items are unselected.
+
+    If \a s is TRUE and QIconView::selectionMode() is \c Multi \a item
+    is selected.
+
+    Note that \a cb is used only if QIconView::selectionMode() is \c
+    Extended. \a cb defaults to FALSE.
+
+    All items whose selection status is changed repaint themselves.
+*/
+
+void QIconView::setSelected( QIconViewItem *item, bool s, bool cb )
+{
+    if ( !item )
+	return;
+    item->setSelected( s, cb );
+}
+
+/*!
+    \property QIconView::count
+    \brief the number of items in the icon view
+*/
+
+uint QIconView::count() const
+{
+    return d->count;
+}
+
+/*!
+    Performs autoscrolling when selecting multiple icons with the
+    rubber band.
+*/
+
+void QIconView::doAutoScroll()
+{
+    QRect oldRubber = QRect( *d->rubber );
+
+    QPoint vp = viewport()->mapFromGlobal( QCursor::pos() );
+    QPoint pos = viewportToContents( vp );
+
+    if ( pos == d->rubber->bottomRight() )
+	return;
+
+    d->rubber->setRight( pos.x() );
+    d->rubber->setBottom( pos.y() );
+
+    int minx = contentsWidth(), miny = contentsHeight();
+    int maxx = 0, maxy = 0;
+    bool changed = FALSE;
+    bool block = signalsBlocked();
+
+    QRect rr;
+    QRegion region( 0, 0, visibleWidth(), visibleHeight() );
+
+    blockSignals( TRUE );
+    viewport()->setUpdatesEnabled( FALSE );
+    bool alreadyIntersected = FALSE;
+    QRect nr = d->rubber->normalize();
+    QRect rubberUnion = nr.unite( oldRubber.normalize() );
+    QIconViewPrivate::ItemContainer *c = d->firstContainer;
+    for ( ; c; c = c->n ) {
+	if ( c->rect.intersects( rubberUnion ) ) {
+	    alreadyIntersected = TRUE;
+	    QIconViewItem *item = c->items.first();
+	    for ( ; item; item = c->items.next() ) {
+               if ( d->selectedItems.find( item ) ) {
+                   if ( item->intersects( nr ) && item->isSelected() && d->controlPressed ) {
+                       item->setSelected( FALSE );
+                       changed = TRUE;
+                       rr = rr.unite( item->rect() );
+                   } else if ( !item->intersects( nr ) && !item->isSelected() && d->controlPressed ) {
+                       item->setSelected( TRUE, TRUE );
+                       changed = TRUE;
+                       rr = rr.unite( item->rect() );
+                   } else
+                       continue;
+               } else if ( !item->intersects( nr ) ) {
+		    if ( item->isSelected() ) {
+			item->setSelected( FALSE );
+			changed = TRUE;
+			rr = rr.unite( item->rect() );
+		    }
+		} else if ( item->intersects( nr ) ) {
+		    if ( !item->isSelected() && item->isSelectable() ) {
+			item->setSelected( TRUE, TRUE );
+			changed = TRUE;
+			rr = rr.unite( item->rect() );
+		    } else {
+			region = region.subtract( QRect( contentsToViewport( item->pos() ),
+							 item->size() ) );
+		    }
+
+		    minx = QMIN( minx, item->x() - 1 );
+		    miny = QMIN( miny, item->y() - 1 );
+		    maxx = QMAX( maxx, item->x() + item->width() + 1 );
+		    maxy = QMAX( maxy, item->y() + item->height() + 1 );
+		}
+	    }
+	} else {
+	    if ( alreadyIntersected )
+		break;
+	}
+    }
+    viewport()->setUpdatesEnabled( TRUE );
+    blockSignals( block );
+
+    QRect r = *d->rubber;
+    *d->rubber = oldRubber;
+
+    QPainter p;
+    p.begin( viewport() );
+    p.setRasterOp( NotROP );
+    p.setPen( QPen( color0, 1 ) );
+    p.setBrush( NoBrush );
+    drawRubber( &p );
+    d->dragging = FALSE;
+    p.end();
+
+    *d->rubber = r;
+
+    if ( changed ) {
+	d->drawAllBack = FALSE;
+	d->clipRegion = region;
+	repaintContents( rr, FALSE );
+	d->drawAllBack = TRUE;
+    }
+
+    ensureVisible( pos.x(), pos.y() );
+
+    p.begin( viewport() );
+    p.setRasterOp( NotROP );
+    p.setPen( QPen( color0, 1 ) );
+    p.setBrush( NoBrush );
+    drawRubber( &p );
+    d->dragging = TRUE;
+
+    p.end();
+
+    if ( changed ) {
+	emit selectionChanged();
+	if ( d->selectionMode == Single )
+	    emit selectionChanged( d->currentItem );
+    }
+
+    if ( !QRect( 50, 50, viewport()->width()-100, viewport()->height()-100 ).contains( vp ) &&
+	 !d->scrollTimer ) {
+	d->scrollTimer = new QTimer( this );
+
+	connect( d->scrollTimer, SIGNAL( timeout() ),
+		 this, SLOT( doAutoScroll() ) );
+	d->scrollTimer->start( 100, FALSE );
+    } else if ( QRect( 50, 50, viewport()->width()-100, viewport()->height()-100 ).contains( vp ) &&
+		d->scrollTimer ) {
+	disconnect( d->scrollTimer, SIGNAL( timeout() ),
+		    this, SLOT( doAutoScroll() ) );
+	d->scrollTimer->stop();
+	delete d->scrollTimer;
+	d->scrollTimer = 0;
+    }
+
+}
+
+/*!
+    \reimp
+*/
+
+void QIconView::drawContents( QPainter *p, int cx, int cy, int cw, int ch )
+{
+    if ( d->dragging && d->rubber )
+	drawRubber( p );
+
+    QRect r = QRect( cx, cy, cw, ch );
+
+    QIconViewPrivate::ItemContainer *c = d->firstContainer;
+    QRegion remaining( QRect( cx, cy, cw, ch ) );
+    bool alreadyIntersected = FALSE;
+    while ( c ) {
+	if ( c->rect.intersects( r ) ) {
+	    p->save();
+	    p->resetXForm();
+	    QRect r2 = c->rect;
+	    r2 = r2.intersect( r );
+	    QRect r3( contentsToViewport( QPoint( r2.x(), r2.y() ) ), QSize( r2.width(), r2.height() ) );
+	    if ( d->drawAllBack ) {
+		p->setClipRect( r3 );
+	    } else {
+		QRegion reg = d->clipRegion.intersect( r3 );
+		p->setClipRegion( reg );
+	    }
+	    drawBackground( p, r3 );
+	    remaining = remaining.subtract( r3 );
+	    p->restore();
+
+	    QColorGroup cg;
+	    d->drawActiveSelection = hasFocus() || d->inMenuMode
+		|| !style().styleHint( QStyle::SH_ItemView_ChangeHighlightOnFocus, this );
+
+	    if ( !d->drawActiveSelection )
+		cg = palette().inactive();
+	    else
+		cg = colorGroup();
+
+	    QIconViewItem *item = c->items.first();
+	    // clip items to the container rect by default... this
+	    // prevents icons with alpha channels from being painted
+	    // twice when they are in 2 containers
+	    //
+	    // NOTE: the item could override this cliprect in it's
+	    // paintItem() implementation, which makes this useless
+	    p->setClipRect( QRect( contentsToViewport( r2.topLeft() ), r2.size() ) );
+	    for ( ; item; item = c->items.next() ) {
+		if ( item->rect().intersects( r ) && !item->dirty ) {
+		    p->save();
+		    p->setFont( font() );
+		    item->paintItem( p, cg );
+		    p->restore();
+		}
+	    }
+	    alreadyIntersected = TRUE;
+	} else {
+	    if ( alreadyIntersected )
+		break;
+	}
+	c = c->n;
+    }
+
+    if ( !remaining.isNull() && !remaining.isEmpty() ) {
+	p->save();
+	p->resetXForm();
+	if ( d->drawAllBack ) {
+	    p->setClipRegion( remaining );
+	} else {
+	    remaining = d->clipRegion.intersect( remaining );
+	    p->setClipRegion( remaining );
+	}
+	drawBackground( p, remaining.boundingRect() );
+	p->restore();
+    }
+
+    if ( ( hasFocus() || viewport()->hasFocus() ) && d->currentItem &&
+	 d->currentItem->rect().intersects( r ) ) {
+	d->currentItem->paintFocus( p, colorGroup() );
+    }
+
+    if ( d->dragging && d->rubber )
+	drawRubber( p );
+}
+
+/*!
+    \overload
+
+    Arranges all the items in the grid given by gridX() and gridY().
+
+    Even if sorting() is enabled, the items are not sorted by this
+    function. If you want to sort or rearrange the items, use
+    iconview->sort(iconview->sortDirection()).
+
+    If \a update is TRUE (the default), the viewport is repainted as
+    well.
+
+    \sa QIconView::setGridX(), QIconView::setGridY(), QIconView::sort()
+*/
+
+void QIconView::arrangeItemsInGrid( bool update )
+{
+    if ( !d->firstItem || !d->lastItem )
+	return;
+
+    d->containerUpdateLocked = TRUE;
+
+    int w = 0, h = 0, y = d->spacing;
+
+    QIconViewItem *item = d->firstItem;
+    bool changedLayout = FALSE;
+    while ( item ) {
+	bool changed;
+	QIconViewItem *next = makeRowLayout( item, y, changed );
+	changedLayout = changed || changedLayout;
+	if( !QApplication::reverseLayout() )
+	    item = next;
+	w = QMAX( w, item->x() + item->width() );
+	h = QMAX( h, item->y() + item->height() );
+	item = next;
+	if ( d->arrangement == LeftToRight )
+	    h = QMAX( h, y );
+
+	if ( !item || !item->next )
+	    break;
+
+	item = item->next;
+    }
+
+    if ( d->lastItem && d->arrangement == TopToBottom ) {
+	item = d->lastItem;
+	int x = item->x();
+	while ( item && item->x() >= x ) {
+	    w = QMAX( w, item->x() + item->width() );
+	    h = QMAX( h, item->y() + item->height() );
+	    item = item->prev;
+	}
+    }
+    d->containerUpdateLocked = FALSE;
+
+    w = QMAX( QMAX( d->cachedW, w ), d->lastItem->x() + d->lastItem->width() );
+    h = QMAX( QMAX( d->cachedH, h ), d->lastItem->y() + d->lastItem->height() );
+
+    if ( d->arrangement == TopToBottom )
+	w += d->spacing;
+    else
+	h += d->spacing;
+
+    bool ue = isUpdatesEnabled();
+    viewport()->setUpdatesEnabled( FALSE );
+    int vw = visibleWidth();
+    int vh = visibleHeight();
+    resizeContents( w, h );
+    bool doAgain = FALSE;
+    if ( d->arrangement == LeftToRight )
+	doAgain = visibleWidth() != vw;
+    if ( d->arrangement == TopToBottom )
+	doAgain = visibleHeight() != vh;
+    if ( doAgain ) // in the case that the visibleExtend changed because of the resizeContents (scrollbar show/hide), redo layout again
+	arrangeItemsInGrid( FALSE );
+    viewport()->setUpdatesEnabled( ue );
+    d->dirty = !isVisible();
+    rebuildContainers();
+    if ( update && ( !optimize_layout || changedLayout ) )
+	repaintContents( contentsX(), contentsY(), viewport()->width(), viewport()->height(), FALSE );
+}
+
+/*!
+    This variant uses \a grid instead of (gridX(), gridY()). If \a
+    grid is invalid (see QSize::isValid()), arrangeItemsInGrid()
+    calculates a valid grid itself and uses that.
+
+    If \a update is TRUE (the default) the viewport is repainted.
+*/
+
+void QIconView::arrangeItemsInGrid( const QSize &grid, bool update )
+{
+    d->containerUpdateLocked = TRUE;
+    QSize grid_( grid );
+    if ( !grid_.isValid() ) {
+	int w = 0, h = 0;
+	QIconViewItem *item = d->firstItem;
+	for ( ; item; item = item->next ) {
+	    w = QMAX( w, item->width() );
+	    h = QMAX( h, item->height() );
+	}
+
+	grid_ = QSize( QMAX( d->rastX + d->spacing, w ),
+		       QMAX( d->rastY + d->spacing, h ) );
+    }
+
+    int w = 0, h = 0;
+    QIconViewItem *item = d->firstItem;
+    for ( ; item; item = item->next ) {
+	int nx = item->x() / grid_.width();
+	int ny = item->y() / grid_.height();
+	item->move( nx * grid_.width(),
+		    ny * grid_.height() );
+	w = QMAX( w, item->x() + item->width() );
+	h = QMAX( h, item->y() + item->height() );
+	item->dirty = FALSE;
+    }
+    d->containerUpdateLocked = FALSE;
+
+    resizeContents( w, h );
+    rebuildContainers();
+    if ( update )
+	repaintContents( contentsX(), contentsY(), viewport()->width(), viewport()->height(), FALSE );
+}
+
+/*!
+    \reimp
+*/
+
+void QIconView::setContentsPos( int x, int y )
+{
+    if ( d->updateTimer->isActive() ) {
+	d->cachedContentsX = x;
+	d->cachedContentsY = y;
+    } else {
+	d->cachedContentsY = d->cachedContentsX = -1;
+	QScrollView::setContentsPos( x, y );
+    }
+}
+
+/*!
+    \reimp
+*/
+
+void QIconView::showEvent( QShowEvent * )
+{
+    if ( d->dirty ) {
+	resizeContents( QMAX( contentsWidth(), viewport()->width() ),
+			QMAX( contentsHeight(), viewport()->height() ) );
+	if ( d->resortItemsWhenInsert )
+	    sort( d->sortDirection );
+	if ( autoArrange() )
+	    arrangeItemsInGrid( FALSE );
+    }
+    QScrollView::show();
+}
+
+/*!
+    \property QIconView::selectionMode
+    \brief the selection mode of the icon view
+
+    This can be \c Single (the default), \c Extended, \c Multi or \c
+    NoSelection.
+*/
+
+void QIconView::setSelectionMode( SelectionMode m )
+{
+    d->selectionMode = m;
+}
+
+QIconView::SelectionMode QIconView::selectionMode() const
+{
+    return d->selectionMode;
+}
+
+/*!
+    Returns a pointer to the item that contains point \a pos, which is
+    given in contents coordinates, or 0 if no item contains point \a
+    pos.
+*/
+
+QIconViewItem *QIconView::findItem( const QPoint &pos ) const
+{
+    if ( !d->firstItem )
+	return 0;
+
+    QIconViewPrivate::ItemContainer *c = d->lastContainer;
+    for ( ; c; c = c->p ) {
+	if ( c->rect.contains( pos ) ) {
+	    QIconViewItem *item = c->items.last();
+	    for ( ; item; item = c->items.prev() )
+		if ( item->contains( pos ) )
+		    return item;
+	}
+    }
+
+    return 0;
+}
+
+/*!
+    \overload
+
+    Returns a pointer to the first item whose text begins with \a
+    text, or 0 if no such item could be found. Use the \a compare flag
+    to control the comparison behaviour. (See \l
+    {Qt::StringComparisonMode}.)
+*/
+
+QIconViewItem *QIconView::findItem( const QString &text, ComparisonFlags compare ) const
+{
+    if ( !d->firstItem )
+	return 0;
+
+    if ( compare == CaseSensitive || compare == 0 )
+	compare |= ExactMatch;
+
+    QString itmtxt;
+    QString comtxt = text;
+    if ( ! (compare & CaseSensitive) )
+	comtxt = text.lower();
+
+    QIconViewItem *item;
+    if ( d->currentItem )
+	item = d->currentItem;
+    else
+	item = d->firstItem;
+
+    QIconViewItem *beginsWithItem = 0;
+    QIconViewItem *endsWithItem = 0;
+    QIconViewItem *containsItem = 0;
+
+    if ( item ) {
+	for ( ; item; item = item->next ) {
+	    if ( ! (compare & CaseSensitive) )
+		itmtxt = item->text().lower();
+	    else
+		itmtxt = item->text();
+
+	    if ( compare & ExactMatch && itmtxt == comtxt )
+		return item;
+	    if ( compare & BeginsWith && !beginsWithItem && itmtxt.startsWith( comtxt ) )
+		beginsWithItem = containsItem = item;
+	    if ( compare & EndsWith && !endsWithItem && itmtxt.endsWith( comtxt ) )
+		endsWithItem = containsItem = item;
+	    if ( compare & Contains && !containsItem && itmtxt.contains( comtxt ) )
+		containsItem = item;
+	}
+
+	if ( d->currentItem && d->firstItem ) {
+	    item = d->firstItem;
+	    for ( ; item && item != d->currentItem; item = item->next ) {
+		if ( ! (compare & CaseSensitive) )
+		    itmtxt = item->text().lower();
+		else
+		    itmtxt = item->text();
+
+		if ( compare & ExactMatch && itmtxt == comtxt )
+		    return item;
+		if ( compare & BeginsWith && !beginsWithItem && itmtxt.startsWith( comtxt ) )
+		    beginsWithItem = containsItem = item;
+		if ( compare & EndsWith && !endsWithItem && itmtxt.endsWith( comtxt ) )
+		    endsWithItem = containsItem = item;
+		if ( compare & Contains && !containsItem && itmtxt.contains( comtxt ) )
+		    containsItem = item;
+	    }
+	}
+    }
+
+    // Obey the priorities
+    if ( beginsWithItem )
+	return beginsWithItem;
+    else if ( endsWithItem )
+	return endsWithItem;
+    else if ( containsItem )
+	return containsItem;
+    return 0;
+}
+
+/*!
+    Unselects all the items.
+*/
+
+void QIconView::clearSelection()
+{
+    selectAll( FALSE );
+}
+
+/*!
+    In Multi and Extended modes, this function sets all items to be
+    selected if \a select is TRUE, and to be unselected if \a select
+    is FALSE.
+
+    In Single and NoSelection modes, this function only changes the
+    selection status of currentItem().
+*/
+
+void QIconView::selectAll( bool select )
+{
+    if ( d->selectionMode == NoSelection )
+	return;
+
+    if ( d->selectionMode == Single ) {
+	if ( d->currentItem )
+	    d->currentItem->setSelected( select );
+	return;
+    }
+
+    bool b = signalsBlocked();
+    blockSignals( TRUE );
+    QIconViewItem *item = d->firstItem;
+    QIconViewItem *i = d->currentItem;
+    bool changed = FALSE;
+    bool ue = viewport()->isUpdatesEnabled();
+    viewport()->setUpdatesEnabled( FALSE );
+    QRect rr;
+    for ( ; item; item = item->next ) {
+	if ( select != item->isSelected() ) {
+ 	    item->setSelected( select, TRUE );
+	    rr = rr.unite( item->rect() );
+	    changed = TRUE;
+	}
+    }
+    viewport()->setUpdatesEnabled( ue );
+    // we call updateContents not repaintContents because of possible previous updateContents
+    QScrollView::updateContents( rr );
+    QApplication::sendPostedEvents( viewport(), QEvent::Paint );
+    if ( i )
+	setCurrentItem( i );
+    blockSignals( b );
+    if ( changed ) {
+	emit selectionChanged();
+    }
+}
+
+/*!
+    Inverts the selection. Works only in Multi and Extended selection
+    mode.
+*/
+
+void QIconView::invertSelection()
+{
+    if ( d->selectionMode == Single ||
+	 d->selectionMode == NoSelection )
+	return;
+
+    bool b = signalsBlocked();
+    blockSignals( TRUE );
+    QIconViewItem *item = d->firstItem;
+    for ( ; item; item = item->next )
+	item->setSelected( !item->isSelected(), TRUE );
+    blockSignals( b );
+    emit selectionChanged();
+}
+
+/*!
+    Repaints the \a item.
+*/
+
+void QIconView::repaintItem( QIconViewItem *item )
+{
+    if ( !item || item->dirty )
+	return;
+
+    if ( QRect( contentsX(), contentsY(), visibleWidth(), visibleHeight() ).
+	 intersects( QRect( item->x() - 1, item->y() - 1, item->width() + 2, item->height() + 2 ) ) )
+	repaintContents( item->x() - 1, item->y() - 1, item->width() + 2, item->height() + 2, FALSE );
+}
+
+/*!
+    Repaints the selected items.
+*/
+void QIconView::repaintSelectedItems()
+{
+    if ( selectionMode() == NoSelection )
+	return;
+
+    if ( selectionMode() == Single ) {
+	if ( !currentItem() || !currentItem()->isSelected() )
+	    return;
+	QRect itemRect = currentItem()->rect(); //rect in contents coordinates
+	itemRect.moveBy( -contentsX(), -contentsY() );
+	viewport()->update( itemRect );
+    } else {
+	// check if any selected items are visible
+	QIconViewItem *item = firstItem();
+	const QRect vr = QRect( contentsX(), contentsY(), visibleWidth(), visibleHeight() );
+
+	while ( item ) {
+	    if ( item->isSelected() && item->rect().intersects( vr ) )
+		repaintItem( item );
+	    item = item->nextItem();
+	}
+    }
+}
+
+/*!
+    Makes sure that \a item is entirely visible. If necessary,
+    ensureItemVisible() scrolls the icon view.
+
+    \sa ensureVisible()
+*/
+
+void QIconView::ensureItemVisible( QIconViewItem *item )
+{
+    if ( !item )
+	return;
+
+    if ( d->updateTimer && d->updateTimer->isActive() ||
+	 d->fullRedrawTimer && d->fullRedrawTimer->isActive() )
+	slotUpdate();
+
+    int w = item->width();
+    int h = item->height();
+    ensureVisible( item->x() + w / 2, item->y() + h / 2,
+		   w / 2 + 1, h / 2 + 1 );
+}
+
+/*!
+    Finds the first item whose bounding rectangle overlaps \a r and
+    returns a pointer to that item. \a r is given in content
+    coordinates. Returns 0 if no item overlaps \a r.
+
+    If you want to find all items that touch \a r, you will need to
+    use this function and nextItem() in a loop ending at
+    findLastVisibleItem() and test QIconViewItem::rect() for each of
+    these items.
+
+    \sa findLastVisibleItem() QIconViewItem::rect()
+*/
+
+QIconViewItem* QIconView::findFirstVisibleItem( const QRect &r ) const
+{
+    QIconViewPrivate::ItemContainer *c = d->firstContainer;
+    QIconViewItem *i = 0;
+    bool alreadyIntersected = FALSE;
+    for ( ; c; c = c->n ) {
+	if ( c->rect.intersects( r ) ) {
+	    alreadyIntersected = TRUE;
+	    QIconViewItem *item = c->items.first();
+	    for ( ; item; item = c->items.next() ) {
+		if ( r.intersects( item->rect() ) ) {
+		    if ( !i ) {
+			i = item;
+		    } else {
+			QRect r2 = item->rect();
+			QRect r3 = i->rect();
+			if ( r2.y() < r3.y() )
+			    i = item;
+			else if ( r2.y() == r3.y() &&
+				  r2.x() < r3.x() )
+			    i = item;
+		    }
+		}
+	    }
+	} else {
+	    if ( alreadyIntersected )
+		break;
+	}
+    }
+
+    return i;
+}
+
+/*!
+    Finds the last item whose bounding rectangle overlaps \a r and
+    returns a pointer to that item. \a r is given in content
+    coordinates. Returns 0 if no item overlaps \a r.
+
+    \sa findFirstVisibleItem()
+*/
+
+QIconViewItem* QIconView::findLastVisibleItem( const QRect &r ) const
+{
+    QIconViewPrivate::ItemContainer *c = d->firstContainer;
+    QIconViewItem *i = 0;
+    bool alreadyIntersected = FALSE;
+    for ( ; c; c = c->n ) {
+	if ( c->rect.intersects( r ) ) {
+	    alreadyIntersected = TRUE;
+	    QIconViewItem *item = c->items.first();
+	    for ( ; item; item = c->items.next() ) {
+		if ( r.intersects( item->rect() ) ) {
+		    if ( !i ) {
+			i = item;
+		    } else {
+			QRect r2 = item->rect();
+			QRect r3 = i->rect();
+			if ( r2.y() > r3.y() )
+			    i = item;
+			else if ( r2.y() == r3.y() &&
+				  r2.x() > r3.x() )
+			    i = item;
+		    }
+		}
+	    }
+	} else {
+	    if ( alreadyIntersected )
+		break;
+	}
+    }
+
+    return i;
+}
+
+/*!
+    Clears the icon view. All items are deleted.
+*/
+
+void QIconView::clear()
+{
+    setContentsPos( 0, 0 );
+    d->clearing = TRUE;
+    bool block = signalsBlocked();
+    blockSignals( TRUE );
+    clearSelection();
+    blockSignals( block );
+    setContentsPos( 0, 0 );
+    d->currentItem = 0;
+
+    if ( !d->firstItem ) {
+	d->clearing = FALSE;
+	return;
+    }
+
+    QIconViewItem *item = d->firstItem, *tmp;
+    d->firstItem = 0;
+    while ( item ) {
+	tmp = item->next;
+	delete item;
+	item = tmp;
+    }
+    QIconViewPrivate::ItemContainer *c = d->firstContainer, *tmpc;
+    while ( c ) {
+	tmpc = c->n;
+	delete c;
+	c = tmpc;
+    }
+    d->firstContainer = d->lastContainer = 0;
+
+    d->count = 0;
+    d->lastItem = 0;
+    setCurrentItem( 0 );
+    d->highlightedItem = 0;
+    d->tmpCurrentItem = 0;
+    d->drawDragShapes = FALSE;
+
+    resizeContents( 0, 0 );
+    // maybe we dont need this update, so delay it
+    d->fullRedrawTimer->start( 0, TRUE );
+
+    d->cleared = TRUE;
+    d->clearing = FALSE;
+}
+
+/*!
+    \property QIconView::gridX
+    \brief the horizontal grid  of the icon view
+
+    If the value is -1, (the default), QIconView computes suitable
+    column widths based on the icon view's contents.
+
+    Note that setting a grid width overrides setMaxItemWidth().
+*/
+
+void QIconView::setGridX( int rx )
+{
+    d->rastX = rx >= 0 ? rx : -1;
+}
+
+/*!
+    \property QIconView::gridY
+    \brief the vertical grid  of the icon view
+
+    If the value is -1, (the default), QIconView computes suitable
+    column heights based on the icon view's contents.
+*/
+
+void QIconView::setGridY( int ry )
+{
+    d->rastY = ry >= 0 ? ry : -1;
+}
+
+int QIconView::gridX() const
+{
+    return d->rastX;
+}
+
+int QIconView::gridY() const
+{
+    return d->rastY;
+}
+
+/*!
+    \property QIconView::spacing
+    \brief the space in pixels between icon view items
+
+    The default is 5 pixels.
+
+    Negative values for spacing are illegal.
+*/
+
+void QIconView::setSpacing( int sp )
+{
+    d->spacing = sp;
+}
+
+int QIconView::spacing() const
+{
+    return d->spacing;
+}
+
+/*!
+    \property QIconView::itemTextPos
+    \brief the position where the text of each item is drawn.
+
+    Valid values are \c Bottom or \c Right. The default is \c Bottom.
+*/
+
+void QIconView::setItemTextPos( ItemTextPos pos )
+{
+    if ( pos == d->itemTextPos || ( pos != Bottom && pos != Right ) )
+	return;
+
+    d->itemTextPos = pos;
+
+    QIconViewItem *item = d->firstItem;
+    for ( ; item; item = item->next ) {
+	item->wordWrapDirty = TRUE;
+	item->calcRect();
+    }
+
+    arrangeItemsInGrid( TRUE );
+}
+
+QIconView::ItemTextPos QIconView::itemTextPos() const
+{
+    return d->itemTextPos;
+}
+
+/*!
+    \property QIconView::itemTextBackground
+    \brief the brush to use when drawing the background of an item's text.
+
+    By default this brush is set to NoBrush, meaning that only the
+    normal icon view background is used.
+*/
+
+void QIconView::setItemTextBackground( const QBrush &brush )
+{
+    d->itemTextBrush = brush;
+}
+
+QBrush QIconView::itemTextBackground() const
+{
+    return d->itemTextBrush;
+}
+
+/*!
+    \property QIconView::arrangement
+    \brief the arrangement mode of the icon view
+
+    This can be \c LeftToRight or \c TopToBottom. The default is \c
+    LeftToRight.
+*/
+
+void QIconView::setArrangement( Arrangement am )
+{
+    if ( d->arrangement == am )
+	return;
+
+    d->arrangement = am;
+
+    viewport()->setUpdatesEnabled( FALSE );
+    resizeContents( viewport()->width(), viewport()->height() );
+    viewport()->setUpdatesEnabled( TRUE );
+    arrangeItemsInGrid( TRUE );
+}
+
+QIconView::Arrangement QIconView::arrangement() const
+{
+    return d->arrangement;
+}
+
+/*!
+    \property QIconView::resizeMode
+    \brief the resize mode of the icon view
+
+    This can be \c Fixed or \c Adjust. The default is \c Fixed.
+    See \l ResizeMode.
+*/
+
+void QIconView::setResizeMode( ResizeMode rm )
+{
+    if ( d->resizeMode == rm )
+	return;
+
+    d->resizeMode = rm;
+}
+
+QIconView::ResizeMode QIconView::resizeMode() const
+{
+    return d->resizeMode;
+}
+
+/*!
+    \property QIconView::maxItemWidth
+    \brief the maximum width that an item may have.
+
+    The default is 100 pixels.
+
+    Note that if the gridX() value is set QIconView will ignore
+    this property.
+*/
+
+void QIconView::setMaxItemWidth( int w )
+{
+    d->maxItemWidth = w;
+}
+
+/*!
+    \property QIconView::maxItemTextLength
+    \brief the maximum length (in characters) that an item's text may have.
+
+    The default is 255 characters.
+*/
+
+void QIconView::setMaxItemTextLength( int w )
+{
+    d->maxItemTextLength = w;
+}
+
+int QIconView::maxItemWidth() const
+{
+    if ( d->rastX != -1 )
+	return d->rastX - 2;
+    else
+	return d->maxItemWidth;
+}
+
+int QIconView::maxItemTextLength() const
+{
+    return d->maxItemTextLength;
+}
+
+/*!
+    \property QIconView::itemsMovable
+    \brief whether the user is allowed to move items around in the icon view
+
+    The default is TRUE.
+*/
+
+void QIconView::setItemsMovable( bool b )
+{
+    d->rearrangeEnabled = b;
+}
+
+bool QIconView::itemsMovable() const
+{
+    return d->rearrangeEnabled;
+}
+
+/*!
+    \property QIconView::autoArrange
+    \brief whether the icon view rearranges its items when a new item is inserted.
+
+    The default is TRUE.
+
+    Note that if the icon view is not visible at the time of
+    insertion, QIconView defers all position-related work until it is
+    shown and then calls arrangeItemsInGrid().
+*/
+
+void QIconView::setAutoArrange( bool b )
+{
+    d->reorderItemsWhenInsert = b;
+}
+
+bool QIconView::autoArrange() const
+{
+    return d->reorderItemsWhenInsert;
+}
+
+/*!
+    If \a sort is TRUE, this function sets the icon view to sort items
+    when a new item is inserted. If \a sort is FALSE, the icon view
+    will not be sorted.
+
+    Note that autoArrange() must be TRUE for sorting to take place.
+
+    If \a ascending is TRUE (the default), items are sorted in
+    ascending order. If \a ascending is FALSE, items are sorted in
+    descending order.
+
+    QIconViewItem::compare() is used to compare pairs of items. The
+    sorting is based on the items' keys; these default to the items'
+    text unless specifically set to something else.
+
+    \sa QIconView::setAutoArrange(), QIconView::autoArrange(),
+    sortDirection(), sort(), QIconViewItem::setKey()
+*/
+
+void QIconView::setSorting( bool sort, bool ascending )
+{
+    d->resortItemsWhenInsert = sort;
+    d->sortDirection = ascending;
+}
+
+/*!
+    \property QIconView::sorting
+    \brief whether the icon view sorts on insertion
+
+    The default is FALSE, i.e. no sorting on insertion.
+
+    To set the sorting, use setSorting().
+*/
+
+bool QIconView::sorting() const
+{
+    return d->resortItemsWhenInsert;
+}
+
+/*!
+    \property QIconView::sortDirection
+    \brief whether the sort direction for inserting new items is ascending;
+
+    The default is TRUE (i.e. ascending). This sort direction is only
+    meaningful if both sorting() and autoArrange() are TRUE.
+
+    To set the sort direction, use setSorting()
+*/
+
+bool QIconView::sortDirection() const
+{
+    return d->sortDirection;
+}
+
+/*!
+    \property QIconView::wordWrapIconText
+    \brief whether the item text will be word-wrapped if it is too long
+
+    The default is TRUE.
+
+    If this property is FALSE, icon text that is too long is
+    truncated, and an ellipsis (...) appended to indicate that
+    truncation has occurred. The full text can still be seen by the
+    user if they hover the mouse because the full text is shown in a
+    tooltip; see setShowToolTips().
+*/
+
+void QIconView::setWordWrapIconText( bool b )
+{
+    if ( d->wordWrapIconText == (uint)b )
+	return;
+
+    d->wordWrapIconText = b;
+    for ( QIconViewItem *item = d->firstItem; item; item = item->next ) {
+	item->wordWrapDirty = TRUE;
+	item->calcRect();
+    }
+    arrangeItemsInGrid( TRUE );
+}
+
+bool QIconView::wordWrapIconText() const
+{
+    return d->wordWrapIconText;
+}
+
+/*!
+    \property QIconView::showToolTips
+    \brief whether the icon view will display a tool tip with the complete text for any truncated item text
+
+    The default is TRUE. Note that this has no effect if
+    setWordWrapIconText() is TRUE, as it is by default.
+*/
+
+void QIconView::setShowToolTips( bool b )
+{
+    d->showTips = b;
+}
+
+bool QIconView::showToolTips() const
+{
+    return d->showTips;
+}
+
+/*!
+    \reimp
+*/
+void QIconView::contentsMousePressEvent( QMouseEvent *e )
+{
+    contentsMousePressEventEx( e );
+}
+
+void QIconView::contentsMousePressEventEx( QMouseEvent *e )
+{
+    if ( d->rubber ) {
+	QPainter p;
+	p.begin( viewport() );
+	p.setRasterOp( NotROP );
+	p.setPen( QPen( color0, 1 ) );
+	p.setBrush( NoBrush );
+
+	drawRubber( &p );
+	d->dragging = FALSE;
+	p.end();
+	delete d->rubber;
+	d->rubber = 0;
+
+	if ( d->scrollTimer ) {
+	    disconnect( d->scrollTimer, SIGNAL( timeout() ), this, SLOT( doAutoScroll() ) );
+	    d->scrollTimer->stop();
+	    delete d->scrollTimer;
+	    d->scrollTimer = 0;
+	}
+    }
+
+    d->dragStartPos = e->pos();
+    QIconViewItem *item = findItem( e->pos() );
+    d->pressedItem = item;
+
+    if ( item )
+	d->selectAnchor = item;
+
+#ifndef QT_NO_TEXTEDIT
+    if ( d->renamingItem )
+	d->renamingItem->renameItem();
+#endif
+
+    if ( !d->currentItem && !item && d->firstItem ) {
+	d->currentItem = d->firstItem;
+	repaintItem( d->firstItem );
+    }
+
+    if (item && item->dragEnabled())
+	d->startDragItem = item;
+    else
+	d->startDragItem = 0;
+
+    if ( e->button() == LeftButton && !( e->state() & ShiftButton ) &&
+	 !( e->state() & ControlButton ) && item && item->isSelected() &&
+	 item->textRect( FALSE ).contains( e->pos() ) ) {
+
+	if ( !item->renameEnabled() ) {
+	    d->mousePressed = TRUE;
+#ifndef QT_NO_TEXTEDIT
+	} else {
+	    ensureItemVisible( item );
+	    setCurrentItem( item );
+	    item->rename();
+	    goto emit_signals;
+#endif
+	}
+    }
+
+    d->pressedSelected = item && item->isSelected();
+
+    if ( item && item->isSelectable() ) {
+	if ( d->selectionMode == Single )
+	    item->setSelected( TRUE, e->state() & ControlButton );
+	else if ( d->selectionMode == Multi )
+	    item->setSelected( !item->isSelected(), e->state() & ControlButton );
+	else if ( d->selectionMode == Extended ) {
+	    if ( e->state() & ShiftButton ) {
+		d->pressedSelected = FALSE;
+		bool block = signalsBlocked();
+		blockSignals( TRUE );
+		viewport()->setUpdatesEnabled( FALSE );
+		QRect r;
+		bool select = TRUE;
+		if ( d->currentItem )
+		    r = QRect( QMIN( d->currentItem->x(), item->x() ),
+			       QMIN( d->currentItem->y(), item->y() ),
+			       0, 0 );
+		else
+		    r = QRect( 0, 0, 0, 0 );
+		if ( d->currentItem ) {
+		    if ( d->currentItem->x() < item->x() )
+			r.setWidth( item->x() - d->currentItem->x() + item->width() );
+		    else
+			r.setWidth( d->currentItem->x() - item->x() + d->currentItem->width() );
+		    if ( d->currentItem->y() < item->y() )
+			r.setHeight( item->y() - d->currentItem->y() + item->height() );
+		    else
+			r.setHeight( d->currentItem->y() - item->y() + d->currentItem->height() );
+		    r = r.normalize();
+		    QIconViewPrivate::ItemContainer *c = d->firstContainer;
+		    bool alreadyIntersected = FALSE;
+		    QRect redraw;
+		    for ( ; c; c = c->n ) {
+			if ( c->rect.intersects( r ) ) {
+			    alreadyIntersected = TRUE;
+			    QIconViewItem *i = c->items.first();
+			    for ( ; i; i = c->items.next() ) {
+				if ( r.intersects( i->rect() ) ) {
+				    redraw = redraw.unite( i->rect() );
+				    i->setSelected( select, TRUE );
+				}
+			    }
+			} else {
+			    if ( alreadyIntersected )
+				break;
+			}
+		    }
+		    redraw = redraw.unite( item->rect() );
+		    viewport()->setUpdatesEnabled( TRUE );
+		    repaintContents( redraw, FALSE );
+		}
+		blockSignals( block );
+		viewport()->setUpdatesEnabled( TRUE );
+		item->setSelected( select, TRUE );
+		emit selectionChanged();
+	    } else if ( e->state() & ControlButton ) {
+		d->pressedSelected = FALSE;
+		item->setSelected( !item->isSelected(), e->state() & ControlButton );
+	    } else {
+		item->setSelected( TRUE, e->state() & ControlButton );
+	    }
+	}
+    } else if ( ( d->selectionMode != Single || e->button() == RightButton )
+		&& !( e->state() & ControlButton ) && !( e->state() & ShiftButton ) )
+	selectAll( FALSE );
+
+    setCurrentItem( item );
+
+    if ( e->button() == LeftButton ) {
+	if ( !item && ( d->selectionMode == Multi ||
+				  d->selectionMode == Extended ) ) {
+	    d->tmpCurrentItem = d->currentItem;
+	    d->currentItem = 0;
+	    repaintItem( d->tmpCurrentItem );
+	    delete d->rubber;
+	    d->rubber = new QRect( e->x(), e->y(), 0, 0 );
+	    d->selectedItems.clear();
+	    if ( ( e->state() & ControlButton ) == ControlButton ||
+	         ( e->state() & ShiftButton ) == ShiftButton ) {
+		for ( QIconViewItem *i = firstItem(); i; i = i->nextItem() )
+		    if ( i->isSelected() )
+			d->selectedItems.insert( i, i );
+	    }
+	}
+
+	d->mousePressed = TRUE;
+	d->controlPressed = ( ( e->state() & ControlButton ) == ControlButton );
+    }
+
+ emit_signals:
+    if ( !d->rubber ) {
+	emit mouseButtonPressed( e->button(), item, e->globalPos() );
+	emit pressed( item );
+	emit pressed( item, e->globalPos() );
+
+	if ( e->button() == RightButton )
+	    emit rightButtonPressed( item, e->globalPos() );
+    }
+}
+
+/*!
+    \reimp
+*/
+
+void QIconView::contentsContextMenuEvent( QContextMenuEvent *e )
+{
+    if ( !receivers( SIGNAL(contextMenuRequested(QIconViewItem*,const QPoint&)) ) ) {
+	e->ignore();
+	return;
+    }
+    if ( e->reason() == QContextMenuEvent::Keyboard ) {
+	QIconViewItem *item = currentItem();
+	QRect r = item ? item->rect() : QRect( 0, 0, visibleWidth(), visibleHeight() );
+	emit contextMenuRequested( item, viewport()->mapToGlobal( contentsToViewport( r.center() ) ) );
+    } else {
+	d->mousePressed = FALSE;
+	QIconViewItem *item = findItem( e->pos() );
+	emit contextMenuRequested( item, e->globalPos() );
+    }
+}
+
+/*!
+    \reimp
+*/
+
+void QIconView::contentsMouseReleaseEvent( QMouseEvent *e )
+{
+    QIconViewItem *item = findItem( e->pos() );
+    d->selectedItems.clear();
+
+    bool emitClicked = TRUE;
+    d->mousePressed = FALSE;
+    d->startDragItem = 0;
+
+    if ( d->rubber ) {
+	QPainter p;
+	p.begin( viewport() );
+	p.setRasterOp( NotROP );
+	p.setPen( QPen( color0, 1 ) );
+	p.setBrush( NoBrush );
+
+	drawRubber( &p );
+	d->dragging = FALSE;
+	p.end();
+
+	if ( ( d->rubber->topLeft() - d->rubber->bottomRight() ).manhattanLength() >
+	     QApplication::startDragDistance() )
+	    emitClicked = FALSE;
+	delete d->rubber;
+	d->rubber = 0;
+	d->currentItem = d->tmpCurrentItem;
+	d->tmpCurrentItem = 0;
+	if ( d->currentItem )
+	    repaintItem( d->currentItem );
+    }
+
+    if ( d->scrollTimer ) {
+	disconnect( d->scrollTimer, SIGNAL( timeout() ), this, SLOT( doAutoScroll() ) );
+	d->scrollTimer->stop();
+	delete d->scrollTimer;
+	d->scrollTimer = 0;
+    }
+
+    if ( d->selectionMode == Extended &&
+	 d->currentItem == d->pressedItem &&
+	 d->pressedSelected && d->currentItem ) {
+	bool block = signalsBlocked();
+	blockSignals( TRUE );
+	clearSelection();
+	blockSignals( block );
+	if ( d->currentItem->isSelectable() ) {
+	    d->currentItem->selected = TRUE;
+	    repaintItem( d->currentItem );
+	}
+	emit selectionChanged();
+    }
+    d->pressedItem = 0;
+
+    if ( emitClicked ) {
+	emit mouseButtonClicked( e->button(), item, e->globalPos() );
+	emit clicked( item );
+	emit clicked( item, e->globalPos() );
+	if ( e->button() == RightButton )
+	    emit rightButtonClicked( item, e->globalPos() );
+    }
+}
+
+/*!
+    \reimp
+*/
+
+void QIconView::contentsMouseMoveEvent( QMouseEvent *e )
+{
+    QIconViewItem *item = findItem( e->pos() );
+    if ( d->highlightedItem != item ) {
+	if ( item )
+	    emit onItem( item );
+	else
+	    emit onViewport();
+	d->highlightedItem = item;
+    }
+
+    if ( d->mousePressed && e->state() == NoButton )
+	d->mousePressed = FALSE;
+
+    if ( d->startDragItem )
+	item = d->startDragItem;
+
+    if ( d->mousePressed && item && item == d->currentItem &&
+	 ( item->isSelected() || d->selectionMode == NoSelection ) && item->dragEnabled() ) {
+	if ( !d->startDragItem ) {
+	    d->currentItem->setSelected( TRUE, TRUE );
+	    d->startDragItem = item;
+	}
+	if ( ( d->dragStartPos - e->pos() ).manhattanLength() > QApplication::startDragDistance() ) {
+	    d->mousePressed = FALSE;
+	    d->cleared = FALSE;
+#ifndef QT_NO_DRAGANDDROP
+	    startDrag();
+#endif
+	    if ( d->tmpCurrentItem )
+		repaintItem( d->tmpCurrentItem );
+	}
+    } else if ( d->mousePressed && !d->currentItem && d->rubber ) {
+	doAutoScroll();
+    }
+}
+
+/*!
+    \reimp
+*/
+
+void QIconView::contentsMouseDoubleClickEvent( QMouseEvent *e )
+{
+    QIconViewItem *item = findItem( e->pos() );
+    if ( item ) {
+	selectAll( FALSE );
+	item->setSelected( TRUE, TRUE );
+	emit doubleClicked( item );
+    }
+}
+
+/*!
+    \reimp
+*/
+
+#ifndef QT_NO_DRAGANDDROP
+void QIconView::contentsDragEnterEvent( QDragEnterEvent *e )
+{
+    d->dragging = TRUE;
+    d->drawDragShapes = TRUE;
+    d->tmpCurrentItem = 0;
+    initDragEnter( e );
+    d->oldDragPos = e->pos();
+    d->oldDragAcceptAction = FALSE;
+    drawDragShapes( e->pos() );
+    d->dropped = FALSE;
+}
+
+/*!
+    \reimp
+*/
+
+void QIconView::contentsDragMoveEvent( QDragMoveEvent *e )
+{
+    if ( e->pos() == d->oldDragPos ) {
+	if (d->oldDragAcceptAction)
+	    e->acceptAction();
+	else
+	    e->ignore();
+	return;
+    }
+
+    drawDragShapes( d->oldDragPos );
+    d->dragging = FALSE;
+
+    QIconViewItem *old = d->tmpCurrentItem;
+    d->tmpCurrentItem = 0;
+
+    QIconViewItem *item = findItem( e->pos() );
+
+    if ( item ) {
+	if ( old &&
+	     old->rect().contains(d->oldDragPos) &&
+	     !old->rect().contains(e->pos()) ) {
+	    old->dragLeft();
+	    repaintItem( old );
+	}
+	if ( !item->rect().contains(d->oldDragPos) )
+	    item->dragEntered();
+	if ( item->acceptDrop( e ) ) {
+	    d->oldDragAcceptAction = TRUE;
+	    e->acceptAction();
+	} else {
+	    d->oldDragAcceptAction = FALSE;
+	    e->ignore();
+	}
+
+	d->tmpCurrentItem = item;
+	QPainter p;
+	p.begin( viewport() );
+	p.translate( -contentsX(), -contentsY() );
+	item->paintFocus( &p, colorGroup() );
+	p.end();
+    } else {
+	e->acceptAction();
+	d->oldDragAcceptAction = TRUE;
+	if ( old ) {
+	    old->dragLeft();
+	    repaintItem( old );
+	}
+    }
+
+    d->oldDragPos = e->pos();
+    drawDragShapes( e->pos() );
+    d->dragging = TRUE;
+}
+
+/*!
+    \reimp
+*/
+
+void QIconView::contentsDragLeaveEvent( QDragLeaveEvent * )
+{
+    if ( !d->dropped )
+	drawDragShapes( d->oldDragPos );
+    d->dragging = FALSE;
+
+    if ( d->tmpCurrentItem ) {
+	repaintItem( d->tmpCurrentItem );
+	d->tmpCurrentItem->dragLeft();
+    }
+
+    d->tmpCurrentItem = 0;
+    d->isIconDrag = FALSE;
+    d->iconDragData.clear();
+}
+
+/*!
+    \reimp
+*/
+
+void QIconView::contentsDropEvent( QDropEvent *e )
+{
+    d->dropped = TRUE;
+    d->dragging = FALSE;
+    drawDragShapes( d->oldDragPos );
+
+    if ( d->tmpCurrentItem )
+	repaintItem( d->tmpCurrentItem );
+
+    QIconViewItem *i = findItem( e->pos() );
+
+    if ( (!i || i == d->currentItem) && e->source() == viewport() && d->currentItem && !d->cleared ) {
+	if ( !d->rearrangeEnabled )
+	    return;
+	QRect r = d->currentItem->rect();
+
+	d->currentItem->move( e->pos() - d->dragStart );
+
+	int w = d->currentItem->x() + d->currentItem->width() + 1;
+	int h = d->currentItem->y() + d->currentItem->height() + 1;
+
+	repaintItem( d->currentItem );
+	repaintContents( r.x(), r.y(), r.width(), r.height(), FALSE );
+
+	int dx = d->currentItem->x() - r.x();
+	int dy = d->currentItem->y() - r.y();
+
+	QIconViewItem *item = d->firstItem;
+	QRect rr;
+	for ( ; item; item = item->next ) {
+	    if ( item->isSelected() && item != d->currentItem ) {
+		rr = rr.unite( item->rect() );
+		item->moveBy( dx, dy );
+		rr = rr.unite( item->rect() );
+	    }
+	    w = QMAX( w, item->x() + item->width() + 1 );
+	    h = QMAX( h, item->y() + item->height() + 1 );
+	}
+	repaintContents( rr, FALSE );
+	bool fullRepaint = FALSE;
+	if ( w > contentsWidth() ||
+	     h > contentsHeight() )
+	    fullRepaint = TRUE;
+
+	int oldw = contentsWidth();
+	int oldh = contentsHeight();
+
+	resizeContents( w, h );
+
+
+	if ( fullRepaint ) {
+	    repaintContents( oldw, 0, contentsWidth() - oldw, contentsHeight(), FALSE );
+	    repaintContents( 0, oldh, contentsWidth(), contentsHeight() - oldh, FALSE );
+	}
+	e->acceptAction();
+    } else if ( !i && ( e->source() != viewport() || d->cleared ) ) {
+	QValueList<QIconDragItem> lst;
+	if ( QIconDrag::canDecode( e ) ) {
+	    QValueList<QIconDragDataItem> l;
+	    QIconDragPrivate::decode( e, l );
+	    QValueList<QIconDragDataItem>::Iterator it = l.begin();
+	    for ( ; it != l.end(); ++it )
+		lst << ( *it ).data;
+	}
+	emit dropped( e, lst );
+    } else if ( i ) {
+	QValueList<QIconDragItem> lst;
+	if ( QIconDrag::canDecode( e ) ) {
+	    QValueList<QIconDragDataItem> l;
+	    QIconDragPrivate::decode( e, l );
+	    QValueList<QIconDragDataItem>::Iterator it = l.begin();
+	    for ( ; it != l.end(); ++it )
+		lst << ( *it ).data;
+	}
+	i->dropped( e, lst );
+    }
+    d->isIconDrag = FALSE;
+}
+#endif
+
+/*!
+    \reimp
+*/
+
+void QIconView::resizeEvent( QResizeEvent* e )
+{
+    QScrollView::resizeEvent( e );
+    if ( d->resizeMode == Adjust ) {
+	optimize_layout = TRUE;
+	adjustItems();
+	optimize_layout = FALSE;
+#if 0 // no need for timer delay anymore
+	d->oldSize = e->oldSize();
+	if ( d->adjustTimer->isActive() )
+	    d->adjustTimer->stop();
+	d->adjustTimer->start( 0, TRUE );
+#endif
+    }
+}
+
+/*!
+    Adjusts the positions of the items to the geometry of the icon
+    view.
+*/
+
+void QIconView::adjustItems()
+{
+    d->adjustTimer->stop();
+    if ( d->resizeMode == Adjust )
+	    arrangeItemsInGrid( TRUE );
+}
+
+/*!
+    \reimp
+*/
+
+void QIconView::keyPressEvent( QKeyEvent *e )
+{
+    if ( !d->firstItem )
+	return;
+
+    if ( !d->currentItem ) {
+	setCurrentItem( d->firstItem );
+	if ( d->selectionMode == Single )
+	    d->currentItem->setSelected( TRUE, TRUE );
+	return;
+    }
+
+    bool selectCurrent = TRUE;
+
+    switch ( e->key() ) {
+    case Key_Escape:
+	e->ignore();
+	break;
+#ifndef QT_NO_TEXTEDIT
+    case Key_F2: {
+	if ( d->currentItem->renameEnabled() ) {
+	    d->currentItem->renameItem();
+	    d->currentItem->rename();
+	    return;
+	}
+    } break;
+#endif
+    case Key_Home: {
+	d->currInputString = QString::null;
+	if ( !d->firstItem )
+	    break;
+
+	selectCurrent = FALSE;
+
+	QIconViewItem *item = 0;
+	QIconViewPrivate::ItemContainer *c = d->firstContainer;
+	while ( !item && c ) {
+	    QPtrList<QIconViewItem> &list = c->items;
+	    QIconViewItem *i = list.first();
+	    while ( i ) {
+		if ( !item ) {
+		    item = i;
+		} else {
+		    if ( d->arrangement == LeftToRight ) {
+			// we use pixmap so the items textlength are ignored
+			// find topmost, leftmost item
+			if ( i->pixmapRect( FALSE ).y() < item->pixmapRect( FALSE ).y() ||
+			     ( i->pixmapRect( FALSE ).y() == item->pixmapRect( FALSE ).y() &&
+			       i->pixmapRect( FALSE ).x() < item->pixmapRect( FALSE ).x() ) )
+			    item = i;
+		    } else {
+			// find leftmost, topmost item
+			if ( i->pixmapRect( FALSE ).x() < item->pixmapRect( FALSE ).x() ||
+			     ( i->pixmapRect( FALSE ).x() == item->pixmapRect( FALSE ).x() &&
+			       i->pixmapRect( FALSE ).y() < item->pixmapRect( FALSE ).y() ) )
+			    item = i;
+		    }
+		}
+		i = list.next();
+	    }
+	    c = c->n;
+	}
+
+	if ( item ) {
+	    QIconViewItem *old = d->currentItem;
+	    setCurrentItem( item );
+	    ensureItemVisible( item );
+	    handleItemChange( old, e->state() & ShiftButton,
+			      e->state() & ControlButton, TRUE );
+	}
+    } break;
+    case Key_End: {
+	d->currInputString = QString::null;
+	if ( !d->lastItem )
+	    break;
+
+	selectCurrent = FALSE;
+
+	QIconViewItem *item = 0;
+	QIconViewPrivate::ItemContainer *c = d->lastContainer;
+	while ( !item && c ) {
+	    QPtrList<QIconViewItem> &list = c->items;
+	    QIconViewItem *i = list.first();
+	    while ( i ) {
+		if ( !item ) {
+		    item = i;
+		} else {
+		    if ( d->arrangement == LeftToRight ) {
+			// find bottommost, rightmost item
+			if ( i->pixmapRect( FALSE ).bottom() > item->pixmapRect( FALSE ).bottom() ||
+			     ( i->pixmapRect( FALSE ).bottom() == item->pixmapRect( FALSE ).bottom() &&
+			       i->pixmapRect( FALSE ).right() > item->pixmapRect( FALSE ).right() ) )
+			    item = i;
+		    } else {
+			// find rightmost, bottommost item
+			if ( i->pixmapRect( FALSE ).right() > item->pixmapRect( FALSE ).right() ||
+			     ( i->pixmapRect( FALSE ).right() == item->pixmapRect( FALSE ).right() &&
+			       i->pixmapRect( FALSE ).bottom() > item->pixmapRect( FALSE ).bottom() ) )
+			    item = i;
+		    }
+		}
+		i = list.next();
+	    }
+	    c = c->p;
+	}
+
+	if ( item ) {
+	    QIconViewItem *old = d->currentItem;
+	    setCurrentItem( item );
+	    ensureItemVisible( item );
+ 	    handleItemChange( old, e->state() & ShiftButton,
+ 			      e->state() & ControlButton, TRUE );
+	}
+    } break;
+    case Key_Right: {
+	d->currInputString = QString::null;
+	QIconViewItem *item;
+	selectCurrent = FALSE;
+	Direction dir = DirRight;
+
+	QRect r( 0, d->currentItem->y(), contentsWidth(), d->currentItem->height() );
+	item = findItem( dir, d->currentItem->rect().center(), r );
+
+	// search the row below from the right
+	while ( !item && r.y() < contentsHeight() ) {
+	    r.moveBy(0, d->currentItem->height() );
+	    item = findItem( dir, QPoint( 0, r.center().y() ), r );
+	}
+
+	if ( item ) {
+	    QIconViewItem *old = d->currentItem;
+	    setCurrentItem( item );
+	    ensureItemVisible( item );
+	    handleItemChange( old, e->state() & ShiftButton, e->state() & ControlButton );
+	}
+    } break;
+    case Key_Left: {
+	d->currInputString = QString::null;
+	QIconViewItem *item;
+	selectCurrent = FALSE;
+	Direction dir = DirLeft;
+
+	QRect r( 0, d->currentItem->y(), contentsWidth(), d->currentItem->height() );
+	item = findItem( dir, d->currentItem->rect().center(), r );
+
+	// search the row above from the left
+	while ( !item && r.y() >= 0 ) {
+	    r.moveBy(0, - d->currentItem->height() );
+	    item = findItem( dir, QPoint( contentsWidth(), r.center().y() ), r );
+	}
+
+	if ( item ) {
+	    QIconViewItem *old = d->currentItem;
+	    setCurrentItem( item );
+	    ensureItemVisible( item );
+	    handleItemChange( old, e->state() & ShiftButton, e->state() & ControlButton );
+	}
+    } break;
+    case Key_Space: {
+	d->currInputString = QString::null;
+	if ( d->selectionMode == Single)
+	    break;
+
+	d->currentItem->setSelected( !d->currentItem->isSelected(), TRUE );
+    } break;
+    case Key_Enter: case Key_Return:
+	d->currInputString = QString::null;
+	emit returnPressed( d->currentItem );
+	break;
+    case Key_Down: {
+	d->currInputString = QString::null;
+	QIconViewItem *item;
+	selectCurrent = FALSE;
+	Direction dir = DirDown;
+
+	QRect r( d->currentItem->x(), 0, d->currentItem->width(), contentsHeight() );
+	item = findItem( dir, d->currentItem->rect().center(), r );
+
+	// finding the closest item below and to the right
+	while ( !item && r.x() < contentsWidth() ) {
+	    r.moveBy( r.width() , 0 );
+	    item = findItem( dir, QPoint( r.center().x(), 0 ), r );
+	}
+
+
+	QIconViewItem *i = d->currentItem;
+	setCurrentItem( item );
+	item = i;
+	handleItemChange( item, e->state() & ShiftButton, e->state() & ControlButton );
+    } break;
+    case Key_Up: {
+	d->currInputString = QString::null;
+	QIconViewItem *item;
+	selectCurrent = FALSE;
+	Direction dir = DirUp;
+
+	QRect r( d->currentItem->x(), 0, d->currentItem->width(), contentsHeight() );
+	item = findItem( dir, d->currentItem->rect().center(), r );
+
+	// finding the closest item above and to the left
+	while ( !item && r.x() >= 0 ) {
+	    r.moveBy(- r.width(), 0 );
+	    item = findItem( dir, QPoint(r.center().x(), contentsHeight() ), r );
+	}
+
+	QIconViewItem *i = d->currentItem;
+	setCurrentItem( item );
+	item = i;
+	handleItemChange( item, e->state() & ShiftButton, e->state() & ControlButton );
+    } break;
+    case Key_Next: {
+	d->currInputString = QString::null;
+	selectCurrent = FALSE;
+	QRect r;
+	if ( d->arrangement == LeftToRight )
+	    r = QRect( 0, d->currentItem->y() + visibleHeight(), contentsWidth(), visibleHeight() );
+	else
+	    r = QRect( d->currentItem->x() + visibleWidth(), 0, visibleWidth(), contentsHeight() );
+	QIconViewItem *item = d->currentItem;
+	QIconViewItem *ni = findFirstVisibleItem( r  );
+	if ( !ni ) {
+	    if ( d->arrangement == LeftToRight )
+		r = QRect( 0, d->currentItem->y() + d->currentItem->height(), contentsWidth(), contentsHeight() );
+	    else
+		r = QRect( d->currentItem->x() + d->currentItem->width(), 0, contentsWidth(), contentsHeight() );
+	    ni = findLastVisibleItem( r  );
+	}
+	if ( ni ) {
+	    setCurrentItem( ni );
+	    handleItemChange( item, e->state() & ShiftButton, e->state() & ControlButton );
+	}
+    } break;
+    case Key_Prior: {
+	d->currInputString = QString::null;
+	selectCurrent = FALSE;
+	QRect r;
+	if ( d->arrangement == LeftToRight )
+	    r = QRect( 0, d->currentItem->y() - visibleHeight(), contentsWidth(), visibleHeight() );
+	else
+	    r = QRect( d->currentItem->x() - visibleWidth(), 0, visibleWidth(), contentsHeight() );
+	QIconViewItem *item = d->currentItem;
+	QIconViewItem *ni = findFirstVisibleItem( r  );
+	if ( !ni ) {
+	    if ( d->arrangement == LeftToRight )
+		r = QRect( 0, 0, contentsWidth(), d->currentItem->y() );
+	    else
+		r = QRect( 0, 0, d->currentItem->x(), contentsHeight() );
+	    ni = findFirstVisibleItem( r  );
+	}
+	if ( ni ) {
+	    setCurrentItem( ni );
+	    handleItemChange( item, e->state() & ShiftButton, e->state() & ControlButton );
+	}
+    } break;
+    default:
+	if ( !e->text().isEmpty() && e->text()[ 0 ].isPrint() ) {
+	    selectCurrent = FALSE;
+	    QIconViewItem *i = d->currentItem;
+	    if ( !i )
+		i = d->firstItem;
+	    if ( !d->inputTimer->isActive() ) {
+		d->currInputString = e->text();
+		i = i->next;
+		if ( !i )
+		    i = d->firstItem;
+		i = findItemByName( i );
+	    } else {
+		d->inputTimer->stop();
+		d->currInputString += e->text();
+		i = findItemByName( i );
+		if ( !i ) {
+		    d->currInputString = e->text();
+		    if (d->currentItem && d->currentItem->next)
+			i = d->currentItem->next;
+		    else
+			i = d->firstItem;
+		    i = findItemByName(i);
+		}
+	    }
+	    if ( i ) {
+		setCurrentItem( i );
+		if ( d->selectionMode == Extended ) {
+		    bool changed = FALSE;
+		    bool block = signalsBlocked();
+		    blockSignals( TRUE );
+		    selectAll( FALSE );
+		    blockSignals( block );
+		    if ( !i->selected && i->isSelectable() ) {
+			changed = TRUE;
+			i->selected = TRUE;
+			repaintItem( i );
+		    }
+		    if ( changed )
+			emit selectionChanged();
+		}
+	    }
+	    d->inputTimer->start( 400, TRUE );
+	} else {
+	    selectCurrent = FALSE;
+	    d->currInputString = QString::null;
+	    if ( e->state() & ControlButton ) {
+		switch ( e->key() ) {
+		case Key_A:
+		    selectAll( TRUE );
+		    break;
+		}
+	    }
+	    e->ignore();
+	    return;
+	}
+    }
+
+    if ( !( e->state() & ShiftButton ) || !d->selectAnchor )
+	d->selectAnchor = d->currentItem;
+
+    if ( d->currentItem && !d->currentItem->isSelected() &&
+	 d->selectionMode == Single && selectCurrent ) {
+	d->currentItem->setSelected( TRUE );
+    }
+
+    ensureItemVisible( d->currentItem );
+}
+
+/*
+  Finds the closest item in the Direction \a dir relative from the point \a relativeTo
+  which intersects with the searchRect.
+
+  The function choses the closest item with its center in the searchRect.
+*/
+QIconViewItem* QIconView::findItem( Direction dir,
+				    const QPoint &relativeTo,
+				    const QRect &searchRect ) const
+{
+    QIconViewItem *item;
+    QIconViewItem *centerMatch = 0;
+    int centerMatchML = 0;
+
+    // gets list of containers with potential items
+    QPtrList<QIconViewPrivate::ItemContainer>* cList =
+	d->findContainers( dir, relativeTo, searchRect);
+
+    cList->first();
+    while ( cList->current() ) {
+	QPtrList<QIconViewItem> &list = (cList->current())->items;
+	for ( item = list.first(); item; item = list.next() ) {
+	    if ( neighbourItem( dir, relativeTo, item ) &&
+		 searchRect.intersects( item->rect() ) &&
+		 item != currentItem() ) {
+ 		int ml = (relativeTo - item->rect().center()).manhattanLength();
+		if ( centerMatch ) {
+		    if ( ml < centerMatchML ) {
+			centerMatch = item;
+			centerMatchML = ml;
+		    }
+		} else {
+		    centerMatch = item;
+		    centerMatchML = ml;
+		}
+	    }
+	}
+	cList->next();
+    }
+    return centerMatch;
+}
+
+
+/*
+  Returns TRUE if the items orientation compared to
+  the point \a relativeTo is correct.
+*/
+bool QIconView::neighbourItem( Direction dir,
+			       const QPoint &relativeTo,
+			       const QIconViewItem *item ) const
+{
+    switch ( dir ) {
+    case DirUp:
+	if ( item->rect().center().y() < relativeTo.y() )
+	    return TRUE;
+	break;
+    case DirDown:
+	if ( item->rect().center().y() > relativeTo.y() )
+	    return TRUE;
+	break;
+    case DirLeft:
+	if ( item->rect().center().x() < relativeTo.x() )
+	    return TRUE;
+	break;
+    case DirRight:
+	if ( item->rect().center().x() > relativeTo.x() )
+	    return TRUE;
+	break;
+    default:
+	// nothing
+	break;
+    }
+    return FALSE;
+}
+
+/*!
+    \reimp
+*/
+
+void QIconView::focusInEvent( QFocusEvent* )
+{
+    d->mousePressed = FALSE;
+    d->inMenuMode = FALSE;
+    if ( d->currentItem ) {
+	repaintItem( d->currentItem );
+    } else if ( d->firstItem && QFocusEvent::reason() != QFocusEvent::Mouse ) {
+	d->currentItem = d->firstItem;
+	emit currentChanged( d->currentItem );
+	repaintItem( d->currentItem );
+    }
+
+    if ( style().styleHint( QStyle::SH_ItemView_ChangeHighlightOnFocus, this ) )
+	repaintSelectedItems();
+
+    if ( d->currentItem )
+	setMicroFocusHint( d->currentItem->x(), d->currentItem->y(), d->currentItem->width(), d->currentItem->height(), FALSE );
+}
+
+/*!
+    \reimp
+*/
+
+void QIconView::focusOutEvent( QFocusEvent* )
+{
+    if (style().styleHint( QStyle::SH_ItemView_ChangeHighlightOnFocus, this )) {
+	d->inMenuMode =
+	    QFocusEvent::reason() == QFocusEvent::Popup ||
+ 	    (qApp->focusWidget() && qApp->focusWidget()->inherits("QMenuBar"));
+ 	if ( !d->inMenuMode )
+	    repaintSelectedItems();
+    }
+    if ( d->currentItem )
+	repaintItem( d->currentItem );
+}
+
+/*!
+    Draws the rubber band using the painter \a p.
+*/
+
+void QIconView::drawRubber( QPainter *p )
+{
+    if ( !p || !d->rubber )
+	return;
+
+    QPoint pnt( d->rubber->x(), d->rubber->y() );
+    pnt = contentsToViewport( pnt );
+
+    style().drawPrimitive(QStyle::PE_RubberBand, p,
+			  QRect(pnt.x(), pnt.y(), d->rubber->width(), d->rubber->height()),
+			  colorGroup(), QStyle::Style_Default, QStyleOption(colorGroup().base()));
+}
+
+/*!
+    Returns the QDragObject that should be used for drag-and-drop.
+    This function is called by the icon view when starting a drag to
+    get the dragobject that should be used for the drag. Subclasses
+    may reimplement this.
+
+    \sa QIconDrag
+*/
+
+#ifndef QT_NO_DRAGANDDROP
+QDragObject *QIconView::dragObject()
+{
+    if ( !d->currentItem )
+	return 0;
+
+    QPoint orig = d->dragStartPos;
+
+    QIconDrag *drag = new QIconDrag( viewport() );
+    drag->setPixmap( ( d->currentItem->pixmap() ?
+		     *d->currentItem->pixmap() : QPixmap() ), // ### QPicture
+		     QPoint( d->currentItem->pixmapRect().width() / 2,
+			     d->currentItem->pixmapRect().height() / 2 ) );
+
+    if ( d->selectionMode == NoSelection ) {
+	QIconViewItem *item = d->currentItem;
+	drag->append( QIconDragItem(),
+		      QRect( item->pixmapRect( FALSE ).x() - orig.x(),
+			     item->pixmapRect( FALSE ).y() - orig.y(),
+			     item->pixmapRect().width(), item->pixmapRect().height() ),
+		      QRect( item->textRect( FALSE ).x() - orig.x(),
+			     item->textRect( FALSE ).y() - orig.y(),
+			     item->textRect().width(), item->textRect().height() ) );
+    } else {
+	for ( QIconViewItem *item = d->firstItem; item; item = item->next ) {
+	    if ( item->isSelected() ) {
+		drag->append( QIconDragItem(),
+			      QRect( item->pixmapRect( FALSE ).x() - orig.x(),
+				     item->pixmapRect( FALSE ).y() - orig.y(),
+				     item->pixmapRect().width(), item->pixmapRect().height() ),
+			      QRect( item->textRect( FALSE ).x() - orig.x(),
+				     item->textRect( FALSE ).y() - orig.y(),
+				     item->textRect().width(), item->textRect().height() ) );
+	    }
+	}
+    }
+
+    return drag;
+}
+
+/*!
+    Starts a drag.
+*/
+
+void QIconView::startDrag()
+{
+    if ( !d->startDragItem )
+	return;
+
+    QPoint orig = d->dragStartPos;
+    d->dragStart = QPoint( orig.x() - d->startDragItem->x(),
+			   orig.y() - d->startDragItem->y() );
+    d->startDragItem = 0;
+    d->mousePressed = FALSE;
+    d->pressedItem = 0;
+    d->pressedSelected = 0;
+
+    QDragObject *drag = dragObject();
+    if ( !drag )
+	return;
+
+    if ( drag->drag() )
+	if ( drag->target() != viewport() )
+	    emit moved();
+}
+
+#endif
+
+/*!
+    Inserts the QIconViewItem \a item in the icon view's grid. \e{You
+    should never need to call this function.} Instead, insert
+    QIconViewItems by creating them with a pointer to the QIconView
+    that they are to be inserted into.
+*/
+
+void QIconView::insertInGrid( QIconViewItem *item )
+{
+    if ( !item )
+	return;
+
+    if ( d->reorderItemsWhenInsert ) {
+	// #### make this efficient - but it's not too dramatic
+	int y = d->spacing;
+
+	item->dirty = FALSE;
+	if ( item == d->firstItem ) {
+	    bool dummy;
+	    makeRowLayout( item, y, dummy );
+	    return;
+	}
+
+	QIconViewItem *begin = rowBegin( item );
+	y = begin->y();
+	while ( begin ) {
+	    bool dummy;
+	    begin = makeRowLayout( begin, y, dummy );
+
+	    if ( !begin || !begin->next )
+		break;
+
+	    begin = begin->next;
+	}
+	item->dirty = FALSE;
+    } else {
+	QRegion r( QRect( 0, 0, QMAX( contentsWidth(), visibleWidth() ),
+			  QMAX( contentsHeight(), visibleHeight() ) ) );
+
+	QIconViewItem *i = d->firstItem;
+	int y = -1;
+	for ( ; i; i = i->next ) {
+	    r = r.subtract( i->rect() );
+	    y = QMAX( y, i->y() + i->height() );
+	}
+
+	QMemArray<QRect> rects = r.rects();
+	QMemArray<QRect>::Iterator it = rects.begin();
+	bool foundPlace = FALSE;
+	for ( ; it != rects.end(); ++it ) {
+	    QRect rect = *it;
+	    if ( rect.width() >= item->width() &&
+		 rect.height() >= item->height() ) {
+		int sx = 0, sy = 0;
+		if ( rect.width() >= item->width() + d->spacing )
+		    sx = d->spacing;
+		if ( rect.height() >= item->height() + d->spacing )
+		    sy = d->spacing;
+		item->move( rect.x() + sx, rect.y() + sy );
+		foundPlace = TRUE;
+		break;
+	    }
+	}
+
+	if ( !foundPlace )
+	    item->move( d->spacing, y + d->spacing );
+
+	resizeContents( QMAX( contentsWidth(), item->x() + item->width() ),
+			QMAX( contentsHeight(), item->y() + item->height() ) );
+	item->dirty = FALSE;
+    }
+}
+
+/*!
+    Emits a signal to indicate selection changes. \a i is the
+    QIconViewItem that was selected or de-selected.
+
+    \e{You should never need to call this function.}
+*/
+
+void QIconView::emitSelectionChanged( QIconViewItem *i )
+{
+    emit selectionChanged();
+    if ( d->selectionMode == Single )
+	emit selectionChanged( i ? i : d->currentItem );
+}
+
+/*!
+    \internal
+*/
+
+void QIconView::emitRenamed( QIconViewItem *item )
+{
+    if ( !item )
+	return;
+
+    emit itemRenamed( item, item->text() );
+    emit itemRenamed( item );
+}
+
+/*!
+    If a drag enters the icon view the shapes of the objects which the
+    drag contains are drawn, usnig \a pos as origin.
+*/
+
+void QIconView::drawDragShapes( const QPoint &pos )
+{
+#ifndef QT_NO_DRAGANDDROP
+    if ( pos == QPoint( -1, -1 ) )
+	return;
+
+    if ( !d->drawDragShapes ) {
+	d->drawDragShapes = TRUE;
+	return;
+    }
+
+    QStyleOption opt(colorGroup().base());
+
+    QPainter p;
+    p.begin( viewport() );
+    p.translate( -contentsX(), -contentsY() );
+    p.setRasterOp( NotROP );
+    p.setPen( QPen( color0 ) );
+
+    if ( d->isIconDrag ) {
+	QValueList<QIconDragDataItem>::Iterator it = d->iconDragData.begin();
+	for ( ; it != d->iconDragData.end(); ++it ) {
+	    QRect ir = (*it).item.pixmapRect();
+	    QRect tr = (*it).item.textRect();
+	    tr.moveBy( pos.x(), pos.y() );
+	    ir.moveBy( pos.x(), pos.y() );
+	    if ( !ir.intersects( QRect( contentsX(), contentsY(), visibleWidth(), visibleHeight() ) ) )
+		continue;
+
+	    style().drawPrimitive(QStyle::PE_FocusRect, &p, ir, colorGroup(),
+				  QStyle::Style_Default, opt);
+	    style().drawPrimitive(QStyle::PE_FocusRect, &p, tr, colorGroup(),
+				  QStyle::Style_Default, opt);
+	}
+    } else if ( d->numDragItems > 0 ) {
+	for ( int i = 0; i < d->numDragItems; ++i ) {
+	    QRect r( pos.x() + i * 40, pos.y(), 35, 35 );
+	    style().drawPrimitive(QStyle::PE_FocusRect, &p, r, colorGroup(),
+				  QStyle::Style_Default, opt);
+	}
+
+    }
+    p.end();
+#endif
+}
+
+/*!
+    When a drag enters the icon view, this function is called to
+    initialize it. Initializing in this context means getting
+    information about the drag, for example so that the icon view
+    knows enough about the drag to be able to draw drag shapes for the
+    drag data (e.g. shapes of icons which are dragged), etc.
+*/
+
+#ifndef QT_NO_DRAGANDDROP
+void QIconView::initDragEnter( QDropEvent *e )
+{
+    if ( QIconDrag::canDecode( e ) ) {
+	QIconDragPrivate::decode( e, d->iconDragData );
+	d->isIconDrag = TRUE;
+    } else if ( QUriDrag::canDecode( e ) ) {
+	QStrList lst;
+	QUriDrag::decode( e, lst );
+	d->numDragItems = lst.count();
+    } else {
+	d->numDragItems = 0;
+    }
+
+}
+#endif
+
+/*!
+    This function is called to draw the rectangle \a r of the
+    background using the painter \a p.
+
+    The default implementation fills \a r with the viewport's
+    backgroundBrush(). Subclasses may reimplement this to draw custom
+    backgrounds.
+
+    \sa contentsX() contentsY() drawContents()
+*/
+
+void QIconView::drawBackground( QPainter *p, const QRect &r )
+{
+    p->fillRect( r, viewport()->backgroundBrush() );
+}
+
+/*!
+    \reimp
+*/
+
+bool QIconView::eventFilter( QObject * o, QEvent * e )
+{
+    if ( o == viewport() ) {
+	switch( e->type() ) {
+	case QEvent::FocusIn:
+	    focusInEvent( (QFocusEvent*)e );
+	    return TRUE;
+	case QEvent::FocusOut:
+	    focusOutEvent( (QFocusEvent*)e );
+	    return TRUE;
+	case QEvent::Enter:
+	    enterEvent( e );
+	    return TRUE;
+	case QEvent::Paint:
+	    if ( o == viewport() ) {
+		if ( d->dragging ) {
+		    if ( !d->rubber )
+			drawDragShapes( d->oldDragPos );
+		}
+		viewportPaintEvent( (QPaintEvent*)e );
+		if ( d->dragging ) {
+		    if ( !d->rubber )
+			drawDragShapes( d->oldDragPos );
+		}
+	    }
+	    return TRUE;
+	default:
+	    // nothing
+	    break;
+	}
+    }
+
+    return QScrollView::eventFilter( o, e );
+}
+
+
+/*!
+    \reimp
+*/
+
+QSize QIconView::minimumSizeHint() const
+{
+    return QScrollView::minimumSizeHint();
+}
+
+/*!
+  \internal
+  Finds the next item after the start item beginning
+  with \a text.
+*/
+
+QIconViewItem* QIconView::findItemByName( QIconViewItem *start )
+{
+    if ( !start )
+	return 0;
+    QString match = d->currInputString.lower();
+    if ( match.length() < 1 )
+	return start;
+    QString curText;
+    QIconViewItem *i = start;
+    do {
+	curText = i->text().lower();
+	if ( curText.startsWith( match ) )
+	    return i;
+	i = i->next;
+	if ( !i )
+	    i = d->firstItem;
+    } while ( i != start );
+    return 0;
+}
+
+/*!
+    Lays out a row of icons (if Arrangement == \c TopToBottom this is
+    a column). Starts laying out with the item \a begin. \a y is the
+    starting coordinate. Returns the last item of the row (column) and
+    sets the new starting coordinate to \a y. The \a changed parameter
+    is used internally.
+
+    \warning This function may be made private in a future version of
+    Qt. We do not recommend calling it.
+*/
+
+QIconViewItem *QIconView::makeRowLayout( QIconViewItem *begin, int &y, bool &changed )
+{
+    QIconViewItem *end = 0;
+
+    bool reverse = QApplication::reverseLayout();
+    changed = FALSE;
+
+    if ( d->arrangement == LeftToRight ) {
+
+	if ( d->rastX == -1 ) {
+	    // first calculate the row height
+	    int h = 0;
+	    int x = 0;
+	    int ih = 0;
+	    QIconViewItem *item = begin;
+	    for (;;) {
+		x += d->spacing + item->width();
+		if ( x > visibleWidth() && item != begin ) {
+		    item = item->prev;
+		    break;
+		}
+		h = QMAX( h, item->height() );
+		ih = QMAX( ih, item->pixmapRect().height() );
+		QIconViewItem *old = item;
+		item = item->next;
+		if ( !item ) {
+		    item = old;
+		    break;
+		}
+	    }
+	    end = item;
+
+	    if ( d->rastY != -1 )
+		h = QMAX( h, d->rastY );
+
+	    // now move the items
+	    item = begin;
+	    for (;;) {
+		item->dirty = FALSE;
+		int x;
+		if ( item == begin ) {
+		    if ( reverse )
+			x = visibleWidth() - d->spacing - item->width();
+		    else
+			x = d->spacing;
+		} else {
+		    if ( reverse )
+			x = item->prev->x() - item->width() - d->spacing;
+		    else
+			x = item->prev->x() + item->prev->width() + d->spacing;
+		}
+		changed = item->move( x, y + ih - item->pixmapRect().height() ) || changed;
+		if ( y + h < item->y() + item->height() )
+		    h = QMAX( h, ih + item->textRect().height() );
+		if ( item == end )
+		    break;
+		item = item->next;
+	    }
+	    y += h + d->spacing;
+	} else {
+	    // first calculate the row height
+	    int h = begin->height();
+	    int x = d->spacing;
+	    int ih = begin->pixmapRect().height();
+	    QIconViewItem *item = begin;
+	    int i = 0;
+	    int sp = 0;
+	    for (;;) {
+		int r = calcGridNum( item->width(), d->rastX );
+		if ( item == begin ) {
+		    i += r;
+		    sp += r;
+		    x = d->spacing + d->rastX * r;
+		} else {
+		    sp += r;
+		    i += r;
+		    x = i * d->rastX + sp * d->spacing;
+		}
+		if ( x > visibleWidth() && item != begin ) {
+		    item = item->prev;
+		    break;
+		}
+		h = QMAX( h, item->height() );
+		ih = QMAX( ih, item->pixmapRect().height() );
+		QIconViewItem *old = item;
+		item = item->next;
+		if ( !item ) {
+		    item = old;
+		    break;
+		}
+	    }
+	    end = item;
+
+	    if ( d->rastY != -1 )
+		h = QMAX( h, d->rastY );
+
+	    // now move the items
+	    item = begin;
+	    i = 0;
+	    sp = 0;
+	    for (;;) {
+		item->dirty = FALSE;
+		int r = calcGridNum( item->width(), d->rastX );
+		if ( item == begin ) {
+		    if ( d->itemTextPos == Bottom )
+			changed = item->move( d->spacing + ( r * d->rastX - item->width() ) / 2,
+					      y + ih - item->pixmapRect().height() ) || changed;
+		    else
+			changed = item->move( d->spacing, y + ih - item->pixmapRect().height() ) || changed;
+		    i += r;
+		    sp += r;
+		} else {
+		    sp += r;
+		    int x = i * d->rastX + sp * d->spacing;
+		    if ( d->itemTextPos == Bottom )
+			changed = item->move( x + ( r * d->rastX - item->width() ) / 2,
+					      y + ih - item->pixmapRect().height() ) || changed;
+		    else
+			changed = item->move( x, y + ih - item->pixmapRect().height() ) || changed;
+		    i += r;
+		}
+		if ( y + h < item->y() + item->height() )
+		    h = QMAX( h, ih + item->textRect().height() );
+		if ( item == end )
+		    break;
+		item = item->next;
+	    }
+	    y += h + d->spacing;
+	}
+
+
+    } else { // -------------------------------- SOUTH ------------------------------
+
+	int x = y;
+
+	{
+	    int w = 0;
+	    int y = 0;
+	    QIconViewItem *item = begin;
+	    for (;;) {
+		y += d->spacing + item->height();
+		if ( y > visibleHeight() && item != begin ) {
+		    item = item->prev;
+		    break;
+		}
+		w = QMAX( w, item->width() );
+		QIconViewItem *old = item;
+		item = item->next;
+		if ( !item ) {
+		    item = old;
+		    break;
+		}
+	    }
+	    end = item;
+
+	    if ( d->rastX != -1 )
+		w = QMAX( w, d->rastX );
+
+	    // now move the items
+	    item = begin;
+	    for (;;) {
+		item->dirty = FALSE;
+		if ( d->itemTextPos == Bottom ) {
+		    if ( item == begin )
+			changed = item->move( x + ( w - item->width() ) / 2, d->spacing )  || changed;
+		    else
+			changed = item->move( x + ( w - item->width() ) / 2,
+					      item->prev->y() + item->prev->height() + d->spacing ) || changed;
+		} else {
+		    if ( item == begin )
+			changed = item->move( x, d->spacing ) || changed;
+		    else
+			changed = item->move( x, item->prev->y() + item->prev->height() + d->spacing ) || changed;
+		}
+		if ( item == end )
+		    break;
+		item = item->next;
+	    }
+	    x += w + d->spacing;
+	}
+
+	y = x;
+    }
+
+    return end;
+}
+
+/*!
+  \internal
+  Calculates how many cells an item of width \a w needs in a grid with of
+  \a x and returns the result.
+*/
+
+int QIconView::calcGridNum( int w, int x ) const
+{
+    float r = (float)w / (float)x;
+    if ( ( w / x ) * x != w )
+	r += 1.0;
+    return (int)r;
+}
+
+/*!
+  \internal
+  Returns the first item of the row which contains \a item.
+*/
+
+QIconViewItem *QIconView::rowBegin( QIconViewItem * ) const
+{
+    // #### todo
+    return d->firstItem;
+}
+
+/*!
+    Sorts and rearranges all the items in the icon view. If \a
+    ascending is TRUE, the items are sorted in increasing order,
+    otherwise they are sorted in decreasing order.
+
+    QIconViewItem::compare() is used to compare pairs of items. The
+    sorting is based on the items' keys; these default to the items'
+    text unless specifically set to something else.
+
+    Note that this function sets the sort order to \a ascending.
+
+    \sa QIconViewItem::key(), QIconViewItem::setKey(),
+    QIconViewItem::compare(), QIconView::setSorting(),
+    QIconView::sortDirection()
+*/
+
+void QIconView::sort( bool ascending )
+{
+    if ( count() == 0 )
+	return;
+
+    d->sortDirection = ascending;
+    QIconViewPrivate::SortableItem *items = new QIconViewPrivate::SortableItem[ count() ];
+
+    QIconViewItem *item = d->firstItem;
+    int i = 0;
+    for ( ; item; item = item->next )
+	items[ i++ ].item = item;
+
+    qsort( items, count(), sizeof( QIconViewPrivate::SortableItem ), cmpIconViewItems );
+
+    QIconViewItem *prev = 0;
+    item = 0;
+    if ( ascending ) {
+	for ( i = 0; i < (int)count(); ++i ) {
+	    item = items[ i ].item;
+	    if ( item ) {
+		item->prev = prev;
+		if ( item->prev )
+		    item->prev->next = item;
+		item->next = 0;
+	    }
+	    if ( i == 0 )
+		d->firstItem = item;
+	    if ( i == (int)count() - 1 )
+		d->lastItem = item;
+	    prev = item;
+	}
+    } else {
+	for ( i = (int)count() - 1; i >= 0 ; --i ) {
+	    item = items[ i ].item;
+	    if ( item ) {
+		item->prev = prev;
+		if ( item->prev )
+		    item->prev->next = item;
+		item->next = 0;
+	    }
+	    if ( i == (int)count() - 1 )
+		d->firstItem = item;
+	    if ( i == 0 )
+		d->lastItem = item;
+	    prev = item;
+	}
+    }
+
+    delete [] items;
+
+    arrangeItemsInGrid( TRUE );
+}
+
+/*!
+    \reimp
+*/
+
+QSize QIconView::sizeHint() const
+{
+    constPolish();
+
+    if ( !d->firstItem )
+	return QScrollView::sizeHint();
+
+    if ( d->dirty && d->firstSizeHint ) {
+	( (QIconView*)this )->resizeContents( QMAX( 400, contentsWidth() ),
+					      QMAX( 400, contentsHeight() ) );
+	if ( autoArrange() )
+	    ( (QIconView*)this )->arrangeItemsInGrid( FALSE );
+	d->firstSizeHint = FALSE;
+    }
+
+    d->dirty = TRUE; // ######## warwick: I'm sure this is wrong. Fixed in 2.3.
+    int extra = style().pixelMetric(QStyle::PM_ScrollBarExtent,
+				    verticalScrollBar()) + 2*frameWidth();
+    QSize s( QMIN(400, contentsWidth() + extra),
+	     QMIN(400, contentsHeight() + extra) );
+    return s;
+}
+
+/*!
+  \internal
+*/
+
+void QIconView::updateContents()
+{
+    viewport()->update();
+}
+
+/*!
+    \reimp
+*/
+
+void QIconView::enterEvent( QEvent *e )
+{
+    QScrollView::enterEvent( e );
+    emit onViewport();
+}
+
+/*!
+  \internal
+  This function is always called when the geometry of an item changes.
+  This function moves the item into the correct area in the internal
+  data structure.
+*/
+
+void QIconView::updateItemContainer( QIconViewItem *item )
+{
+    if ( !item || d->containerUpdateLocked || (!isVisible() && autoArrange()) )
+	return;
+
+    if ( item->d->container1 && d->firstContainer ) {
+	//Special-case to check if we can use removeLast otherwise use removeRef (slower)
+	if (item->d->container1->items.last() == item)
+	    item->d->container1->items.removeLast();
+	else
+	    item->d->container1->items.removeRef( item );
+    }
+    item->d->container1 = 0;
+    if ( item->d->container2 && d->firstContainer ) {
+	//Special-case to check if we can use removeLast otherwise use removeRef (slower)
+	if (item->d->container2->items.last() == item)
+	    item->d->container2->items.removeLast();
+	else
+	    item->d->container2->items.removeRef( item );
+    }
+    item->d->container2 = 0;
+
+    QIconViewPrivate::ItemContainer *c = d->firstContainer;
+    if ( !c ) {
+	appendItemContainer();
+	c = d->firstContainer;
+    }
+
+    const QRect irect = item->rect();
+    bool contains = FALSE;
+    for (;;) {
+	if ( c->rect.intersects( irect ) ) {
+	    contains = c->rect.contains( irect );
+	    break;
+	}
+
+	c = c->n;
+	if ( !c ) {
+	    appendItemContainer();
+	    c = d->lastContainer;
+	}
+    }
+
+    if ( !c ) {
+#if defined(QT_CHECK_RANGE)
+	qWarning( "QIconViewItem::updateItemContainer(): No fitting container found!" );
+#endif
+	return;
+    }
+
+    c->items.append( item );
+    item->d->container1 = c;
+
+    if ( !contains ) {
+	c = c->n;
+	if ( !c ) {
+	    appendItemContainer();
+	    c = d->lastContainer;
+	}
+	c->items.append( item );
+	item->d->container2 = c;
+    }
+    if ( contentsWidth() < irect.right() || contentsHeight() < irect.bottom() )
+	resizeContents( QMAX( contentsWidth(), irect.right() ), QMAX( contentsHeight(), irect.bottom() ) );
+}
+
+/*!
+  \internal
+  Appends a new rect area to the internal data structure of the items.
+*/
+
+void QIconView::appendItemContainer()
+{
+    QSize s;
+    // #### We have to find out which value is best here
+    if ( d->arrangement == LeftToRight )
+	s = QSize( INT_MAX - 1, RECT_EXTENSION );
+    else
+	s = QSize( RECT_EXTENSION, INT_MAX - 1 );
+
+    if ( !d->firstContainer ) {
+	d->firstContainer = new QIconViewPrivate::ItemContainer( 0, 0, QRect( QPoint( 0, 0 ), s ) );
+	d->lastContainer = d->firstContainer;
+    } else {
+	if ( d->arrangement == LeftToRight )
+	    d->lastContainer = new QIconViewPrivate::ItemContainer(
+		d->lastContainer, 0, QRect( d->lastContainer->rect.bottomLeft(), s ) );
+	else
+	    d->lastContainer = new QIconViewPrivate::ItemContainer(
+		d->lastContainer, 0, QRect( d->lastContainer->rect.topRight(), s ) );
+    }
+}
+
+/*!  \internal
+
+  Rebuilds the whole internal data structure. This is done when it's
+  likely that most/all items change their geometry (e.g. in
+  arrangeItemsInGrid()), because calling this is then more efficient
+  than calling updateItemContainer() for each item.
+*/
+
+void QIconView::rebuildContainers()
+{
+    QIconViewPrivate::ItemContainer *c = d->firstContainer, *tmpc;
+    while ( c ) {
+	tmpc = c->n;
+	delete c;
+	c = tmpc;
+    }
+    d->firstContainer = d->lastContainer = 0;
+
+    QIconViewItem *item = d->firstItem;
+    appendItemContainer();
+    c = d->lastContainer;
+    while ( item ) {
+	if ( c->rect.contains( item->rect() ) ) {
+	    item->d->container1 = c;
+	    item->d->container2 = 0;
+	    c->items.append( item );
+	    item = item->next;
+	} else if ( c->rect.intersects( item->rect() ) && (
+			( d->arrangement == LeftToRight && item->y() >= c->rect.y() ) ||
+			( d->arrangement == TopToBottom && item->x() >= c->rect.x() ) ) ) {
+	    item->d->container1 = c;
+	    c->items.append( item );
+	    c = c->n;
+	    if ( !c ) {
+		appendItemContainer();
+		c = d->lastContainer;
+	    }
+	    c->items.append( item );
+	    item->d->container2 = c;
+	    item = item->next;
+	    c = c->p;
+	} else {
+	    if ( d->arrangement == LeftToRight ) {
+		if ( item->y() < c->rect.y() && c->p ) {
+		    c = c->p;
+		    continue;
+		}
+	    } else {
+		if ( item->x() < c->rect.x() && c->p ) {
+		    c = c->p;
+		    continue;
+		}
+	    }
+
+	    c = c->n;
+	    if ( !c ) {
+		appendItemContainer();
+		c = d->lastContainer;
+	    }
+	}
+    }
+}
+
+/*!
+  \internal
+*/
+
+void QIconView::movedContents( int, int )
+{
+    if ( d->drawDragShapes ) {
+	drawDragShapes( d->oldDragPos );
+	d->oldDragPos = QPoint( -1, -1 );
+    }
+}
+
+void QIconView::handleItemChange( QIconViewItem *old, bool shift,
+				  bool control, bool homeend )
+{
+    if ( d->selectionMode == Single ) {
+	bool block = signalsBlocked();
+	blockSignals( TRUE );
+	if ( old )
+	    old->setSelected( FALSE );
+	blockSignals( block );
+	d->currentItem->setSelected( TRUE, TRUE );
+    } else if ( d->selectionMode == Extended ) {
+	 if ( shift ) {
+	    if ( !d->selectAnchor ) {
+		if ( old && !old->selected && old->isSelectable() ) {
+		    old->selected = TRUE;
+		    repaintItem( old );
+		}
+		d->currentItem->setSelected( TRUE, TRUE );
+	    } else {
+		QIconViewItem *from = d->selectAnchor, *to = d->currentItem;
+		if ( !from || !to )
+		    return;
+
+		// checking if it's downwards and if we span rows
+		bool downwards = FALSE;
+		bool spanning = FALSE;
+		if ( d->arrangement == LeftToRight) {
+		    if ( from->rect().center().y() < to->rect().center().y() )
+			downwards = TRUE;
+		} else {
+		    if ( from->rect().center().x() < to->rect().center().x() )
+			downwards = TRUE;
+		}
+
+ 		QRect fr = from->rect();
+		QRect tr = to->rect();
+ 		if ( d->arrangement == LeftToRight ) {
+		    fr.moveTopLeft( QPoint( tr.x(), fr.y() ) );
+ 		    if ( !tr.intersects( fr ) )
+ 			spanning = TRUE;
+ 		} else {
+		    fr.moveTopLeft( QPoint( fr.x(), tr.y() ) );
+ 		    if ( !tr.intersects( fr ) )
+ 			spanning = TRUE;
+ 		}
+
+
+		// finding the rectangles
+		QRect topRect, bottomRect, midRect;
+		if ( !spanning ) {
+		    midRect = from->rect().unite( to->rect() );
+		} else {
+		    if ( downwards ) {
+			topRect = from->rect();
+			bottomRect = to->rect();
+		    } else {
+			topRect = to->rect();
+			bottomRect = from->rect();
+		    }
+		    if ( d->arrangement == LeftToRight ) {
+			topRect.setRight( contentsWidth() );
+			bottomRect.setLeft( 0 );
+			midRect.setRect( 0, topRect.bottom(),
+					 contentsWidth(),
+					 bottomRect.top() - topRect.bottom() );
+		    } else {
+			topRect.setBottom( contentsHeight() );
+			bottomRect.setTop( 0 );
+			midRect.setRect( topRect.right(),
+					 0,
+					 bottomRect.left() - topRect.right(),
+					 contentsHeight() );
+		    }
+		}
+
+		// finding contained items and selecting them
+		QIconViewItem *item = 0;
+		bool changed = FALSE;
+		bool midValid = midRect.isValid();
+		bool topValid = topRect.isValid();
+		bool bottomValid = bottomRect.isValid();
+		QRect selectedRect, unselectedRect;
+		for ( item = d->firstItem; item; item = item->next ) {
+		    bool contained = FALSE;
+		    QPoint itemCenter = item->rect().center();
+		    if ( midValid && midRect.contains( itemCenter ) )
+			contained = TRUE;
+		    if ( !contained && topValid && topRect.contains( itemCenter ) )
+			contained = TRUE;
+		    if ( !contained && bottomValid && bottomRect.contains( itemCenter ) )
+			contained = TRUE;
+
+		    if ( contained ) {
+			if ( !item->selected && item->isSelectable() ) {
+			    changed = TRUE;
+			    item->selected = TRUE;
+			    selectedRect = selectedRect.unite( item->rect() );
+			}
+		    } else if ( item->selected && !control ) {
+			item->selected = FALSE;
+			unselectedRect = unselectedRect.unite( item->rect() );
+			changed = TRUE;
+		    }
+		}
+
+		QRect viewRect( contentsX(), contentsY(),
+				visibleWidth(), visibleHeight() );
+
+   		if ( viewRect.intersects( selectedRect ) ) {
+		    if ( homeend )
+			QScrollView::updateContents( viewRect.intersect( selectedRect ) );
+		    else
+			repaintContents( viewRect.intersect( selectedRect ) );
+		}
+		if ( viewRect.intersects( unselectedRect ) ) {
+		    if ( homeend )
+			QScrollView::updateContents( viewRect.intersect( unselectedRect ) );
+		    else
+			repaintContents( viewRect.intersect( unselectedRect ) );
+		}
+
+		if ( changed )
+		    emit selectionChanged();
+	    }
+	} else if ( !control ) {
+	    blockSignals( TRUE );
+	    selectAll( FALSE );
+	    blockSignals( FALSE );
+	    d->currentItem->setSelected( TRUE, TRUE );
+	}
+    } else {
+	if ( shift )
+	    d->currentItem->setSelected( !d->currentItem->isSelected(), TRUE );
+    }
+}
+
+QBitmap QIconView::mask( QPixmap *pix ) const
+{
+    QBitmap m;
+    if ( d->maskCache.find( QString::number( pix->serialNumber() ), m ) )
+	return m;
+    m = pix->createHeuristicMask();
+    d->maskCache.insert( QString::number( pix->serialNumber() ), m );
+    return m;
+}
+
+/*!
+    \reimp
+    \internal
+
+    (Implemented to get rid of a compiler warning.)
+*/
+void QIconView::drawContents( QPainter * )
+{
+}
+
+/*!
+    \reimp
+*/
+void QIconView::windowActivationChange( bool oldActive )
+{
+    if ( oldActive && d->scrollTimer )
+	d->scrollTimer->stop();
+
+    if ( !isVisible() )
+	return;
+
+    if ( palette().active() == palette().inactive() )
+	return;
+
+    repaintSelectedItems();
+}
+
+/*!
+    Returns TRUE if an iconview item is being renamed; otherwise
+    returns FALSE.
+*/
+
+bool QIconView::isRenaming() const
+{
+#ifndef QT_NO_TEXTEDIT
+    return d->renamingItem && d->renamingItem->renameBox;
+#else
+    return FALSE;
+#endif
+}
+
+#endif // QT_NO_ICONVIEW
diff -Nru qt-x11-free-3.3.3.orig/src/iconview/qiconview.h qt-x11-free-3.3.3/src/iconview/qiconview.h
--- qt-x11-free-3.3.3.orig/src/iconview/qiconview.h	2004-08-22 13:20:57.132011168 +0200
+++ qt-x11-free-3.3.3/src/iconview/qiconview.h	2004-08-22 13:23:59.931444409 +0200
@@ -496,6 +496,8 @@
 			const QPoint &relativeTo,
 			const QIconViewItem *item ) const;
     QBitmap mask( QPixmap *pix ) const;
+    int visibleWidthSB() const;
+    int visibleHeightSB() const;
 
     QIconViewPrivate *d;
 
diff -Nru qt-x11-free-3.3.3.orig/src/kernel/qapplication_x11.cpp qt-x11-free-3.3.3/src/kernel/qapplication_x11.cpp
--- qt-x11-free-3.3.3.orig/src/kernel/qapplication_x11.cpp	2004-08-22 13:20:57.187000757 +0200
+++ qt-x11-free-3.3.3/src/kernel/qapplication_x11.cpp	2004-08-22 13:23:19.709043244 +0200
@@ -3402,10 +3402,23 @@
 
 	// update the size for desktop widget
 	int scr = XRRRootToScreen( appDpy, event->xany.window );
+
+	// Determine if we're at right-angles & thus DisplayWidth/DisplayHeight should be switched
+	XRRScreenConfiguration* xrrconfig;
+	xrrconfig = XRRGetScreenInfo( appDpy, event->xany.window );
+	Rotation rotation;
+	XRRConfigCurrentConfiguration( xrrconfig, &rotation );
+	XRRFreeScreenConfigInfo( xrrconfig );
+
 	QWidget *w = desktop()->screen( scr );
 	QSize oldSize( w->size() );
-	w->crect.setWidth( DisplayWidth( appDpy, scr ) );
-        w->crect.setHeight( DisplayHeight( appDpy, scr ) );
+	if (rotation & (RR_Rotate_90 | RR_Rotate_270)) {
+	    w->crect.setWidth( DisplayHeight( appDpy, scr ) );
+	    w->crect.setHeight( DisplayWidth( appDpy, scr ) );
+	} else {
+	    w->crect.setWidth( DisplayWidth( appDpy, scr ) );
+	    w->crect.setHeight( DisplayHeight( appDpy, scr ) );
+	}
 	if ( w->size() != oldSize ) {
 	    QResizeEvent e( w->size(), oldSize );
 	    QApplication::sendEvent( w, &e );
@@ -3964,7 +3977,7 @@
 // Keyboard event translation
 //
 
-static int translateButtonState( int s )
+int qt_x11_translateButtonState( int s )
 {
     int bst = 0;
     if ( s & Button1Mask )
@@ -4030,7 +4043,7 @@
 	pos.ry() = lastMotion.y;
 	globalPos.rx() = lastMotion.x_root;
 	globalPos.ry() = lastMotion.y_root;
-	state = translateButtonState( lastMotion.state );
+	state = qt_x11_translateButtonState( lastMotion.state );
 	if ( qt_button_down && (state & (LeftButton |
 					 MidButton |
 					 RightButton ) ) == 0 )
@@ -4054,7 +4067,7 @@
 	pos.ry() = xevent->xcrossing.y;
 	globalPos.rx() = xevent->xcrossing.x_root;
 	globalPos.ry() = xevent->xcrossing.y_root;
-	state = translateButtonState( xevent->xcrossing.state );
+	state = qt_x11_translateButtonState( xevent->xcrossing.state );
 	if ( qt_button_down && (state & (LeftButton |
 					 MidButton |
 					 RightButton ) ) == 0 )
@@ -4066,7 +4079,7 @@
 	pos.ry() = event->xbutton.y;
 	globalPos.rx() = event->xbutton.x_root;
 	globalPos.ry() = event->xbutton.y_root;
-	state = translateButtonState( event->xbutton.state );
+	state = qt_x11_translateButtonState( event->xbutton.state );
 	switch ( event->xbutton.button ) {
 	case Button1: button = LeftButton; break;
 	case Button2: button = MidButton; break;
@@ -5004,7 +5017,7 @@
     XKeyEvent xkeyevent = event->xkey;
 
     // save the modifier state, we will use the keystate uint later by passing
-    // it to translateButtonState
+    // it to qt_x11_translateButtonState
     uint keystate = event->xkey.state;
     // remove the modifiers where mode_switch exists... HPUX machines seem
     // to have alt *AND* mode_switch both in Mod1Mask, which causes
@@ -5118,7 +5131,7 @@
     }
 #endif // !QT_NO_XIM
 
-    state = translateButtonState( keystate );
+    state = qt_x11_translateButtonState( keystate );
 
     static int directionKeyEvent = 0;
     if ( qt_use_rtl_extensions && type == QEvent::KeyRelease ) {
diff -Nru qt-x11-free-3.3.3.orig/src/kernel/qapplication_x11.cpp~ qt-x11-free-3.3.3/src/kernel/qapplication_x11.cpp~
--- qt-x11-free-3.3.3.orig/src/kernel/qapplication_x11.cpp~	1970-01-01 01:00:00.000000000 +0100
+++ qt-x11-free-3.3.3/src/kernel/qapplication_x11.cpp~	2004-08-22 13:22:29.654504987 +0200
@@ -0,0 +1,6430 @@
+/****************************************************************************
+** $Id: qt/qapplication_x11.cpp   3.3.3   edited Jul 28 14:04 $
+**
+** Implementation of X11 startup routines and event handling
+**
+** Created : 931029
+**
+** Copyright (C) 1992-2003 Trolltech AS.  All rights reserved.
+**
+** This file is part of the kernel module of the Qt GUI Toolkit.
+**
+** This file may be distributed under the terms of the Q Public License
+** as defined by Trolltech AS of Norway and appearing in the file
+** LICENSE.QPL included in the packaging of this file.
+**
+** This file may be distributed and/or modified under the terms of the
+** GNU General Public License version 2 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.
+**
+** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
+** licenses for Unix/X11 may use this file in accordance with the Qt Commercial
+** License Agreement provided with the Software.
+**
+** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+**
+** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
+**   information about Qt Commercial License Agreements.
+** See http://www.trolltech.com/qpl/ for QPL licensing information.
+** See http://www.trolltech.com/gpl/ for GPL licensing information.
+**
+** Contact info@trolltech.com if any conditions of this licensing are
+** not clear to you.
+**
+**********************************************************************/
+
+// ### 4.0: examine Q_EXPORT's below. The respective symbols had all
+// been in use (e.g. in the KDE wm ) before the introduction of a version
+// map. One might want to turn some of them into propert public API and
+// provide a proper alternative for others. See also the exports in
+// qapplication_win.cpp which suggest a unification.
+
+// ### needed for solaris-g++ in beta5
+#define QT_CLEAN_NAMESPACE
+
+#include "qplatformdefs.h"
+
+// POSIX Large File Support redefines open -> open64
+#if defined(open)
+# undef open
+#endif
+
+// Solaris redefines connect -> __xnet_connect with _XOPEN_SOURCE_EXTENDED.
+#if defined(connect)
+# undef connect
+#endif
+
+// POSIX Large File Support redefines truncate -> truncate64
+#if defined(truncate)
+# undef truncate
+#endif
+
+#include "qapplication.h"
+#include "qapplication_p.h"
+#include "qcolor_p.h"
+#include "qcursor.h"
+#include "qwidget.h"
+#include "qwidget_p.h"
+#include "qobjectlist.h"
+#include "qwidgetlist.h"
+#include "qwidgetintdict.h"
+#include "qbitarray.h"
+#include "qpainter.h"
+#include "qpixmapcache.h"
+#include "qdatetime.h"
+#include "qtextcodec.h"
+#include "qdatastream.h"
+#include "qbuffer.h"
+#include "qsocketnotifier.h"
+#include "qsessionmanager.h"
+#include "qvaluelist.h"
+#include "qdict.h"
+#include "qguardedptr.h"
+#include "qclipboard.h"
+#include "qwhatsthis.h" // ######## dependency
+#include "qsettings.h"
+#include "qstylefactory.h"
+#include "qfileinfo.h"
+
+// Input method stuff - UNFINISHED
+#include "qinputcontext_p.h"
+#include "qinternal_p.h" // shared double buffer cleanup
+
+#if defined(QT_THREAD_SUPPORT)
+# include "qthread.h"
+#endif
+
+#if defined(QT_DEBUG) && defined(Q_OS_LINUX)
+# include "qfile.h"
+#endif
+
+#include "qt_x11_p.h"
+
+#if !defined(QT_NO_XFTFREETYPE)
+// XFree86 4.0.3 implementation is missing XftInitFtLibrary forward
+extern "C" Bool XftInitFtLibrary(void);
+#endif
+
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <locale.h>
+
+//#define X_NOT_BROKEN
+#ifdef X_NOT_BROKEN
+// Some X libraries are built with setlocale #defined to _Xsetlocale,
+// even though library users are then built WITHOUT such a definition.
+// This creates a problem - Qt might setlocale() one value, but then
+// X looks and doesn't see the value Qt set. The solution here is to
+// implement _Xsetlocale just in case X calls it - redirecting it to
+// the real libC version.
+//
+# ifndef setlocale
+extern "C" char *_Xsetlocale(int category, const char *locale);
+char *_Xsetlocale(int category, const char *locale)
+{
+    //qDebug("_Xsetlocale(%d,%s),category,locale");
+    return setlocale(category,locale);
+}
+# endif // setlocale
+#endif // X_NOT_BROKEN
+
+
+// resolve the conflict between X11's FocusIn and QEvent::FocusIn
+const int XFocusOut = FocusOut;
+const int XFocusIn = FocusIn;
+#undef FocusOut
+#undef FocusIn
+
+const int XKeyPress = KeyPress;
+const int XKeyRelease = KeyRelease;
+#undef KeyPress
+#undef KeyRelease
+
+
+// Fix old X libraries
+#ifndef XK_KP_Home
+#define XK_KP_Home              0xFF95
+#endif
+#ifndef XK_KP_Left
+#define XK_KP_Left              0xFF96
+#endif
+#ifndef XK_KP_Up
+#define XK_KP_Up                0xFF97
+#endif
+#ifndef XK_KP_Right
+#define XK_KP_Right             0xFF98
+#endif
+#ifndef XK_KP_Down
+#define XK_KP_Down              0xFF99
+#endif
+#ifndef XK_KP_Prior
+#define XK_KP_Prior             0xFF9A
+#endif
+#ifndef XK_KP_Next
+#define XK_KP_Next              0xFF9B
+#endif
+#ifndef XK_KP_End
+#define XK_KP_End               0xFF9C
+#endif
+#ifndef XK_KP_Insert
+#define XK_KP_Insert            0xFF9E
+#endif
+#ifndef XK_KP_Delete
+#define XK_KP_Delete            0xFF9F
+#endif
+
+
+/*****************************************************************************
+  Internal variables and functions
+ *****************************************************************************/
+static const char *appName;			// application name
+static const char *appClass;			// application class
+static const char *appFont	= 0;		// application font
+static const char *appBGCol	= 0;		// application bg color
+static const char *appFGCol	= 0;		// application fg color
+static const char *appBTNCol	= 0;		// application btn color
+static const char *mwGeometry	= 0;		// main widget geometry
+static const char *mwTitle	= 0;		// main widget title
+//Ming-Che 10/10
+static char    *ximServer	= 0;		// XIM Server will connect to
+static bool	mwIconic	= FALSE;	// main widget iconified
+//Ming-Che 10/10
+static bool	noxim		= FALSE;	// connect to xim or not
+static Display *appDpy		= 0;		// X11 application display
+static char    *appDpyName	= 0;		// X11 display name
+static bool	appForeignDpy	= FALSE;        // we didn't create display
+static bool	appSync		= FALSE;	// X11 synchronization
+#if defined(QT_DEBUG)
+static bool	appNoGrab	= FALSE;	// X11 grabbing enabled
+static bool	appDoGrab	= FALSE;	// X11 grabbing override (gdb)
+#endif
+static int	appScreen;			// X11 screen number
+static int	appScreenCount;			// X11 screen count
+static bool	app_save_rootinfo = FALSE;	// save root info
+static bool	app_do_modal	= FALSE;	// modal mode
+static Window	curWin = 0;			// current window
+
+static GC*	app_gc_ro	= 0;		// read-only GC
+static GC*	app_gc_tmp	= 0;		// temporary GC
+static GC*	app_gc_ro_m	= 0;		// read-only GC (monochrome)
+static GC*	app_gc_tmp_m	= 0;		// temporary GC (monochrome)
+// symbols needed by extern QXEmbed class
+Q_EXPORT Atom	qt_wm_protocols		= 0;	// window manager protocols
+Q_EXPORT Atom	qt_wm_delete_window	= 0;	// delete window protocol
+Q_EXPORT Atom	qt_wm_take_focus	= 0;	// take focus window protocol
+
+Atom		qt_qt_scrolldone	= 0;	// scroll synchronization
+Atom		qt_net_wm_context_help	= 0;	// context help
+Atom		qt_net_wm_ping		= 0;	// _NET_WM_PING protocol
+
+static Atom	qt_xsetroot_id		= 0;
+Atom            qt_xa_clipboard         = 0;
+Atom		qt_selection_property	= 0;
+Atom            qt_clipboard_sentinel   = 0;
+Atom		qt_selection_sentinel	= 0;
+Q_EXPORT Atom	qt_wm_state		= 0;
+Atom		qt_wm_change_state	= 0;
+static Atom     qt_settings_timestamp	= 0;    // Qt >=3 settings timestamp
+static Atom	qt_input_encoding	= 0;	// Qt desktop properties
+static Atom	qt_resource_manager	= 0;	// X11 Resource manager
+Atom		qt_sizegrip		= 0;	// sizegrip
+Atom		qt_wm_client_leader	= 0;
+Q_EXPORT Atom	qt_window_role		= 0;
+Q_EXPORT Atom	qt_sm_client_id		= 0;
+Atom		qt_xa_motif_wm_hints	= 0;
+Atom		qt_cde_running		= 0;
+Atom		qt_kwin_running	= 0;
+Atom		qt_kwm_running	= 0;
+Atom		qt_gbackground_properties	= 0;
+Atom		qt_x_incr		= 0;
+Atom		qt_utf8_string = 0;
+
+// detect broken window managers
+Atom            qt_sgi_desks_manager    = 0;
+bool		qt_broken_wm		= FALSE;
+static void qt_detect_broken_window_manager();
+
+// NET WM support
+Atom		qt_net_supported	= 0;
+Atom		qt_net_wm_name		= 0;
+Atom		qt_net_wm_icon_name	= 0;
+Atom		qt_net_virtual_roots	= 0;
+Atom		qt_net_workarea		= 0;
+Atom		qt_net_wm_state		= 0;
+Atom		qt_net_wm_state_modal	= 0;
+Atom		qt_net_wm_state_max_v	= 0;
+Atom		qt_net_wm_state_max_h	= 0;
+Atom		qt_net_wm_state_fullscreen = 0;
+Atom		qt_net_wm_state_above	= 0;
+Atom            qt_net_wm_window_type   = 0;
+Atom            qt_net_wm_window_type_normal	= 0;
+Atom            qt_net_wm_window_type_dialog	= 0;
+Atom            qt_net_wm_window_type_toolbar	= 0;
+Atom		qt_net_wm_window_type_menu	= 0;
+Atom		qt_net_wm_window_type_utility	= 0;
+Atom            qt_net_wm_window_type_splash    = 0;
+Atom            qt_net_wm_window_type_override	= 0;	// KDE extension
+Atom		qt_net_wm_frame_strut		= 0;	// KDE extension
+Atom		qt_net_wm_state_stays_on_top	= 0;	// KDE extension
+Atom		qt_net_wm_pid		= 0;
+Atom		qt_net_wm_user_time	= 0;
+// Enlightenment support
+Atom		qt_enlightenment_desktop	= 0;
+
+// window managers list of supported "stuff"
+Atom		*qt_net_supported_list	= 0;
+// list of virtual root windows
+Window		*qt_net_virtual_root_list	= 0;
+
+
+
+// client leader window
+Window qt_x11_wm_client_leader = 0;
+
+// function to update the workarea of the screen - in qdesktopwidget_x11.cpp
+extern void qt_desktopwidget_update_workarea();
+
+// current focus model
+static const int FocusModel_Unknown = -1;
+static const int FocusModel_Other = 0;
+static const int FocusModel_PointerRoot = 1;
+static int qt_focus_model = -1;
+
+#ifndef QT_NO_XRANDR
+// TRUE if Qt is compiled w/ XRandR support and XRandR exists on the connected
+// Display
+bool	qt_use_xrandr	= FALSE;
+static int xrandr_eventbase;
+#endif
+
+// TRUE if Qt is compiled w/ XRender support and XRender exists on the connected
+// Display
+Q_EXPORT bool qt_use_xrender = FALSE;
+
+// modifier masks for alt/meta - detected when the application starts
+static long qt_alt_mask = 0;
+static long qt_meta_mask = 0;
+// modifier mask to remove mode switch from modifiers that have alt/meta set
+// this problem manifests itself on HP/UX 10.20 at least, and without it
+// modifiers do not work at all...
+static long qt_mode_switch_remove_mask = 0;
+
+// flags for extensions for special Languages, currently only for RTL languages
+static bool 	qt_use_rtl_extensions = FALSE;
+bool qt_hebrew_keyboard_hack = FALSE;
+
+static Window	mouseActWindow	     = 0;	// window where mouse is
+static int	mouseButtonPressed   = 0;	// last mouse button pressed
+static int	mouseButtonState     = 0;	// mouse button state
+static Time	mouseButtonPressTime = 0;	// when was a button pressed
+static short	mouseXPos, mouseYPos;		// mouse pres position in act window
+static short	mouseGlobalXPos, mouseGlobalYPos; // global mouse press position
+
+extern QWidgetList *qt_modal_stack;		// stack of modal widgets
+static bool	    ignoreNextMouseReleaseEvent = FALSE; // ignore the next mouse release
+							 // event if return from a modal
+							 // widget
+
+static QWidget     *popupButtonFocus = 0;
+static QWidget     *popupOfPopupButtonFocus = 0;
+static bool	    popupCloseDownMode = FALSE;
+static bool	    popupGrabOk;
+
+static bool sm_blockUserInput = FALSE;		// session management
+
+int qt_xfocusout_grab_counter = 0;
+
+#if defined (QT_TABLET_SUPPORT)
+// since XInput event classes aren't created until we actually open an XInput
+// device, here is a static list that we will use later on...
+const int INVALID_EVENT = -1;
+const int TOTAL_XINPUT_EVENTS = 7;
+
+XDevice *devStylus = NULL;
+XDevice *devEraser = NULL;
+XEventClass event_list_stylus[TOTAL_XINPUT_EVENTS];
+XEventClass event_list_eraser[TOTAL_XINPUT_EVENTS];
+
+int qt_curr_events_stylus = 0;
+int qt_curr_events_eraser = 0;
+
+// well, luckily we only need to do this once.
+static int xinput_motion = INVALID_EVENT;
+static int xinput_key_press = INVALID_EVENT;
+static int xinput_key_release = INVALID_EVENT;
+static int xinput_button_press = INVALID_EVENT;
+static int xinput_button_release = INVALID_EVENT;
+
+// making this assumption on XFree86, since we can only use 1 device,
+// the pressure for the eraser and the stylus should be the same, if they aren't
+// well, they certainly have a strange pen then...
+static int max_pressure;
+extern bool chokeMouse;
+#endif
+
+// last timestamp read from QSettings
+static uint appliedstamp = 0;
+
+
+typedef int (*QX11EventFilter) (XEvent*);
+QX11EventFilter qt_set_x11_event_filter(QX11EventFilter filter);
+
+static QX11EventFilter qt_x11_event_filter = 0;
+Q_EXPORT QX11EventFilter qt_set_x11_event_filter(QX11EventFilter filter)
+{
+    QX11EventFilter old_filter = qt_x11_event_filter;
+    qt_x11_event_filter = filter;
+    return old_filter;
+}
+static bool qt_x11EventFilter( XEvent* ev )
+{
+    if ( qt_x11_event_filter  && qt_x11_event_filter( ev )  )
+	return TRUE;
+    return qApp->x11EventFilter( ev );
+}
+
+
+
+
+
+#if !defined(QT_NO_XIM)
+XIM		qt_xim			= 0;
+XIMStyle	qt_xim_style		= 0;
+static XIMStyle xim_default_style	= XIMPreeditCallbacks | XIMStatusNothing;
+static XIMStyle	xim_preferred_style	= 0;
+#endif
+
+static int composingKeycode=0;
+static QTextCodec * input_mapper = 0;
+
+Q_EXPORT Time	qt_x_time = CurrentTime;
+Q_EXPORT Time	qt_x_user_time = CurrentTime;
+extern bool     qt_check_clipboard_sentinel(); //def in qclipboard_x11.cpp
+extern bool	qt_check_selection_sentinel(); //def in qclipboard_x11.cpp
+
+static void	qt_save_rootinfo();
+bool	qt_try_modal( QWidget *, XEvent * );
+
+int		qt_ncols_option  = 216;		// used in qcolor_x11.cpp
+int		qt_visual_option = -1;
+bool		qt_cmap_option	 = FALSE;
+QWidget	       *qt_button_down	 = 0;		// widget got last button-down
+
+extern bool qt_tryAccelEvent( QWidget*, QKeyEvent* ); // def in qaccel.cpp
+
+struct QScrollInProgress {
+    static long serial;
+    QScrollInProgress( QWidget* w, int x, int y ) :
+    id( serial++ ), scrolled_widget( w ), dx( x ), dy( y ) {}
+    long id;
+    QWidget* scrolled_widget;
+    int dx, dy;
+};
+long QScrollInProgress::serial=0;
+static QPtrList<QScrollInProgress> *sip_list = 0;
+
+
+// stuff in qt_xdnd.cpp
+// setup
+extern void qt_xdnd_setup();
+// x event handling
+extern void qt_handle_xdnd_enter( QWidget *, const XEvent *, bool );
+extern void qt_handle_xdnd_position( QWidget *, const XEvent *, bool );
+extern void qt_handle_xdnd_status( QWidget *, const XEvent *, bool );
+extern void qt_handle_xdnd_leave( QWidget *, const XEvent *, bool );
+extern void qt_handle_xdnd_drop( QWidget *, const XEvent *, bool );
+extern void qt_handle_xdnd_finished( QWidget *, const XEvent *, bool );
+extern void qt_xdnd_handle_selection_request( const XSelectionRequestEvent * );
+extern bool qt_xdnd_handle_badwindow();
+
+extern void qt_motifdnd_handle_msg( QWidget *, const XEvent *, bool );
+extern void qt_x11_motifdnd_init();
+
+// client message atoms
+extern Atom qt_xdnd_enter;
+extern Atom qt_xdnd_position;
+extern Atom qt_xdnd_status;
+extern Atom qt_xdnd_leave;
+extern Atom qt_xdnd_drop;
+extern Atom qt_xdnd_finished;
+// xdnd selection atom
+extern Atom qt_xdnd_selection;
+extern bool qt_xdnd_dragging;
+
+// gui or non-gui from qapplication.cpp
+extern bool qt_is_gui_used;
+
+extern bool qt_resolve_symlinks; // from qapplication.cpp
+
+// Paint event clipping magic
+extern void qt_set_paintevent_clipping( QPaintDevice* dev, const QRegion& region);
+extern void qt_clear_paintevent_clipping();
+
+
+// Palette handling
+extern QPalette *qt_std_pal;
+extern void qt_create_std_palette();
+
+void qt_x11_intern_atom( const char *, Atom * );
+
+static QPtrList<QWidget>* deferred_map_list = 0;
+static void qt_deferred_map_cleanup()
+{
+    delete deferred_map_list;
+    deferred_map_list = 0;
+}
+void qt_deferred_map_add( QWidget* w)
+{
+    if ( !deferred_map_list ) {
+	deferred_map_list = new QPtrList<QWidget>;
+	qAddPostRoutine( qt_deferred_map_cleanup );
+    }
+    deferred_map_list->append( w );
+}
+void qt_deferred_map_take( QWidget* w )
+{
+    if (deferred_map_list ) {
+	deferred_map_list->remove( w );
+    }
+}
+bool qt_deferred_map_contains( QWidget* w )
+{
+    if (!deferred_map_list)
+	return FALSE;
+    else
+	return deferred_map_list->contains( w );
+}
+
+
+class QETWidget : public QWidget		// event translator widget
+{
+public:
+    void setWState( WFlags f )		{ QWidget::setWState(f); }
+    void clearWState( WFlags f )	{ QWidget::clearWState(f); }
+    void setWFlags( WFlags f )		{ QWidget::setWFlags(f); }
+    void clearWFlags( WFlags f )	{ QWidget::clearWFlags(f); }
+    bool translateMouseEvent( const XEvent * );
+    bool translateKeyEventInternal( const XEvent *, int& count, QString& text, int& state, char& ascii, int &code,
+				    QEvent::Type &type, bool willRepeat=FALSE );
+    bool translateKeyEvent( const XEvent *, bool grab );
+    bool translatePaintEvent( const XEvent * );
+    bool translateConfigEvent( const XEvent * );
+    bool translateCloseEvent( const XEvent * );
+    bool translateScrollDoneEvent( const XEvent * );
+    bool translateWheelEvent( int global_x, int global_y, int delta, int state, Orientation orient );
+#if defined (QT_TABLET_SUPPORT)
+    bool translateXinputEvent( const XEvent* );
+#endif
+    bool translatePropertyEvent(const XEvent *);
+};
+
+
+
+
+// ************************************************************************
+// X Input Method support
+// ************************************************************************
+
+#if !defined(QT_NO_XIM)
+
+#if defined(Q_C_CALLBACKS)
+extern "C" {
+#endif // Q_C_CALLBACKS
+
+#ifdef USE_X11R6_XIM
+    static void xim_create_callback(XIM /*im*/,
+				    XPointer /*client_data*/,
+				    XPointer /*call_data*/)
+    {
+	// qDebug("xim_create_callback");
+	QApplication::create_xim();
+    }
+
+    static void xim_destroy_callback(XIM /*im*/,
+				     XPointer /*client_data*/,
+				     XPointer /*call_data*/)
+    {
+	// qDebug("xim_destroy_callback");
+	QApplication::close_xim();
+	XRegisterIMInstantiateCallback(appDpy, 0, 0, 0,
+				       (XIMProc) xim_create_callback, 0);
+    }
+
+#endif // USE_X11R6_XIM
+
+#if defined(Q_C_CALLBACKS)
+}
+#endif // Q_C_CALLBACKS
+
+#endif // QT_NO_XIM
+
+
+/*! \internal
+  Creates the application input method.
+ */
+void QApplication::create_xim()
+{
+#ifndef QT_NO_XIM
+    qt_xim = XOpenIM( appDpy, 0, 0, 0 );
+    if ( qt_xim ) {
+
+#ifdef USE_X11R6_XIM
+	XIMCallback destroy;
+	destroy.callback = (XIMProc) xim_destroy_callback;
+	destroy.client_data = 0;
+	if ( XSetIMValues( qt_xim, XNDestroyCallback, &destroy, (char *) 0 ) != 0 )
+	    qWarning( "Xlib dosn't support destroy callback");
+#endif // USE_X11R6_XIM
+
+	XIMStyles *styles = 0;
+	XGetIMValues(qt_xim, XNQueryInputStyle, &styles, (char *) 0, (char *) 0);
+	if ( styles ) {
+	    int i;
+	    for ( i = 0; !qt_xim_style && i < styles->count_styles; i++ ) {
+		if ( styles->supported_styles[i] == xim_preferred_style ) {
+		    qt_xim_style = xim_preferred_style;
+		    break;
+		}
+	    }
+	    // if the preferred input style couldn't be found, look for
+	    // Nothing
+	    for ( i = 0; !qt_xim_style && i < styles->count_styles; i++ ) {
+		if ( styles->supported_styles[i] == (XIMPreeditNothing |
+						     XIMStatusNothing) ) {
+		    qt_xim_style = XIMPreeditNothing | XIMStatusNothing;
+		    break;
+		}
+	    }
+	    // ... and failing that, None.
+	    for ( i = 0; !qt_xim_style && i < styles->count_styles; i++ ) {
+		if ( styles->supported_styles[i] == (XIMPreeditNone |
+						     XIMStatusNone) ) {
+		    qt_xim_style = XIMPreeditNone | XIMStatusNone;
+		    break;
+		}
+	    }
+
+	    // qDebug("QApplication: using im style %lx", qt_xim_style);
+	    XFree( (char *)styles );
+	}
+
+	if ( qt_xim_style ) {
+
+#ifdef USE_X11R6_XIM
+	    XUnregisterIMInstantiateCallback(appDpy, 0, 0, 0,
+					     (XIMProc) xim_create_callback, 0);
+#endif // USE_X11R6_XIM
+
+	    QWidgetList *list= qApp->topLevelWidgets();
+	    QWidgetListIt it(*list);
+	    QWidget * w;
+	    while( (w=it.current()) != 0 ) {
+		++it;
+		w->createTLSysExtra();
+	    }
+	    delete list;
+	} else {
+	    // Give up
+	    qWarning( "No supported input style found."
+		      "  See InputMethod documentation.");
+	    close_xim();
+	}
+    }
+#endif // QT_NO_XIM
+}
+
+
+/*! \internal
+  Closes the application input method.
+*/
+void QApplication::close_xim()
+{
+#ifndef QT_NO_XIM
+    // Calling XCloseIM gives a Purify FMR error
+    // XCloseIM( qt_xim );
+    // We prefer a less serious memory leak
+
+    qt_xim = 0;
+    QWidgetList *list = qApp->topLevelWidgets();
+    QWidgetListIt it(*list);
+    while(it.current()) {
+	it.current()->destroyInputContext();
+	++it;
+    }
+    delete list;
+#endif // QT_NO_XIM
+}
+
+
+/*****************************************************************************
+  Default X error handlers
+ *****************************************************************************/
+
+#if defined(Q_C_CALLBACKS)
+extern "C" {
+#endif
+
+static bool x11_ignore_badwindow;
+static bool x11_badwindow;
+
+    // starts to ignore bad window errors from X
+void qt_ignore_badwindow()
+{
+    x11_ignore_badwindow = TRUE;
+    x11_badwindow = FALSE;
+}
+
+    // ends ignoring bad window errors and returns whether an error
+    // had happen.
+bool qt_badwindow()
+{
+    x11_ignore_badwindow = FALSE;
+    return x11_badwindow;
+}
+
+static int (*original_x_errhandler)( Display *dpy, XErrorEvent * );
+static int (*original_xio_errhandler)( Display *dpy );
+
+static int qt_x_errhandler( Display *dpy, XErrorEvent *err )
+{
+    if ( err->error_code == BadWindow ) {
+	x11_badwindow = TRUE;
+	if ( err->request_code == 25 /* X_SendEvent */ &&
+	     qt_xdnd_handle_badwindow() )
+	    return 0;
+	if ( x11_ignore_badwindow )
+	    return 0;
+    } else if ( err->error_code == BadMatch &&
+		err->request_code == 42 /* X_SetInputFocus */ ) {
+	return 0;
+    }
+
+    char errstr[256];
+    XGetErrorText( dpy, err->error_code, errstr, 256 );
+    qWarning( "X Error: %s %d\n"
+	      "  Major opcode:  %d\n"
+	      "  Minor opcode:  %d\n"
+	      "  Resource id:  0x%lx",
+	      errstr, err->error_code,
+	      err->request_code,
+	      err->minor_code,
+	      err->resourceid );
+
+    // ### we really should distinguish between severe, non-severe and
+    // ### application specific errors
+
+    return 0;
+}
+
+
+static int qt_xio_errhandler( Display * )
+{
+    qWarning( "%s: Fatal IO error: client killed", appName );
+    qApp = 0;
+    exit( 1 );
+    //### give the application a chance for a proper shutdown instead,
+    //### exit(1) doesn't help.
+    return 0;
+}
+
+#if defined(Q_C_CALLBACKS)
+}
+#endif
+
+
+// Memory leak: if the app exits before qt_init_internal(), this dict
+// isn't released correctly.
+static QAsciiDict<Atom> *atoms_to_be_created = 0;
+static bool create_atoms_now = 0;
+
+/*****************************************************************************
+  qt_x11_intern_atom() - efficiently interns an atom, now or later.
+
+  If the application is being initialized, this function stores the
+  adddress of the atom and qt_init_internal will do the actual work
+  quickly. If the application is running, the atom is created here.
+
+  Neither argument may point to temporary variables.
+ *****************************************************************************/
+
+void qt_x11_intern_atom( const char *name, Atom *result)
+{
+    if ( !name || !result || *result )
+	return;
+
+    if ( create_atoms_now ) {
+	*result = XInternAtom( appDpy, name, False );
+    } else {
+	if ( !atoms_to_be_created ) {
+	    atoms_to_be_created = new QAsciiDict<Atom>;
+	    atoms_to_be_created->setAutoDelete( FALSE );
+	}
+	atoms_to_be_created->insert( name, result );
+	*result = 0;
+    }
+}
+
+
+static void qt_x11_process_intern_atoms()
+{
+    if ( atoms_to_be_created ) {
+#if defined(XlibSpecificationRelease) && (XlibSpecificationRelease >= 6)
+	int i = atoms_to_be_created->count();
+	Atom * res = (Atom *)malloc( i * sizeof( Atom ) );
+	Atom ** resp = (Atom **)malloc( i * sizeof( Atom* ) );
+	char ** names = (char **)malloc( i * sizeof(const char*));
+
+	i = 0;
+	QAsciiDictIterator<Atom> it( *atoms_to_be_created );
+	while( it.current() ) {
+	    res[i] = 0;
+	    resp[i] = it.current();
+	    names[i] = qstrdup(it.currentKey());
+	    i++;
+	    ++it;
+	}
+	XInternAtoms( appDpy, names, i, False, res );
+	while( i ) {
+	    i--;
+	    delete [] names[i];
+	    if ( res[i] && resp[i] )
+		*(resp[i]) = res[i];
+	}
+	free( res );
+	free( resp );
+	free( names );
+#else
+	QAsciiDictIterator<Atom> it( *atoms_to_be_created );
+	Atom * result;
+	const char * name;
+	while( (result = it.current()) != 0 ) {
+	    name = it.currentKey();
+	    ++it;
+	    *result = XInternAtom( appDpy, name, False );
+	}
+#endif
+	delete atoms_to_be_created;
+	atoms_to_be_created = 0;
+	create_atoms_now = TRUE;
+    }
+}
+
+
+/*! \internal
+    apply the settings to the application
+*/
+bool QApplication::x11_apply_settings()
+{
+    if (! qt_std_pal)
+	qt_create_std_palette();
+
+    Atom type;
+    int format;
+    long offset = 0;
+    unsigned long nitems, after = 1;
+    unsigned char *data = 0;
+    QDateTime timestamp, settingsstamp;
+    bool update_timestamp = FALSE;
+
+    if (XGetWindowProperty(appDpy, QPaintDevice::x11AppRootWindow( 0 ),
+			   qt_settings_timestamp, 0, 0,
+			   False, AnyPropertyType, &type, &format, &nitems,
+			   &after, &data) == Success && format == 8) {
+	if (data)
+	    XFree(data);
+
+	QBuffer ts;
+	ts.open(IO_WriteOnly);
+
+	while (after > 0) {
+	    XGetWindowProperty(appDpy, QPaintDevice::x11AppRootWindow( 0 ),
+			       qt_settings_timestamp,
+			       offset, 1024, False, AnyPropertyType,
+			       &type, &format, &nitems, &after, &data);
+	    if (format == 8) {
+		ts.writeBlock((const char *) data, nitems);
+		offset += nitems / 4;
+	    }
+
+	    XFree(data);
+	}
+
+	QDataStream d(ts.buffer(), IO_ReadOnly);
+	d >> timestamp;
+    }
+
+    QSettings settings;
+    settingsstamp = settings.lastModificationTime( "/qt/font" );
+    if (! settingsstamp.isValid())
+	return FALSE;
+
+    if ( appliedstamp && appliedstamp == settingsstamp.toTime_t() )
+	return TRUE;
+    appliedstamp = settingsstamp.toTime_t();
+
+    if (! timestamp.isValid() || settingsstamp > timestamp)
+	update_timestamp = TRUE;
+
+    /*
+      Qt settings. This is now they are written into the datastream.
+
+      /qt/Palette/ *             - QPalette
+      /qt/font                   - QFont
+      /qt/libraryPath            - QStringList
+      /qt/style                  - QString
+      /qt/doubleClickInterval    - int
+      /qt/cursorFlashTime        - int
+      /qt/wheelScrollLines       - int
+      /qt/colorSpec              - QString
+      /qt/defaultCodec           - QString
+      /qt/globalStrut            - QSize
+      /qt/GUIEffects             - QStringList
+      /qt/Font Substitutions/ *  - QStringList
+      /qt/Font Substitutions/... - QStringList
+    */
+
+    QString str;
+    QStringList strlist;
+    int i, num;
+    QPalette pal(QApplication::palette());
+    strlist = settings.readListEntry("/qt/Palette/active");
+    if (strlist.count() == QColorGroup::NColorRoles) {
+	for (i = 0; i < QColorGroup::NColorRoles; i++)
+	    pal.setColor(QPalette::Active, (QColorGroup::ColorRole) i,
+			 QColor(strlist[i]));
+    }
+    strlist = settings.readListEntry("/qt/Palette/inactive");
+    if (strlist.count() == QColorGroup::NColorRoles) {
+	for (i = 0; i < QColorGroup::NColorRoles; i++)
+	    pal.setColor(QPalette::Inactive, (QColorGroup::ColorRole) i,
+			 QColor(strlist[i]));
+    }
+    strlist = settings.readListEntry("/qt/Palette/disabled");
+    if (strlist.count() == QColorGroup::NColorRoles) {
+	for (i = 0; i < QColorGroup::NColorRoles; i++)
+	    pal.setColor(QPalette::Disabled, (QColorGroup::ColorRole) i,
+			 QColor(strlist[i]));
+    }
+
+    // workaround for KDE 3.0, which messes up the buttonText value of
+    // the disabled palette in QSettings
+    if ( pal.disabled().buttonText() == pal.active().buttonText() ) {
+	pal.setColor( QPalette::Disabled, QColorGroup::ButtonText,
+		      pal.disabled().foreground() );
+    }
+
+    if (pal != *qt_std_pal && pal != QApplication::palette()) {
+	QApplication::setPalette(pal, TRUE);
+	*qt_std_pal = pal;
+    }
+
+    QFont font(QApplication::font());
+    // read new font
+    str = settings.readEntry("/qt/font");
+    if (! str.isNull() && ! str.isEmpty()) {
+	font.fromString(str);
+
+	if (font != QApplication::font())
+	    QApplication::setFont(font, TRUE);
+    }
+
+    // read library (ie. plugin) path list
+    QString libpathkey =
+	QString("/qt/%1.%2/libraryPath").arg( QT_VERSION >> 16 ).arg( (QT_VERSION & 0xff00 ) >> 8 );
+    QStringList pathlist = settings.readListEntry(libpathkey, ':');
+    if (! pathlist.isEmpty()) {
+	QStringList::ConstIterator it = pathlist.begin();
+	while (it != pathlist.end())
+	    QApplication::addLibraryPath(*it++);
+    }
+
+    // read new QStyle
+    extern bool qt_explicit_app_style; // defined in qapplication.cpp
+    QString stylename = settings.readEntry( "/qt/style" );
+    if ( !stylename.isEmpty() && !qt_explicit_app_style ) {
+	QApplication::setStyle( stylename );
+	// took the style from the user settings, so mark the explicit flag FALSE
+	qt_explicit_app_style = FALSE;
+    }
+
+    num =
+	settings.readNumEntry("/qt/doubleClickInterval",
+			      QApplication::doubleClickInterval());
+    QApplication::setDoubleClickInterval(num);
+
+    num =
+	settings.readNumEntry("/qt/cursorFlashTime",
+			      QApplication::cursorFlashTime());
+    QApplication::setCursorFlashTime(num);
+
+    num =
+	settings.readNumEntry("/qt/wheelScrollLines",
+			      QApplication::wheelScrollLines());
+    QApplication::setWheelScrollLines(num);
+
+    QString colorspec = settings.readEntry("/qt/colorSpec", "default");
+    if (colorspec == "normal")
+	QApplication::setColorSpec(QApplication::NormalColor);
+    else if (colorspec == "custom")
+	QApplication::setColorSpec(QApplication::CustomColor);
+    else if (colorspec == "many")
+	QApplication::setColorSpec(QApplication::ManyColor);
+    else if (colorspec != "default")
+	colorspec = "default";
+
+    QString defaultcodec = settings.readEntry("/qt/defaultCodec", "none");
+    if (defaultcodec != "none") {
+	QTextCodec *codec = QTextCodec::codecForName(defaultcodec);
+	if (codec)
+	    qApp->setDefaultCodec(codec);
+    }
+
+    QStringList strut = settings.readListEntry("/qt/globalStrut");
+    if (! strut.isEmpty()) {
+	if (strut.count() == 2) {
+	    QSize sz(strut[0].toUInt(), strut[1].toUInt());
+
+	    if (sz.isValid())
+		QApplication::setGlobalStrut(sz);
+	}
+    }
+
+    QStringList effects = settings.readListEntry("/qt/GUIEffects");
+
+    QApplication::setEffectEnabled( Qt::UI_General, effects.contains("general") );
+    QApplication::setEffectEnabled( Qt::UI_AnimateMenu, effects.contains("animatemenu") );
+    QApplication::setEffectEnabled( Qt::UI_FadeMenu, effects.contains("fademenu") );
+    QApplication::setEffectEnabled( Qt::UI_AnimateCombo, effects.contains("animatecombo") );
+    QApplication::setEffectEnabled( Qt::UI_AnimateTooltip, effects.contains("animatetooltip") );
+    QApplication::setEffectEnabled( Qt::UI_FadeTooltip, effects.contains("fadetooltip") );
+    QApplication::setEffectEnabled( Qt::UI_AnimateToolBox, effects.contains("animatetoolbox") );
+
+    QStringList fontsubs =
+	settings.entryList("/qt/Font Substitutions");
+    if (!fontsubs.isEmpty()) {
+	QStringList subs;
+	QString fam, skey;
+	QStringList::Iterator it = fontsubs.begin();
+	while (it != fontsubs.end()) {
+	    fam = (*it++);
+	    skey = "/qt/Font Substitutions/" + fam;
+	    subs = settings.readListEntry(skey);
+	    QFont::insertSubstitutions(fam, subs);
+	}
+    }
+
+    qt_broken_wm =
+	settings.readBoolEntry("/qt/brokenWindowManager", qt_broken_wm);
+
+    qt_resolve_symlinks =
+	settings.readBoolEntry("/qt/resolveSymlinks", TRUE);
+
+    qt_use_rtl_extensions =
+    	settings.readBoolEntry("/qt/useRtlExtensions", FALSE);
+
+#ifndef QT_NO_XIM
+    if (xim_preferred_style == 0) {
+        QString ximInputStyle =
+            settings.readEntry( "/qt/XIMInputStyle",
+                                QObject::trUtf8( "On The Spot" ) ).lower();
+        if ( ximInputStyle == "on the spot" )
+            xim_preferred_style = XIMPreeditCallbacks | XIMStatusNothing;
+        else if ( ximInputStyle == "over the spot" )
+            xim_preferred_style = XIMPreeditPosition | XIMStatusNothing;
+        else if ( ximInputStyle == "off the spot" )
+            xim_preferred_style = XIMPreeditArea | XIMStatusArea;
+        else if ( ximInputStyle == "root" )
+            xim_preferred_style = XIMPreeditNothing | XIMStatusNothing;
+    }
+#endif
+
+    if (update_timestamp) {
+	QBuffer stamp;
+	QDataStream s(stamp.buffer(), IO_WriteOnly);
+	s << settingsstamp;
+
+	XChangeProperty(appDpy, QPaintDevice::x11AppRootWindow( 0 ),
+			qt_settings_timestamp, qt_settings_timestamp, 8,
+			PropModeReplace, (unsigned char *) stamp.buffer().data(),
+			stamp.buffer().size());
+    }
+
+    return TRUE;
+}
+
+
+// read the _QT_INPUT_ENCODING property and apply the settings to
+// the application
+static void qt_set_input_encoding()
+{
+    Atom type;
+    int format;
+    ulong  nitems, after = 1;
+    const char *data;
+
+    int e = XGetWindowProperty( appDpy, QPaintDevice::x11AppRootWindow(),
+				qt_input_encoding, 0, 1024,
+				False, XA_STRING, &type, &format, &nitems,
+				&after,  (unsigned char**)&data );
+    if ( e != Success || !nitems || type == None ) {
+	// Always use the locale codec, since we have no examples of non-local
+	// XIMs, and since we cannot get a sensible answer about the encoding
+	// from the XIM.
+	input_mapper = QTextCodec::codecForLocale();
+
+    } else {
+	if ( !qstricmp( data, "locale" ) )
+	    input_mapper = QTextCodec::codecForLocale();
+	else
+	    input_mapper = QTextCodec::codecForName( data );
+	// make sure we have an input codec
+	if( !input_mapper )
+	    input_mapper = QTextCodec::codecForName( "ISO 8859-1" );
+    }
+    if ( input_mapper->mibEnum() == 11 ) // 8859-8
+	input_mapper = QTextCodec::codecForName( "ISO 8859-8-I");
+    if( data )
+	XFree( (char *)data );
+}
+
+// set font, foreground and background from x11 resources. The
+// arguments may override the resource settings.
+static void qt_set_x11_resources( const char* font = 0, const char* fg = 0,
+				  const char* bg = 0, const char* button = 0 )
+{
+    if ( !qt_std_pal )
+	qt_create_std_palette();
+
+    QCString resFont, resFG, resBG, resEF, sysFont;
+
+    QApplication::setEffectEnabled( Qt::UI_General, FALSE);
+    QApplication::setEffectEnabled( Qt::UI_AnimateMenu, FALSE);
+    QApplication::setEffectEnabled( Qt::UI_FadeMenu, FALSE);
+    QApplication::setEffectEnabled( Qt::UI_AnimateCombo, FALSE );
+    QApplication::setEffectEnabled( Qt::UI_AnimateTooltip, FALSE );
+    QApplication::setEffectEnabled( Qt::UI_FadeTooltip, FALSE );
+    QApplication::setEffectEnabled( Qt::UI_AnimateToolBox, FALSE );
+
+    if ( QApplication::desktopSettingsAware() && !QApplication::x11_apply_settings()  ) {
+	int format;
+	ulong  nitems, after = 1;
+	QCString res;
+	long offset = 0;
+	Atom type = None;
+
+	while (after > 0) {
+	    uchar *data;
+	    XGetWindowProperty( appDpy, QPaintDevice::x11AppRootWindow( 0 ),
+				qt_resource_manager,
+				offset, 8192, False, AnyPropertyType,
+				&type, &format, &nitems, &after,
+				&data );
+	    res += (char*)data;
+	    offset += 2048; // offset is in 32bit quantities... 8192/4 == 2048
+	    if ( data )
+		XFree( (char *)data );
+	}
+
+	QCString key, value;
+	int l = 0, r;
+	QCString apn = appName;
+	QCString apc = appClass;
+	int apnl = apn.length();
+	int apcl = apc.length();
+	int resl = res.length();
+
+	while (l < resl) {
+	    r = res.find( '\n', l );
+	    if ( r < 0 )
+		r = resl;
+	    while ( isspace((uchar) res[l]) )
+		l++;
+	    bool mine = FALSE;
+	    if ( res[l] == '*' &&
+		 (res[l+1] == 'f' || res[l+1] == 'b' || res[l+1] == 'g' ||
+		  res[l+1] == 'F' || res[l+1] == 'B' || res[l+1] == 'G' ||
+		  res[l+1] == 's' || res[l+1] == 'S' ) ) {
+		// OPTIMIZED, since we only want "*[fbgs].."
+
+		QCString item = res.mid( l, r - l ).simplifyWhiteSpace();
+		int i = item.find( ":" );
+		key = item.left( i ).stripWhiteSpace().mid(1).lower();
+		value = item.right( item.length() - i - 1 ).stripWhiteSpace();
+		mine = TRUE;
+	    } else if ( res[l] == appName[0] || (appClass && res[l] == appClass[0]) ) {
+		if (res.mid(l,apnl) == apn && (res[l+apnl] == '.' || res[l+apnl] == '*')) {
+		    QCString item = res.mid( l, r - l ).simplifyWhiteSpace();
+		    int i = item.find( ":" );
+		    key = item.left( i ).stripWhiteSpace().mid(apnl+1).lower();
+		    value = item.right( item.length() - i - 1 ).stripWhiteSpace();
+		    mine = TRUE;
+		} else if (res.mid(l,apcl) == apc && (res[l+apcl] == '.' || res[l+apcl] == '*')) {
+		    QCString item = res.mid( l, r - l ).simplifyWhiteSpace();
+		    int i = item.find( ":" );
+		    key = item.left( i ).stripWhiteSpace().mid(apcl+1).lower();
+		    value = item.right( item.length() - i - 1 ).stripWhiteSpace();
+		    mine = TRUE;
+		}
+	    }
+
+	    if ( mine ) {
+		if ( !font && key == "systemfont")
+		    sysFont = value.left( value.findRev(':') ).copy();
+		if ( !font && key == "font")
+		    resFont = value.copy();
+		else if  ( !fg &&  key == "foreground" )
+		    resFG = value.copy();
+		else if ( !bg && key == "background")
+		    resBG = value.copy();
+		else if ( key == "guieffects")
+		    resEF = value.copy();
+		// NOTE: if you add more, change the [fbg] stuff above
+	    }
+
+	    l = r + 1;
+	}
+    }
+    if ( !sysFont.isEmpty() )
+	resFont = sysFont;
+    if ( resFont.isEmpty() )
+	resFont = font;
+    if ( resFG.isEmpty() )
+	resFG = fg;
+    if ( resBG.isEmpty() )
+	resBG = bg;
+    if ( !resFont.isEmpty() ) {				// set application font
+	QFont fnt;
+	fnt.setRawName( resFont );
+
+	// the font we get may actually be an alias for another font,
+	// so we reset the application font to the real font info.
+	if ( ! fnt.exactMatch() ) {
+	    QFontInfo fontinfo( fnt );
+	    fnt.setFamily( fontinfo.family() );
+	    fnt.setRawMode( fontinfo.rawMode() );
+
+	    if ( ! fnt.rawMode() ) {
+		fnt.setItalic( fontinfo.italic() );
+		fnt.setWeight( fontinfo.weight() );
+		fnt.setUnderline( fontinfo.underline() );
+		fnt.setStrikeOut( fontinfo.strikeOut() );
+		fnt.setStyleHint( fontinfo.styleHint() );
+
+		if ( fnt.pointSize() <= 0 && fnt.pixelSize() <= 0 )
+		    // size is all wrong... fix it
+		    fnt.setPointSize( (int) ( ( fontinfo.pixelSize() * 72. /
+						(float) QPaintDevice::x11AppDpiY() ) +
+					      0.5 ) );
+	    }
+	}
+
+	if ( fnt != QApplication::font() ) {
+	    QApplication::setFont( fnt, TRUE );
+	}
+    }
+
+
+    if ( button || !resBG.isEmpty() || !resFG.isEmpty() ) {// set app colors
+	QColor btn;
+	QColor bg;
+	QColor fg;
+	if ( !resBG.isEmpty() )
+	    bg = QColor(QString(resBG));
+	else
+	    bg = qt_std_pal->active().background();
+	if ( !resFG.isEmpty() )
+	    fg = QColor(QString(resFG));
+	else
+	    fg = qt_std_pal->active().foreground();
+	if ( button )
+	    btn = QColor( button );
+	else if ( !resBG.isEmpty() )
+	    btn = bg;
+	else
+	    btn = qt_std_pal->active().button();
+
+	int h,s,v;
+	fg.hsv(&h,&s,&v);
+	QColor base = Qt::white;
+	bool bright_mode = FALSE;
+	if (v >= 255-50) {
+	    base = btn.dark(150);
+	    bright_mode = TRUE;
+	}
+
+	QColorGroup cg( fg, btn, btn.light(),
+			btn.dark(), btn.dark(150), fg, Qt::white, base, bg );
+	if (bright_mode) {
+	    cg.setColor( QColorGroup::HighlightedText, base );
+	    cg.setColor( QColorGroup::Highlight, Qt::white );
+	} else {
+	    cg.setColor( QColorGroup::HighlightedText, Qt::white );
+	    cg.setColor( QColorGroup::Highlight, Qt::darkBlue );
+	}
+	QColor disabled( (fg.red()+btn.red())/2,
+			 (fg.green()+btn.green())/2,
+			 (fg.blue()+btn.blue())/2);
+	QColorGroup dcg( disabled, btn, btn.light( 125 ), btn.dark(), btn.dark(150),
+			 disabled, Qt::white, Qt::white, bg );
+	if (bright_mode) {
+	    dcg.setColor( QColorGroup::HighlightedText, base );
+	    dcg.setColor( QColorGroup::Highlight, Qt::white );
+	} else {
+	    dcg.setColor( QColorGroup::HighlightedText, Qt::white );
+	    dcg.setColor( QColorGroup::Highlight, Qt::darkBlue );
+	}
+	QPalette pal( cg, dcg, cg );
+	if ( pal != *qt_std_pal && pal != QApplication::palette() )
+	    QApplication::setPalette( pal, TRUE );
+	*qt_std_pal = pal;
+    }
+
+    if ( !resEF.isEmpty() ) {
+	QStringList effects = QStringList::split(" ",resEF);
+	QApplication::setEffectEnabled( Qt::UI_General,  effects.contains("general") );
+	QApplication::setEffectEnabled( Qt::UI_AnimateMenu, effects.contains("animatemenu") );
+	QApplication::setEffectEnabled( Qt::UI_FadeMenu, effects.contains("fademenu") );
+	QApplication::setEffectEnabled( Qt::UI_AnimateCombo, effects.contains("animatecombo") );
+	QApplication::setEffectEnabled( Qt::UI_AnimateTooltip, effects.contains("animatetooltip") );
+	QApplication::setEffectEnabled( Qt::UI_FadeTooltip, effects.contains("fadetooltip") );
+	QApplication::setEffectEnabled( Qt::UI_AnimateToolBox, effects.contains("animatetoolbox") );
+    }
+}
+
+
+static void qt_detect_broken_window_manager()
+{
+    Atom type;
+    int format;
+    ulong nitems, after;
+    uchar *data = 0;
+
+    // look for SGI's 4Dwm
+    int e = XGetWindowProperty(appDpy, QPaintDevice::x11AppRootWindow(),
+                               qt_sgi_desks_manager, 0, 1, False, XA_WINDOW,
+                               &type, &format, &nitems, &after, &data);
+    if (data)
+        XFree(data);
+
+    if (e == Success && type == XA_WINDOW && format == 32 && nitems == 1 && after == 0) {
+        // detected SGI 4Dwm
+        qt_broken_wm = TRUE;
+    }
+}
+
+
+// update the supported array
+void qt_get_net_supported()
+{
+    Atom type;
+    int format;
+    long offset = 0;
+    unsigned long nitems, after;
+    unsigned char *data = 0;
+
+    int e = XGetWindowProperty(appDpy, QPaintDevice::x11AppRootWindow(),
+			       qt_net_supported, 0, 0,
+			       False, XA_ATOM, &type, &format, &nitems, &after, &data);
+    if (data)
+	XFree(data);
+
+    if (qt_net_supported_list)
+	delete [] qt_net_supported_list;
+    qt_net_supported_list = 0;
+
+    if (e == Success && type == XA_ATOM && format == 32) {
+	QBuffer ts;
+	ts.open(IO_WriteOnly);
+
+	while (after > 0) {
+	    XGetWindowProperty(appDpy, QPaintDevice::x11AppRootWindow(),
+			       qt_net_supported, offset, 1024,
+			       False, XA_ATOM, &type, &format, &nitems, &after, &data);
+
+	    if (type == XA_ATOM && format == 32) {
+		ts.writeBlock((const char *) data, nitems * 4);
+		offset += nitems;
+	    } else
+		after = 0;
+	    if (data)
+		XFree(data);
+	}
+
+	// compute nitems
+	QByteArray buffer(ts.buffer());
+	nitems = buffer.size() / sizeof(Atom);
+	qt_net_supported_list = new Atom[nitems + 1];
+	Atom *a = (Atom *) buffer.data();
+	uint i;
+	for (i = 0; i < nitems; i++)
+	    qt_net_supported_list[i] = a[i];
+	qt_net_supported_list[nitems] = 0;
+    }
+}
+
+
+bool qt_net_supports(Atom atom)
+{
+    if (! qt_net_supported_list)
+	return FALSE;
+
+    bool supported = FALSE;
+    int i = 0;
+    while (qt_net_supported_list[i] != 0) {
+	if (qt_net_supported_list[i++] == atom) {
+	    supported = TRUE;
+	    break;
+	}
+    }
+
+    return supported;
+}
+
+
+// update the virtual roots array
+void qt_get_net_virtual_roots()
+{
+    if (qt_net_virtual_root_list)
+	delete [] qt_net_virtual_root_list;
+    qt_net_virtual_root_list = 0;
+
+    if (! qt_net_supports(qt_net_virtual_roots))
+	return;
+
+    Atom type;
+    int format;
+    long offset = 0;
+    unsigned long nitems, after;
+    unsigned char *data;
+
+    int e = XGetWindowProperty(appDpy, QPaintDevice::x11AppRootWindow(),
+			       qt_net_virtual_roots, 0, 0,
+			       False, XA_ATOM, &type, &format, &nitems, &after, &data);
+    if (data)
+	XFree(data);
+
+    if (e == Success && type == XA_ATOM && format == 32) {
+	QBuffer ts;
+	ts.open(IO_WriteOnly);
+
+	while (after > 0) {
+	    XGetWindowProperty(appDpy, QPaintDevice::x11AppRootWindow(),
+			       qt_net_virtual_roots, offset, 1024,
+			       False, XA_ATOM, &type, &format, &nitems, &after, &data);
+
+	    if (type == XA_ATOM && format == 32) {
+		ts.writeBlock((const char *) data, nitems * 4);
+		offset += nitems;
+	    } else
+		after = 0;
+	    if (data)
+		XFree(data);
+	}
+
+	// compute nitems
+	QByteArray buffer(ts.buffer());
+	nitems = buffer.size() / sizeof(Window);
+	qt_net_virtual_root_list = new Window[nitems + 1];
+	Window *a = (Window *) buffer.data();
+	uint i;
+	for (i = 0; i < nitems; i++)
+	    qt_net_virtual_root_list[i] = a[i];
+	qt_net_virtual_root_list[nitems] = 0;
+    }
+}
+
+void qt_x11_create_wm_client_leader()
+{
+    if ( qt_x11_wm_client_leader ) return;
+
+    qt_x11_wm_client_leader =
+	XCreateSimpleWindow( QPaintDevice::x11AppDisplay(),
+			     QPaintDevice::x11AppRootWindow(),
+			     0, 0, 1, 1, 0, 0, 0 );
+
+    // set client leader property to itself
+    XChangeProperty( QPaintDevice::x11AppDisplay(),
+		     qt_x11_wm_client_leader, qt_wm_client_leader,
+		     XA_WINDOW, 32, PropModeReplace,
+		     (unsigned char *)&qt_x11_wm_client_leader, 1 );
+
+    // If we are session managed, inform the window manager about it
+    QCString session = qApp->sessionId().latin1();
+    if ( !session.isEmpty() ) {
+	XChangeProperty( QPaintDevice::x11AppDisplay(),
+			 qt_x11_wm_client_leader, qt_sm_client_id,
+			 XA_STRING, 8, PropModeReplace,
+			 (unsigned char *)session.data(), session.length() );
+    }
+}
+
+static void qt_net_update_user_time(QWidget *tlw)
+{
+    XChangeProperty(QPaintDevice::x11AppDisplay(), tlw->winId(), qt_net_wm_user_time, XA_CARDINAL,
+		    32, PropModeReplace, (unsigned char *) &qt_x_user_time, 1);
+}
+
+static void qt_check_focus_model()
+{
+    Window fw = None;
+    int unused;
+    XGetInputFocus( appDpy, &fw, &unused );
+    if ( fw == PointerRoot )
+	qt_focus_model = FocusModel_PointerRoot;
+    else
+	qt_focus_model = FocusModel_Other;
+}
+
+
+/*
+  Returns a truecolor visual (if there is one). 8-bit TrueColor visuals
+  are ignored, unless the user has explicitly requested -visual TrueColor.
+  The SGI X server usually has an 8 bit default visual, but the application
+  can also ask for a truecolor visual. This is what we do if
+  QApplication::colorSpec() is QApplication::ManyColor.
+*/
+
+static Visual *find_truecolor_visual( Display *dpy, int scr, int *depth, int *ncols )
+{
+    XVisualInfo *vi, rvi;
+    int best=0, n, i;
+    rvi.c_class = TrueColor;
+    rvi.screen  = scr;
+    vi = XGetVisualInfo( dpy, VisualClassMask | VisualScreenMask,
+			 &rvi, &n );
+    if ( vi ) {
+	for ( i=0; i<n; i++ ) {
+	    if ( vi[i].depth > vi[best].depth )
+		best = i;
+	}
+    }
+    Visual *v = DefaultVisual(dpy,scr);
+    if ( !vi || (vi[best].visualid == XVisualIDFromVisual(v)) ||
+	 (vi[best].depth <= 8 && qt_visual_option != TrueColor) )
+	{
+	*depth = DefaultDepth(dpy,scr);
+	*ncols = DisplayCells(dpy,scr);
+    } else {
+	v = vi[best].visual;
+	*depth = vi[best].depth;
+	*ncols = vi[best].colormap_size;
+    }
+    if ( vi )
+	XFree( (char *)vi );
+    return v;
+}
+
+
+/*****************************************************************************
+  qt_init() - initializes Qt for X11
+ *****************************************************************************/
+
+// need to get default font?
+extern bool qt_app_has_font;
+
+#define XK_MISCELLANY
+#define XK_LATIN1
+#include <X11/keysymdef.h>
+
+// ### This should be static but it isn't because of the friend declaration
+// ### in qpaintdevice.h which then should have a static too but can't have
+// ### it because "storage class specifiers invalid in friend function
+// ### declarations" :-) Ideas anyone?
+void qt_init_internal( int *argcptr, char **argv,
+		       Display *display, Qt::HANDLE visual, Qt::HANDLE colormap )
+{
+    if ( display ) {
+	// Qt part of other application
+
+	appForeignDpy = TRUE;
+	appDpy  = display;
+
+	// Set application name and class
+	appName = qstrdup( "Qt-subapplication" );
+	char *app_class = 0;
+	if (argv) {
+	    const char* p = strrchr( argv[0], '/' );
+	    app_class = qstrdup(p ? p + 1 : argv[0]);
+	    if (app_class[0])
+		app_class[0] = toupper(app_class[0]);
+	}
+	appClass = app_class;
+
+	// Install default error handlers
+	original_x_errhandler = XSetErrorHandler( qt_x_errhandler );
+	original_xio_errhandler = XSetIOErrorHandler( qt_xio_errhandler );
+    } else {
+	// Qt controls everything (default)
+
+	int argc = *argcptr;
+	int j;
+
+	// Install default error handlers
+	original_x_errhandler = XSetErrorHandler( qt_x_errhandler );
+	original_xio_errhandler = XSetIOErrorHandler( qt_xio_errhandler );
+
+	// Set application name and class
+	char *app_class = 0;
+	if (argv) {
+	    const char *p = strrchr( argv[0], '/' );
+	    appName = p ? p + 1 : argv[0];
+	    app_class = qstrdup(appName);
+	    if (app_class[0])
+		app_class[0] = toupper(app_class[0]);
+	}
+	appClass = app_class;
+
+	// Get command line params
+	j = 1;
+	for ( int i=1; i<argc; i++ ) {
+	    if ( argv[i] && *argv[i] != '-' ) {
+		argv[j++] = argv[i];
+		continue;
+	    }
+	    QCString arg = argv[i];
+	    if ( arg == "-display" ) {
+		if ( ++i < argc )
+		    appDpyName = argv[i];
+	    } else if ( arg == "-fn" || arg == "-font" ) {
+		if ( ++i < argc )
+		    appFont = argv[i];
+	    } else if ( arg == "-bg" || arg == "-background" ) {
+		if ( ++i < argc )
+		    appBGCol = argv[i];
+	    } else if ( arg == "-btn" || arg == "-button" ) {
+		if ( ++i < argc )
+		    appBTNCol = argv[i];
+	    } else if ( arg == "-fg" || arg == "-foreground" ) {
+		if ( ++i < argc )
+		    appFGCol = argv[i];
+	    } else if ( arg == "-name" ) {
+		if ( ++i < argc )
+		    appName = argv[i];
+	    } else if ( arg == "-title" ) {
+		if ( ++i < argc )
+		    mwTitle = argv[i];
+	    } else if ( arg == "-geometry" ) {
+		if ( ++i < argc )
+		    mwGeometry = argv[i];
+		//Ming-Che 10/10
+	    } else if ( arg == "-im" ) {
+		if ( ++i < argc )
+		    ximServer = argv[i];
+	    } else if ( arg == "-noxim" ) {
+		noxim=TRUE;
+		//
+	    } else if ( arg == "-iconic" ) {
+		mwIconic = !mwIconic;
+	    } else if ( arg == "-ncols" ) {   // xv and netscape use this name
+		if ( ++i < argc )
+		    qt_ncols_option = QMAX(0,atoi(argv[i]));
+	    } else if ( arg == "-visual" ) {  // xv and netscape use this name
+		if ( ++i < argc ) {
+		    QCString s = QCString(argv[i]).lower();
+		    if ( s == "truecolor" ) {
+			qt_visual_option = TrueColor;
+		    } else {
+			// ### Should we honor any others?
+		    }
+		}
+#ifndef QT_NO_XIM
+	    } else if ( arg == "-inputstyle" ) {
+		if ( ++i < argc ) {
+		    QCString s = QCString(argv[i]).lower();
+		    if ( s == "onthespot" )
+			xim_preferred_style = XIMPreeditCallbacks |
+					      XIMStatusNothing;
+		    else if ( s == "overthespot" )
+			xim_preferred_style = XIMPreeditPosition |
+					      XIMStatusNothing;
+		    else if ( s == "offthespot" )
+			xim_preferred_style = XIMPreeditArea |
+					      XIMStatusArea;
+		    else if ( s == "root" )
+			xim_preferred_style = XIMPreeditNothing |
+					      XIMStatusNothing;
+		}
+#endif
+	    } else if ( arg == "-cmap" ) {    // xv uses this name
+		qt_cmap_option = TRUE;
+	    }
+#if defined(QT_DEBUG)
+	    else if ( arg == "-sync" )
+		appSync = !appSync;
+	    else if ( arg == "-nograb" )
+		appNoGrab = !appNoGrab;
+	    else if ( arg == "-dograb" )
+		appDoGrab = !appDoGrab;
+#endif
+	    else
+		argv[j++] = argv[i];
+	}
+
+	*argcptr = j;
+
+#if defined(QT_DEBUG) && defined(Q_OS_LINUX)
+	if ( !appNoGrab && !appDoGrab ) {
+	    QCString s;
+	    s.sprintf( "/proc/%d/cmdline", getppid() );
+	    QFile f( s );
+	    if ( f.open( IO_ReadOnly ) ) {
+		s.truncate( 0 );
+		int c;
+		while ( (c = f.getch()) > 0 ) {
+		    if ( c == '/' )
+			s.truncate( 0 );
+		    else
+			s += (char)c;
+		}
+		if ( s == "gdb" ) {
+		    appNoGrab = TRUE;
+		    qDebug( "Qt: gdb: -nograb added to command-line options.\n"
+			    "\t Use the -dograb option to enforce grabbing." );
+		}
+		f.close();
+	    }
+	}
+#endif
+	// Connect to X server
+
+	if( qt_is_gui_used ) {
+	    if ( ( appDpy = XOpenDisplay(appDpyName) ) == 0 ) {
+		qWarning( "%s: cannot connect to X server %s", appName,
+			  XDisplayName(appDpyName) );
+		qApp = 0;
+		exit( 1 );
+	    }
+
+	    if ( appSync )				// if "-sync" argument
+		XSynchronize( appDpy, TRUE );
+	}
+    }
+    // Common code, regardless of whether display is foreign.
+
+    // Get X parameters
+
+    if( qt_is_gui_used ) {
+	appScreen = DefaultScreen(appDpy);
+	appScreenCount = ScreenCount(appDpy);
+
+	QPaintDevice::x_appdisplay = appDpy;
+	QPaintDevice::x_appscreen = appScreen;
+
+	// allocate the arrays for the QPaintDevice data
+	QPaintDevice::x_appdepth_arr = new int[ appScreenCount ];
+	QPaintDevice::x_appcells_arr = new int[ appScreenCount ];
+	QPaintDevice::x_approotwindow_arr = new Qt::HANDLE[ appScreenCount ];
+	QPaintDevice::x_appcolormap_arr = new Qt::HANDLE[ appScreenCount ];
+	QPaintDevice::x_appdefcolormap_arr = new bool[ appScreenCount ];
+	QPaintDevice::x_appvisual_arr = new void*[ appScreenCount ];
+	QPaintDevice::x_appdefvisual_arr = new bool[ appScreenCount ];
+	Q_CHECK_PTR( QPaintDevice::x_appdepth_arr );
+	Q_CHECK_PTR( QPaintDevice::x_appcells_arr );
+	Q_CHECK_PTR( QPaintDevice::x_approotwindow_arr );
+	Q_CHECK_PTR( QPaintDevice::x_appcolormap_arr );
+	Q_CHECK_PTR( QPaintDevice::x_appdefcolormap_arr );
+	Q_CHECK_PTR( QPaintDevice::x_appvisual_arr );
+	Q_CHECK_PTR( QPaintDevice::x_appdefvisual_arr );
+
+	int screen;
+	QString serverVendor( ServerVendor( appDpy) );
+	if (serverVendor.contains("XFree86") && VendorRelease(appDpy) < 40300000)
+	    qt_hebrew_keyboard_hack = TRUE;
+
+	for ( screen = 0; screen < appScreenCount; ++screen ) {
+	    QPaintDevice::x_appdepth_arr[ screen ] = DefaultDepth(appDpy, screen);
+	    QPaintDevice::x_appcells_arr[ screen ] = DisplayCells(appDpy, screen);
+	    QPaintDevice::x_approotwindow_arr[ screen ] = RootWindow(appDpy, screen);
+
+	    // setup the visual and colormap for each screen
+	    Visual *vis = 0;
+	    if ( visual && screen == appScreen ) {
+		// use the provided visual on the default screen only
+		vis = (Visual *) visual;
+
+		// figure out the depth of the visual we are using
+		XVisualInfo *vi, rvi;
+		int n;
+		rvi.visualid = XVisualIDFromVisual(vis);
+		rvi.screen  = screen;
+		vi = XGetVisualInfo( appDpy, VisualIDMask | VisualScreenMask, &rvi, &n );
+		if (vi) {
+		    QPaintDevice::x_appdepth_arr[ screen ] = vi->depth;
+		    QPaintDevice::x_appcells_arr[ screen ] = vi->visual->map_entries;
+		    QPaintDevice::x_appvisual_arr[ screen ] = vi->visual;
+		    QPaintDevice::x_appdefvisual_arr[ screen ] = FALSE;
+		    XFree(vi);
+		} else {
+		    // couldn't get info about the visual, use the default instead
+		    vis = 0;
+		}
+	    }
+
+	    if (!vis) {
+		// use the default visual
+		vis = DefaultVisual(appDpy, screen);
+		QPaintDevice::x_appdefvisual_arr[ screen ] = TRUE;
+
+		if ( qt_visual_option == TrueColor ||
+		     QApplication::colorSpec() == QApplication::ManyColor ) {
+		    // find custom visual
+
+		    int d, c;
+		    vis = find_truecolor_visual( appDpy, screen, &d, &c );
+		    QPaintDevice::x_appdepth_arr[ screen ] = d;
+		    QPaintDevice::x_appcells_arr[ screen ] = c;
+
+		    QPaintDevice::x_appvisual_arr[ screen ] = vis;
+		    QPaintDevice::x_appdefvisual_arr[ screen ] =
+			(XVisualIDFromVisual(vis) ==
+			 XVisualIDFromVisual(DefaultVisual(appDpy, screen)));
+		}
+
+		QPaintDevice::x_appvisual_arr[ screen ] = vis;
+	    }
+
+	    // we assume that 8bpp == pseudocolor, but this is not
+	    // always the case (according to the X server), so we need
+	    // to make sure that our internal data is setup in a way
+	    // that is compatible with our assumptions
+	    if ( vis->c_class == TrueColor &&
+		 QPaintDevice::x_appdepth_arr[ screen ] == 8 &&
+		 QPaintDevice::x_appcells_arr[ screen ] == 8 )
+		QPaintDevice::x_appcells_arr[ screen ] = 256;
+
+	    if ( colormap && screen == appScreen ) {
+		// use the provided colormap for the default screen only
+		QPaintDevice::x_appcolormap_arr[ screen ] = colormap;
+		QPaintDevice::x_appdefcolormap_arr[ screen ] = FALSE;
+	    } else {
+		if ( vis->c_class == TrueColor ) {
+		    QPaintDevice::x_appdefcolormap_arr[ screen ] =
+			QPaintDevice::x_appdefvisual_arr[ screen ];
+		} else {
+		    QPaintDevice::x_appdefcolormap_arr[ screen ] =
+			!qt_cmap_option && QPaintDevice::x_appdefvisual_arr[ screen ];
+		}
+
+		if ( QPaintDevice::x_appdefcolormap_arr[ screen ] ) {
+		    // use default colormap
+		    XStandardColormap *stdcmap;
+		    VisualID vid =
+			XVisualIDFromVisual((Visual *)
+					    QPaintDevice::x_appvisual_arr[ screen ]);
+		    int i, count;
+
+		    QPaintDevice::x_appcolormap_arr[ screen ] = 0;
+
+		    if ( ! serverVendor.contains( "Hewlett-Packard" ) ) {
+			// on HPUX 10.20 local displays, the RGB_DEFAULT_MAP colormap
+			// doesn't give us correct colors. Why this happens, I have
+			// no clue, so we disable this for HPUX
+			if (XGetRGBColormaps(appDpy,
+					     QPaintDevice::x11AppRootWindow( screen ),
+					     &stdcmap, &count, XA_RGB_DEFAULT_MAP)) {
+			    i = 0;
+			    while (i < count &&
+				   QPaintDevice::x_appcolormap_arr[ screen ] == 0) {
+				if (stdcmap[i].visualid == vid) {
+				    QPaintDevice::x_appcolormap_arr[ screen ] =
+					stdcmap[i].colormap;
+				}
+				i++;
+			    }
+
+			    XFree( (char *)stdcmap );
+			}
+		    }
+
+		    if (QPaintDevice::x_appcolormap_arr[ screen ] == 0) {
+			QPaintDevice::x_appcolormap_arr[ screen ] =
+			    DefaultColormap(appDpy, screen);
+		    }
+		} else {
+		    // create a custom colormap
+		    QPaintDevice::x_appcolormap_arr[ screen ] =
+			XCreateColormap(appDpy, QPaintDevice::x11AppRootWindow( screen ),
+					vis, AllocNone);
+		}
+	    }
+	}
+
+	// Set X paintdevice parameters for the default screen
+	QPaintDevice::x_appdepth = QPaintDevice::x_appdepth_arr[ appScreen ];
+	QPaintDevice::x_appcells = QPaintDevice::x_appcells_arr[ appScreen ];
+	QPaintDevice::x_approotwindow = QPaintDevice::x_approotwindow_arr[ appScreen ];
+	QPaintDevice::x_appcolormap = QPaintDevice::x_appcolormap_arr[ appScreen ];
+	QPaintDevice::x_appdefcolormap = QPaintDevice::x_appdefcolormap_arr[ appScreen ];
+	QPaintDevice::x_appvisual = QPaintDevice::x_appvisual_arr[ appScreen ];
+	QPaintDevice::x_appdefvisual = QPaintDevice::x_appdefvisual_arr[ appScreen ];
+
+	// Support protocols
+
+	qt_x11_intern_atom( "WM_PROTOCOLS", &qt_wm_protocols );
+	qt_x11_intern_atom( "WM_DELETE_WINDOW", &qt_wm_delete_window );
+	qt_x11_intern_atom( "WM_STATE", &qt_wm_state );
+	qt_x11_intern_atom( "WM_CHANGE_STATE", &qt_wm_change_state );
+	qt_x11_intern_atom( "WM_TAKE_FOCUS", &qt_wm_take_focus );
+	qt_x11_intern_atom( "WM_CLIENT_LEADER", &qt_wm_client_leader);
+	qt_x11_intern_atom( "WM_WINDOW_ROLE", &qt_window_role);
+	qt_x11_intern_atom( "SM_CLIENT_ID", &qt_sm_client_id);
+	qt_x11_intern_atom( "CLIPBOARD", &qt_xa_clipboard );
+	qt_x11_intern_atom( "RESOURCE_MANAGER", &qt_resource_manager );
+	qt_x11_intern_atom( "INCR", &qt_x_incr );
+	qt_x11_intern_atom( "_XSETROOT_ID", &qt_xsetroot_id );
+	qt_x11_intern_atom( "_QT_SELECTION", &qt_selection_property );
+	qt_x11_intern_atom( "_QT_CLIPBOARD_SENTINEL", &qt_clipboard_sentinel );
+	qt_x11_intern_atom( "_QT_SELECTION_SENTINEL", &qt_selection_sentinel );
+	qt_x11_intern_atom( "_QT_SCROLL_DONE", &qt_qt_scrolldone );
+	qt_x11_intern_atom( "_QT_INPUT_ENCODING", &qt_input_encoding );
+	qt_x11_intern_atom( "_QT_SIZEGRIP", &qt_sizegrip );
+	qt_x11_intern_atom( "_NET_WM_CONTEXT_HELP", &qt_net_wm_context_help );
+	qt_x11_intern_atom( "_NET_WM_PING", &qt_net_wm_ping );
+	qt_x11_intern_atom( "_MOTIF_WM_HINTS", &qt_xa_motif_wm_hints );
+	qt_x11_intern_atom( "DTWM_IS_RUNNING", &qt_cde_running );
+	qt_x11_intern_atom( "KWIN_RUNNING", &qt_kwin_running );
+	qt_x11_intern_atom( "KWM_RUNNING", &qt_kwm_running );
+	qt_x11_intern_atom( "GNOME_BACKGROUND_PROPERTIES", &qt_gbackground_properties );
+
+	QString atomname("_QT_SETTINGS_TIMESTAMP_");
+	atomname += XDisplayName(appDpyName);
+	qt_x11_intern_atom( atomname.latin1(), &qt_settings_timestamp );
+
+	qt_x11_intern_atom( "_NET_SUPPORTED", &qt_net_supported );
+	qt_x11_intern_atom( "_NET_VIRTUAL_ROOTS", &qt_net_virtual_roots );
+	qt_x11_intern_atom( "_NET_WORKAREA", &qt_net_workarea );
+	qt_x11_intern_atom( "_NET_WM_STATE", &qt_net_wm_state );
+	qt_x11_intern_atom( "_NET_WM_STATE_MODAL", &qt_net_wm_state_modal );
+	qt_x11_intern_atom( "_NET_WM_STATE_MAXIMIZED_VERT", &qt_net_wm_state_max_v );
+	qt_x11_intern_atom( "_NET_WM_STATE_MAXIMIZED_HORZ", &qt_net_wm_state_max_h );
+	qt_x11_intern_atom( "_NET_WM_STATE_FULLSCREEN", &qt_net_wm_state_fullscreen );
+	qt_x11_intern_atom( "_NET_WM_STATE_ABOVE", &qt_net_wm_state_above );
+	qt_x11_intern_atom( "_NET_WM_WINDOW_TYPE", &qt_net_wm_window_type );
+	qt_x11_intern_atom( "_NET_WM_WINDOW_TYPE_NORMAL", &qt_net_wm_window_type_normal );
+	qt_x11_intern_atom( "_NET_WM_WINDOW_TYPE_DIALOG", &qt_net_wm_window_type_dialog );
+	qt_x11_intern_atom( "_NET_WM_WINDOW_TYPE_TOOLBAR", &qt_net_wm_window_type_toolbar );
+	qt_x11_intern_atom( "_NET_WM_WINDOW_TYPE_MENU", &qt_net_wm_window_type_menu );
+	qt_x11_intern_atom( "_NET_WM_WINDOW_TYPE_UTILITY", &qt_net_wm_window_type_utility );
+	qt_x11_intern_atom( "_NET_WM_WINDOW_TYPE_SPLASH", &qt_net_wm_window_type_splash );
+	qt_x11_intern_atom( "_KDE_NET_WM_WINDOW_TYPE_OVERRIDE", &qt_net_wm_window_type_override );
+	qt_x11_intern_atom( "_KDE_NET_WM_FRAME_STRUT", &qt_net_wm_frame_strut );
+	qt_x11_intern_atom( "_NET_WM_STATE_STAYS_ON_TOP",
+			    &qt_net_wm_state_stays_on_top );
+	qt_x11_intern_atom( "_NET_WM_PID", &qt_net_wm_pid );
+	qt_x11_intern_atom( "_NET_WM_USER_TIME", &qt_net_wm_user_time );
+	qt_x11_intern_atom( "ENLIGHTENMENT_DESKTOP", &qt_enlightenment_desktop );
+	qt_x11_intern_atom( "_NET_WM_NAME", &qt_net_wm_name );
+	qt_x11_intern_atom( "_NET_WM_ICON_NAME", &qt_net_wm_icon_name );
+	qt_x11_intern_atom( "UTF8_STRING", &qt_utf8_string );
+        qt_x11_intern_atom( "_SGI_DESKS_MANAGER", &qt_sgi_desks_manager );
+
+	qt_xdnd_setup();
+	qt_x11_motifdnd_init();
+
+	// Finally create all atoms
+	qt_x11_process_intern_atoms();
+
+        // look for broken window managers
+        qt_detect_broken_window_manager();
+
+	// initialize NET lists
+	qt_get_net_supported();
+	qt_get_net_virtual_roots();
+
+#ifndef QT_NO_XRANDR
+	// See if XRandR is supported on the connected display
+	int xrandr_errorbase;
+	Q_UNUSED( xrandr_eventbase );
+	if ( XRRQueryExtension( appDpy, &xrandr_eventbase, &xrandr_errorbase ) ) {
+	    // XRandR is supported
+	    qt_use_xrandr = TRUE;
+	}
+#endif // QT_NO_XRANDR
+
+#ifndef QT_NO_XRENDER
+	// See if XRender is supported on the connected display
+	int xrender_eventbase, xrender_errorbase;
+	if (XRenderQueryExtension(appDpy, &xrender_eventbase, &xrender_errorbase)) {
+	    // XRender is supported, let's see if we have a PictFormat for the
+	    // default visual
+	    XRenderPictFormat *format =
+		XRenderFindVisualFormat(appDpy,
+					(Visual *) QPaintDevice::x_appvisual);
+	    qt_use_xrender = (format != 0) && (QPaintDevice::x_appdepth != 8);
+	}
+#endif // QT_NO_XRENDER
+
+#ifndef QT_NO_XKB
+	// If XKB is detected, set the GrabsUseXKBState option so input method
+	// compositions continue to work (ie. deadkeys)
+	unsigned int state = XkbPCF_GrabsUseXKBStateMask;
+	(void) XkbSetPerClientControls(appDpy, state, &state);
+#endif
+
+#if !defined(QT_NO_XFTFREETYPE)
+	// defined in qfont_x11.cpp
+	extern bool qt_has_xft;
+#ifndef QT_XFT2
+        if (!qt_use_xrender)
+            qt_has_xft = FALSE;
+        else
+#endif
+            qt_has_xft = XftInit(0) && XftInitFtLibrary();
+
+        if (qt_has_xft) {
+            char *dpi_str = XGetDefault(appDpy, "Xft", "dpi");
+            if (dpi_str) {
+                // use a custom DPI
+                char *end = 0;
+                int dpi = strtol(dpi_str, &end, 0);
+                if (dpi_str != end) {
+                    for (int s = 0; s < ScreenCount(appDpy); ++s) {
+                        QPaintDevice::x11SetAppDpiX(dpi, s);
+                        QPaintDevice::x11SetAppDpiY(dpi, s);
+                    }
+                }
+            }
+        }
+#endif // QT_NO_XFTFREETYPE
+
+	// look at the modifier mapping, and get the correct masks for alt/meta
+	// find the alt/meta masks
+	XModifierKeymap *map = XGetModifierMapping(appDpy);
+	if (map) {
+	    int i, maskIndex = 0, mapIndex = 0;
+	    for (maskIndex = 0; maskIndex < 8; maskIndex++) {
+		for (i = 0; i < map->max_keypermod; i++) {
+		    if (map->modifiermap[mapIndex]) {
+			KeySym sym =
+			    XKeycodeToKeysym(appDpy, map->modifiermap[mapIndex], 0);
+			if ( qt_alt_mask == 0 &&
+			     ( sym == XK_Alt_L || sym == XK_Alt_R ) ) {
+			    qt_alt_mask = 1 << maskIndex;
+			}
+			if ( qt_meta_mask == 0 &&
+			     (sym == XK_Meta_L || sym == XK_Meta_R ) ) {
+			    qt_meta_mask = 1 << maskIndex;
+			}
+		    }
+		    mapIndex++;
+		}
+	    }
+
+	    // not look for mode_switch in qt_alt_mask and qt_meta_mask - if it is
+	    // present in one or both, then we set qt_mode_switch_remove_mask.
+	    // see QETWidget::translateKeyEventInternal for an explanation
+	    // of why this is needed
+	    mapIndex = 0;
+	    for ( maskIndex = 0; maskIndex < 8; maskIndex++ ) {
+		if ( qt_alt_mask  != ( 1 << maskIndex ) &&
+		     qt_meta_mask != ( 1 << maskIndex ) ) {
+		    for ( i = 0; i < map->max_keypermod; i++ )
+			mapIndex++;
+		    continue;
+		}
+
+		for ( i = 0; i < map->max_keypermod; i++ ) {
+		    if ( map->modifiermap[ mapIndex ] ) {
+			KeySym sym =
+			    XKeycodeToKeysym( appDpy, map->modifiermap[ mapIndex ], 0 );
+			if ( sym == XK_Mode_switch ) {
+			    qt_mode_switch_remove_mask |= 1 << maskIndex;
+			}
+		    }
+		    mapIndex++;
+		}
+	    }
+
+	    XFreeModifiermap(map);
+	} else {
+	    // assume defaults
+	    qt_alt_mask = Mod1Mask;
+	    qt_meta_mask = Mod4Mask;
+	    qt_mode_switch_remove_mask = 0;
+	}
+
+	// Misc. initialization
+
+	QColor::initialize();
+	QFont::initialize();
+	QCursor::initialize();
+	QPainter::initialize();
+    }
+
+#if defined(QT_THREAD_SUPPORT)
+    QThread::initialize();
+#endif
+
+    if( qt_is_gui_used ) {
+	qApp->setName( appName );
+
+	int screen;
+	for ( screen = 0; screen < appScreenCount; ++screen ) {
+	    XSelectInput( appDpy, QPaintDevice::x11AppRootWindow( screen ),
+			  KeymapStateMask | EnterWindowMask | LeaveWindowMask |
+			  PropertyChangeMask );
+
+#ifndef QT_NO_XRANDR
+	    if (qt_use_xrandr)
+		XRRSelectInput( appDpy, QPaintDevice::x11AppRootWindow( screen ), True );
+#endif // QT_NO_XRANDR
+	}
+    }
+
+    setlocale( LC_ALL, "" );		// use correct char set mapping
+    setlocale( LC_NUMERIC, "C" );	// make sprintf()/scanf() work
+
+    if ( qt_is_gui_used ) {
+	qt_set_input_encoding();
+
+	// be smart about the size of the default font. most X servers have helvetica
+	// 12 point available at 2 resolutions:
+	//     75dpi (12 pixels) and 100dpi (17 pixels).
+	// At 95 DPI, a 12 point font should be 16 pixels tall - in which case a 17
+	// pixel font is a closer match than a 12 pixel font
+	int ptsz =
+	    (int) ( ( ( QPaintDevice::x11AppDpiY() >= 95 ? 17. : 12. ) *
+		      72. / (float) QPaintDevice::x11AppDpiY() ) + 0.5 );
+
+	if ( !qt_app_has_font ) {
+	    QFont f( "Helvetica", ptsz );
+	    QApplication::setFont( f );
+	}
+
+	qt_set_x11_resources( appFont, appFGCol, appBGCol, appBTNCol);
+
+#ifndef QT_NO_XIM
+	if ( ! xim_preferred_style ) // no configured input style, use the default
+	    xim_preferred_style = xim_default_style;
+
+	qt_xim = 0;
+	QString ximServerName(ximServer);
+	if (ximServer)
+	    ximServerName.prepend("@im=");
+	else
+	    ximServerName = "";
+
+	if ( !XSupportsLocale() )
+	    qWarning("Qt: Locales not supported on X server");
+
+#ifdef USE_X11R6_XIM
+	else if ( XSetLocaleModifiers (ximServerName.ascii()) == 0 )
+	    qWarning( "Qt: Cannot set locale modifiers: %s",
+		      ximServerName.ascii());
+	else if (! noxim)
+	    XRegisterIMInstantiateCallback(appDpy, 0, 0, 0,
+					   (XIMProc) xim_create_callback, 0);
+#else // !USE_X11R6_XIM
+	else if ( XSetLocaleModifiers ("") == 0 )
+	    qWarning("Qt: Cannot set locale modifiers");
+	else if (! noxim)
+	    QApplication::create_xim();
+#endif // USE_X11R6_XIM
+#endif // QT_NO_XIM
+
+#if defined (QT_TABLET_SUPPORT)
+	int ndev,
+	    i,
+	    j;
+	bool gotStylus,
+	    gotEraser;
+	XDeviceInfo *devices, *devs;
+	XInputClassInfo *ip;
+	XAnyClassPtr any;
+	XValuatorInfoPtr v;
+	XAxisInfoPtr a;
+	XDevice *dev;
+	XEventClass *ev_class;
+	int curr_event_count;
+
+#if !defined(Q_OS_IRIX)
+	// XFree86 divides a stylus and eraser into 2 devices, so we must do for both...
+	const QString XFREENAMESTYLUS = "stylus";
+	const QString XFREENAMEPEN = "pen";
+	const QString XFREENAMEERASER = "eraser";
+#endif
+
+	devices = XListInputDevices( appDpy, &ndev);
+	if ( devices == NULL ) {
+	    qWarning( "Failed to get list of devices" );
+	    ndev = -1;
+	}
+	dev = NULL;
+	for ( devs = devices, i = 0; i < ndev; i++, devs++ ) {
+	    gotEraser = FALSE;
+#if defined(Q_OS_IRIX)
+
+	    gotStylus = ( !strncmp(devs->name,
+				   WACOM_NAME, sizeof(WACOM_NAME) - 1) );
+#else
+	    QString devName = devs->name;
+	    devName = devName.lower();
+	    gotStylus = ( devName.startsWith(XFREENAMEPEN)
+			  || devName.startsWith(XFREENAMESTYLUS) );
+	    if ( !gotStylus )
+		gotEraser = devName.startsWith( XFREENAMEERASER );
+
+#endif
+	    if ( gotStylus || gotEraser ) {
+		// I only wanted to do this once, so wrap pointers around these
+		curr_event_count = 0;
+
+		if ( gotStylus ) {
+		    devStylus = XOpenDevice( appDpy, devs->id );
+		    dev = devStylus;
+		    ev_class = event_list_stylus;
+		} else if ( gotEraser ) {
+		    devEraser = XOpenDevice( appDpy, devs->id );
+		    dev = devEraser;
+		    ev_class = event_list_eraser;
+		}
+		if ( dev == NULL ) {
+		    qWarning( "Failed to open device" );
+		} else {
+		    if ( dev->num_classes > 0 ) {
+			for ( ip = dev->classes, j = 0; j < devs->num_classes;
+			      ip++, j++ ) {
+			    switch ( ip->input_class ) {
+			    case KeyClass:
+				DeviceKeyPress( dev, xinput_key_press,
+						ev_class[curr_event_count] );
+				curr_event_count++;
+				DeviceKeyRelease( dev, xinput_key_release,
+						  ev_class[curr_event_count] );
+				curr_event_count++;
+				break;
+			    case ButtonClass:
+				DeviceButtonPress( dev, xinput_button_press,
+						   ev_class[curr_event_count] );
+				curr_event_count++;
+				DeviceButtonRelease( dev, xinput_button_release,
+						     ev_class[curr_event_count] );
+				curr_event_count++;
+				break;
+			    case ValuatorClass:
+				// I'm only going to be interested in motion when the
+				// stylus is already down anyway!
+				DeviceMotionNotify( dev, xinput_motion,
+						    ev_class[curr_event_count] );
+				curr_event_count++;
+				break;
+			    default:
+				break;
+			    }
+			}
+		    }
+		}
+		// get the min/max value for pressure!
+		any = (XAnyClassPtr) ( devs->inputclassinfo );
+		if ( dev == devStylus ) {
+		    qt_curr_events_stylus = curr_event_count;
+		    for (j = 0; j < devs->num_classes; j++) {
+			if ( any->c_class == ValuatorClass ) {
+			    v = (XValuatorInfoPtr) any;
+			    a = (XAxisInfoPtr) ((char *) v +
+						sizeof (XValuatorInfo));
+#if defined (Q_OS_IRIX)
+			    max_pressure = a[WAC_PRESSURE_I].max_value;
+#else
+			    max_pressure = a[2].max_value;
+#endif
+			    // got the max pressure no need to go further...
+			    break;
+			}
+			any = (XAnyClassPtr) ((char *) any + any->length);
+		    }
+		} else {
+		    qt_curr_events_eraser = curr_event_count;
+		}
+		// at this point we are assuming there is only one
+		// wacom device...
+#if defined (Q_OS_IRIX)
+		if ( devStylus != NULL ) {
+#else
+		    if ( devStylus != NULL && devEraser != NULL ) {
+#endif
+			break;
+		    }
+		}
+	    } // end for loop
+	    XFreeDeviceList( devices );
+#endif // QT_TABLET_SUPPORT
+
+	} else {
+	    // read some non-GUI settings when not using the X server...
+
+	    if ( QApplication::desktopSettingsAware() ) {
+		QSettings settings;
+
+		// read library (ie. plugin) path list
+		QString libpathkey = QString("/qt/%1.%2/libraryPath")
+				     .arg( QT_VERSION >> 16 )
+				     .arg( (QT_VERSION & 0xff00 ) >> 8 );
+		QStringList pathlist =
+		    settings.readListEntry(libpathkey, ':');
+		if (! pathlist.isEmpty()) {
+		    QStringList::ConstIterator it = pathlist.begin();
+		    while (it != pathlist.end())
+			QApplication::addLibraryPath(*it++);
+		}
+
+		QString defaultcodec = settings.readEntry("/qt/defaultCodec", "none");
+		if (defaultcodec != "none") {
+		    QTextCodec *codec = QTextCodec::codecForName(defaultcodec);
+		    if (codec)
+			qApp->setDefaultCodec(codec);
+		}
+
+		qt_resolve_symlinks =
+		    settings.readBoolEntry("/qt/resolveSymlinks", TRUE);
+	    }
+	}
+    }
+
+
+#ifndef QT_NO_STYLE
+    // run-time search for default style
+void QApplication::x11_initialize_style()
+{
+    Atom type;
+    int format;
+    unsigned long length, after;
+    uchar *data;
+    if ( !app_style &&
+	 XGetWindowProperty( appDpy, QPaintDevice::x11AppRootWindow(), qt_kwin_running,
+			     0, 1, False, AnyPropertyType, &type, &format, &length,
+			     &after, &data ) == Success && length ) {
+	if ( data ) XFree( (char *)data );
+	// kwin is there. check if KDE's styles are available,
+	// otherwise use windows style
+	if ( (app_style = QStyleFactory::create("highcolor") ) == 0 )
+	    app_style = QStyleFactory::create("windows");
+    }
+    if ( !app_style &&
+	 XGetWindowProperty( appDpy, QPaintDevice::x11AppRootWindow(), qt_kwm_running,
+			     0, 1, False, AnyPropertyType, &type, &format, &length,
+			     &after, &data ) == Success && length ) {
+	if ( data ) XFree( (char *)data );
+	app_style = QStyleFactory::create("windows");
+    }
+    if ( !app_style &&
+	 XGetWindowProperty( appDpy, QPaintDevice::x11AppRootWindow(), qt_cde_running,
+			     0, 1, False, AnyPropertyType, &type, &format, &length,
+			     &after, &data ) == Success && length ) {
+	// DTWM is running, meaning most likely CDE is running...
+	if ( data ) XFree( (char *) data );
+	app_style = QStyleFactory::create( "cde" );
+    }
+    // maybe another desktop?
+    if ( !app_style &&
+	 XGetWindowProperty( appDpy, QPaintDevice::x11AppRootWindow(),
+			     qt_gbackground_properties, 0, 1, False, AnyPropertyType,
+			     &type, &format, &length, &after, &data ) == Success &&
+	 length ) {
+	if ( data ) XFree( (char *)data );
+	// default to MotifPlus with hovering
+	app_style = QStyleFactory::create("motifplus" );
+    }
+}
+#endif
+
+void qt_init( int *argcptr, char **argv, QApplication::Type )
+{
+    qt_init_internal( argcptr, argv, 0, 0, 0 );
+}
+
+void qt_init( Display *display, Qt::HANDLE visual, Qt::HANDLE colormap )
+{
+    qt_init_internal( 0, 0, display, visual, colormap );
+}
+
+
+/*****************************************************************************
+  qt_cleanup() - cleans up when the application is finished
+ *****************************************************************************/
+
+void qt_cleanup()
+{
+    appliedstamp = 0;
+
+    if ( app_save_rootinfo )			// root window must keep state
+	qt_save_rootinfo();
+
+    if ( qt_is_gui_used ) {
+	QPixmapCache::clear();
+	QPainter::cleanup();
+	QCursor::cleanup();
+	QFont::cleanup();
+	QColor::cleanup();
+	QSharedDoubleBuffer::cleanup();
+    }
+#if defined(QT_THREAD_SUPPORT)
+    QThread::cleanup();
+#endif
+
+#if defined (QT_TABLET_SUPPORT)
+    if ( devStylus != NULL )
+	XCloseDevice( appDpy, devStylus );
+    if ( devEraser != NULL )
+	XCloseDevice( appDpy, devEraser );
+#endif
+
+#if !defined(QT_NO_XIM)
+    if ( qt_xim )
+	QApplication::close_xim();
+#endif
+
+    if ( qt_is_gui_used ) {
+	int screen;
+	for ( screen = 0; screen < appScreenCount; screen++ ) {
+	    if ( ! QPaintDevice::x11AppDefaultColormap( screen ) )
+		XFreeColormap( QPaintDevice::x11AppDisplay(),
+			       QPaintDevice::x11AppColormap( screen ) );
+	}
+    }
+
+#define QT_CLEANUP_GC(g) if (g) { for (int i=0;i<appScreenCount;i++){if(g[i])XFreeGC(appDpy,g[i]);} delete [] g; g = 0; }
+    QT_CLEANUP_GC(app_gc_ro);
+    QT_CLEANUP_GC(app_gc_ro_m);
+    QT_CLEANUP_GC(app_gc_tmp);
+    QT_CLEANUP_GC(app_gc_tmp_m);
+#undef QT_CLEANUP_GC
+
+    delete sip_list;
+    sip_list = 0;
+
+    // Reset the error handlers
+    XSetErrorHandler( original_x_errhandler );
+    XSetIOErrorHandler( original_xio_errhandler );
+
+    if ( qt_is_gui_used && !appForeignDpy )
+	XCloseDisplay( appDpy );		// close X display
+    appDpy = 0;
+
+    qt_x11_wm_client_leader = 0;
+
+    if ( QPaintDevice::x_appdepth_arr )
+	delete [] QPaintDevice::x_appdepth_arr;
+    if ( QPaintDevice::x_appcells_arr )
+	delete [] QPaintDevice::x_appcells_arr;
+    if ( QPaintDevice::x_appcolormap_arr )
+	delete []QPaintDevice::x_appcolormap_arr;
+    if ( QPaintDevice::x_appdefcolormap_arr )
+	delete [] QPaintDevice::x_appdefcolormap_arr;
+    if ( QPaintDevice::x_appvisual_arr )
+	delete [] QPaintDevice::x_appvisual_arr;
+    if ( QPaintDevice::x_appdefvisual_arr )
+	delete [] QPaintDevice::x_appdefvisual_arr;
+
+    if ( appForeignDpy ) {
+	delete [] (char *)appName;
+	appName = 0;
+	delete [] (char *)appClass;
+	appClass = 0;
+    }
+
+    if (qt_net_supported_list)
+	delete [] qt_net_supported_list;
+    qt_net_supported_list = 0;
+
+    if (qt_net_virtual_root_list)
+	delete [] qt_net_virtual_root_list;
+    qt_net_virtual_root_list = 0;
+}
+
+
+/*****************************************************************************
+  Platform specific global and internal functions
+ *****************************************************************************/
+
+void qt_save_rootinfo()				// save new root info
+{
+    Atom type;
+    int format;
+    unsigned long length, after;
+    uchar *data;
+
+    if ( qt_xsetroot_id ) {			// kill old pixmap
+	if ( XGetWindowProperty( appDpy, QPaintDevice::x11AppRootWindow(),
+				 qt_xsetroot_id, 0, 1,
+				 True, AnyPropertyType, &type, &format,
+				 &length, &after, &data ) == Success ) {
+	    if ( type == XA_PIXMAP && format == 32 && length == 1 &&
+		 after == 0 && data ) {
+		XKillClient( appDpy, *((Pixmap*)data) );
+	    }
+	    Pixmap dummy = XCreatePixmap( appDpy, QPaintDevice::x11AppRootWindow(),
+					  1, 1, 1 );
+	    XChangeProperty( appDpy, QPaintDevice::x11AppRootWindow(),
+			     qt_xsetroot_id, XA_PIXMAP, 32,
+			     PropModeReplace, (uchar *)&dummy, 1 );
+	    XSetCloseDownMode( appDpy, RetainPermanent );
+	}
+    }
+    if ( data )
+	XFree( (char *)data );
+}
+
+void qt_updated_rootinfo()
+{
+    app_save_rootinfo = TRUE;
+}
+
+bool qt_wstate_iconified( WId winid )
+{
+    Atom type;
+    int format;
+    unsigned long length, after;
+    uchar *data;
+    int r = XGetWindowProperty( appDpy, winid, qt_wm_state, 0, 2,
+				 False, AnyPropertyType, &type, &format,
+				 &length, &after, &data );
+    bool iconic = FALSE;
+    if ( r == Success && data && format == 32 ) {
+	// Q_UINT32 *wstate = (Q_UINT32*)data;
+	unsigned long *wstate = (unsigned long *) data;
+	iconic = (*wstate == IconicState );
+	XFree( (char *)data );
+    }
+    return iconic;
+}
+
+const char *qAppName()				// get application name
+{
+    return appName;
+}
+
+const char *qAppClass()				// get application class
+{
+    return appClass;
+}
+
+Display *qt_xdisplay()				// get current X display
+{
+    return appDpy;
+}
+
+int qt_xscreen()				// get current X screen
+{
+    return appScreen;
+}
+
+// ### REMOVE 4.0
+WId qt_xrootwin()				// get X root window
+{
+    return QPaintDevice::x11AppRootWindow();
+}
+
+WId qt_xrootwin( int scrn )			// get X root window for screen
+{
+    return QPaintDevice::x11AppRootWindow( scrn );
+}
+
+bool qt_nograb()				// application no-grab option
+{
+#if defined(QT_DEBUG)
+    return appNoGrab;
+#else
+    return FALSE;
+#endif
+}
+
+static GC create_gc( int scrn, bool monochrome )
+{
+    GC gc;
+    if ( monochrome ) {
+	Pixmap pm = XCreatePixmap( appDpy, RootWindow( appDpy, scrn ), 8, 8, 1 );
+	gc = XCreateGC( appDpy, pm, 0, 0 );
+	XFreePixmap( appDpy, pm );
+    } else {
+	if ( QPaintDevice::x11AppDefaultVisual( scrn ) ) {
+	    gc = XCreateGC( appDpy, RootWindow( appDpy, scrn ), 0, 0 );
+	} else {
+	    Window w;
+	    XSetWindowAttributes a;
+	    a.background_pixel = Qt::black.pixel( scrn );
+	    a.border_pixel = Qt::black.pixel( scrn );
+	    a.colormap = QPaintDevice::x11AppColormap( scrn );
+	    w = XCreateWindow( appDpy, RootWindow( appDpy, scrn ), 0, 0, 100, 100,
+			       0, QPaintDevice::x11AppDepth( scrn ), InputOutput,
+			       (Visual*)QPaintDevice::x11AppVisual( scrn ),
+			       CWBackPixel|CWBorderPixel|CWColormap, &a );
+	    gc = XCreateGC( appDpy, w, 0, 0 );
+	    XDestroyWindow( appDpy, w );
+	}
+    }
+    XSetGraphicsExposures( appDpy, gc, False );
+    return gc;
+}
+
+GC qt_xget_readonly_gc( int scrn, bool monochrome )	// get read-only GC
+{
+    if ( scrn < 0 || scrn >= appScreenCount ) {
+	qDebug("invalid screen %d %d", scrn, appScreenCount );
+	QWidget* bla = 0;
+	bla->setName("hello");
+    }
+    GC gc;
+    if ( monochrome ) {
+	if ( !app_gc_ro_m )			// create GC for bitmap
+	    memset( (app_gc_ro_m = new GC[appScreenCount]), 0, appScreenCount * sizeof( GC ) );
+	if ( !app_gc_ro_m[scrn] )
+	    app_gc_ro_m[scrn] = create_gc( scrn, TRUE );
+	gc = app_gc_ro_m[scrn];
+    } else {					// create standard GC
+	if ( !app_gc_ro )
+	    memset( (app_gc_ro = new GC[appScreenCount]), 0, appScreenCount * sizeof( GC ) );
+	if ( !app_gc_ro[scrn] )
+	    app_gc_ro[scrn] = create_gc( scrn, FALSE );
+	gc = app_gc_ro[scrn];
+    }
+    return gc;
+}
+
+GC qt_xget_temp_gc( int scrn, bool monochrome )		// get temporary GC
+{
+    if ( scrn < 0 || scrn >= appScreenCount ) {
+	qDebug("invalid screen (tmp) %d %d", scrn, appScreenCount );
+	QWidget* bla = 0;
+	bla->setName("hello");
+    }
+    GC gc;
+    if ( monochrome ) {
+	if ( !app_gc_tmp_m )			// create GC for bitmap
+	    memset( (app_gc_tmp_m = new GC[appScreenCount]), 0, appScreenCount * sizeof( GC ) );
+	if ( !app_gc_tmp_m[scrn] )
+	    app_gc_tmp_m[scrn] = create_gc( scrn, TRUE );
+	gc = app_gc_tmp_m[scrn];
+    } else {					// create standard GC
+	if ( !app_gc_tmp )
+	    memset( (app_gc_tmp = new GC[appScreenCount]), 0, appScreenCount * sizeof( GC ) );
+	if ( !app_gc_tmp[scrn] )
+	    app_gc_tmp[scrn] = create_gc( scrn, FALSE );
+	gc = app_gc_tmp[scrn];
+    }
+    return gc;
+}
+
+
+/*****************************************************************************
+  Platform specific QApplication members
+ *****************************************************************************/
+
+/*!
+    \fn QWidget *QApplication::mainWidget() const
+
+    Returns the main application widget, or 0 if there is no main
+    widget.
+
+    \sa setMainWidget()
+*/
+
+/*!
+    Sets the application's main widget to \a mainWidget.
+
+    In most respects the main widget is like any other widget, except
+    that if it is closed, the application exits. Note that
+    QApplication does \e not take ownership of the \a mainWidget, so
+    if you create your main widget on the heap you must delete it
+    yourself.
+
+    You need not have a main widget; connecting lastWindowClosed() to
+    quit() is an alternative.
+
+    For X11, this function also resizes and moves the main widget
+    according to the \e -geometry command-line option, so you should
+    set the default geometry (using \l QWidget::setGeometry()) before
+    calling setMainWidget().
+
+    \sa mainWidget(), exec(), quit()
+*/
+
+void QApplication::setMainWidget( QWidget *mainWidget )
+{
+#if defined(QT_CHECK_STATE)
+    if ( mainWidget && mainWidget->parentWidget() &&
+	 ! mainWidget->parentWidget()->isDesktop() )
+	qWarning( "QApplication::setMainWidget(): New main widget (%s/%s) "
+		  "has a parent!",
+		  mainWidget->className(), mainWidget->name() );
+#endif
+    main_widget = mainWidget;
+    if ( main_widget ) {			// give WM command line
+	XSetWMProperties( main_widget->x11Display(), main_widget->winId(),
+			  0, 0, app_argv, app_argc, 0, 0, 0 );
+	if ( mwTitle )
+	    XStoreName( main_widget->x11Display(), main_widget->winId(), (char*)mwTitle );
+	if ( mwGeometry ) {			// parse geometry
+	    int x, y;
+	    int w, h;
+	    int m = XParseGeometry( (char*)mwGeometry, &x, &y, (uint*)&w, (uint*)&h );
+	    QSize minSize = main_widget->minimumSize();
+	    QSize maxSize = main_widget->maximumSize();
+	    if ( (m & XValue) == 0 )
+		x = main_widget->geometry().x();
+	    if ( (m & YValue) == 0 )
+		y = main_widget->geometry().y();
+	    if ( (m & WidthValue) == 0 )
+		w = main_widget->width();
+	    if ( (m & HeightValue) == 0 )
+		h = main_widget->height();
+	    w = QMIN(w,maxSize.width());
+	    h = QMIN(h,maxSize.height());
+	    w = QMAX(w,minSize.width());
+	    h = QMAX(h,minSize.height());
+	    if ( (m & XNegative) ) {
+		x = desktop()->width()  + x - w;
+		qt_widget_tlw_gravity = NorthEastGravity;
+	    }
+	    if ( (m & YNegative) ) {
+		y = desktop()->height() + y - h;
+		qt_widget_tlw_gravity = (m & XNegative) ? SouthEastGravity : SouthWestGravity;
+	    }
+	    main_widget->setGeometry( x, y, w, h );
+	}
+    }
+}
+
+#ifndef QT_NO_CURSOR
+
+/*****************************************************************************
+  QApplication cursor stack
+ *****************************************************************************/
+
+extern void qt_x11_enforce_cursor( QWidget * w );
+
+typedef QPtrList<QCursor> QCursorList;
+
+static QCursorList *cursorStack = 0;
+
+/*!
+    \fn QCursor *QApplication::overrideCursor()
+
+    Returns the active application override cursor.
+
+    This function returns 0 if no application cursor has been defined
+    (i.e. the internal cursor stack is empty).
+
+    \sa setOverrideCursor(), restoreOverrideCursor()
+*/
+
+/*!
+    Sets the application override cursor to \a cursor.
+
+    Application override cursors are intended for showing the user
+    that the application is in a special state, for example during an
+    operation that might take some time.
+
+    This cursor will be displayed in all the application's widgets
+    until restoreOverrideCursor() or another setOverrideCursor() is
+    called.
+
+    Application cursors are stored on an internal stack.
+    setOverrideCursor() pushes the cursor onto the stack, and
+    restoreOverrideCursor() pops the active cursor off the stack.
+    Every setOverrideCursor() must eventually be followed by a
+    corresponding restoreOverrideCursor(), otherwise the stack will
+    never be emptied.
+
+    If \a replace is TRUE, the new cursor will replace the last
+    override cursor (the stack keeps its depth). If \a replace is
+    FALSE, the new stack is pushed onto the top of the stack.
+
+    Example:
+    \code
+	QApplication::setOverrideCursor( QCursor(Qt::WaitCursor) );
+	calculateHugeMandelbrot();              // lunch time...
+	QApplication::restoreOverrideCursor();
+    \endcode
+
+    \sa overrideCursor(), restoreOverrideCursor(), QWidget::setCursor()
+*/
+
+void QApplication::setOverrideCursor( const QCursor &cursor, bool replace )
+{
+    if ( !cursorStack ) {
+	cursorStack = new QCursorList;
+	Q_CHECK_PTR( cursorStack );
+	cursorStack->setAutoDelete( TRUE );
+    }
+    app_cursor = new QCursor( cursor );
+    Q_CHECK_PTR( app_cursor );
+    if ( replace )
+	cursorStack->removeLast();
+    cursorStack->append( app_cursor );
+
+    QWidgetIntDictIt it( *((QWidgetIntDict*)QWidget::mapper) );
+    register QWidget *w;
+    while ( (w=it.current()) ) {		// for all widgets that have
+	if ( w->testWState( WState_OwnCursor ) )
+	    qt_x11_enforce_cursor( w );
+	++it;
+    }
+    XFlush( appDpy );				// make X execute it NOW
+}
+
+/*!
+    Undoes the last setOverrideCursor().
+
+    If setOverrideCursor() has been called twice, calling
+    restoreOverrideCursor() will activate the first cursor set.
+    Calling this function a second time restores the original widgets'
+    cursors.
+
+    \sa setOverrideCursor(), overrideCursor().
+*/
+
+void QApplication::restoreOverrideCursor()
+{
+    if ( !cursorStack )				// no cursor stack
+	return;
+    cursorStack->removeLast();
+    app_cursor = cursorStack->last();
+    if ( QWidget::mapper != 0 && !closingDown() ) {
+	QWidgetIntDictIt it( *((QWidgetIntDict*)QWidget::mapper) );
+	register QWidget *w;
+	while ( (w=it.current()) ) {		// set back to original cursors
+	    if ( w->testWState( WState_OwnCursor ) )
+		qt_x11_enforce_cursor( w );
+	    ++it;
+	}
+	XFlush( appDpy );
+    }
+    if ( !app_cursor ) {
+	delete cursorStack;
+	cursorStack = 0;
+    }
+}
+
+#endif
+
+/*!
+    \fn bool QApplication::hasGlobalMouseTracking()
+
+    Returns TRUE if global mouse tracking is enabled; otherwise
+    returns FALSE.
+
+    \sa setGlobalMouseTracking()
+*/
+
+/*!
+    Enables global mouse tracking if \a enable is TRUE, or disables it
+    if \a enable is FALSE.
+
+    Enabling global mouse tracking makes it possible for widget event
+    filters or application event filters to get all mouse move events,
+    even when no button is depressed. This is useful for special GUI
+    elements, e.g. tooltips.
+
+    Global mouse tracking does not affect widgets and their
+    mouseMoveEvent(). For a widget to get mouse move events when no
+    button is depressed, it must do QWidget::setMouseTracking(TRUE).
+
+    This function uses an internal counter. Each
+    setGlobalMouseTracking(TRUE) must have a corresponding
+    setGlobalMouseTracking(FALSE):
+    \code
+	// at this point global mouse tracking is off
+	QApplication::setGlobalMouseTracking( TRUE );
+	QApplication::setGlobalMouseTracking( TRUE );
+	QApplication::setGlobalMouseTracking( FALSE );
+	// at this point it's still on
+	QApplication::setGlobalMouseTracking( FALSE );
+	// but now it's off
+    \endcode
+
+    \sa hasGlobalMouseTracking(), QWidget::hasMouseTracking()
+*/
+
+void QApplication::setGlobalMouseTracking( bool enable )
+{
+    bool tellAllWidgets;
+    if ( enable ) {
+	tellAllWidgets = (++app_tracking == 1);
+    } else {
+	tellAllWidgets = (--app_tracking == 0);
+    }
+    if ( tellAllWidgets ) {
+	QWidgetIntDictIt it( *((QWidgetIntDict*)QWidget::mapper) );
+	register QWidget *w;
+	while ( (w=it.current()) ) {
+	    if ( app_tracking > 0 ) {		// switch on
+		if ( !w->testWState(WState_MouseTracking) ) {
+		    w->setMouseTracking( TRUE );
+		    w->clearWState( WState_MouseTracking );
+		}
+	    } else {				// switch off
+		if ( !w->testWState(WState_MouseTracking) ) {
+		    w->setWState( WState_MouseTracking );
+		    w->setMouseTracking( FALSE );
+		}
+	    }
+	    ++it;
+	}
+    }
+}
+
+
+/*****************************************************************************
+  Routines to find a Qt widget from a screen position
+ *****************************************************************************/
+
+Window qt_x11_findClientWindow( Window win, Atom property, bool leaf )
+{
+    Atom   type = None;
+    int	   format, i;
+    ulong  nitems, after;
+    uchar *data;
+    Window root, parent, target=0, *children=0;
+    uint   nchildren;
+    if ( XGetWindowProperty( appDpy, win, property, 0, 0, FALSE, AnyPropertyType,
+			     &type, &format, &nitems, &after, &data ) == Success ) {
+	if ( data )
+	    XFree( (char *)data );
+	if ( type )
+	    return win;
+    }
+    if ( !XQueryTree(appDpy,win,&root,&parent,&children,&nchildren) ) {
+	if ( children )
+	    XFree( (char *)children );
+	return 0;
+    }
+    for ( i=nchildren-1; !target && i >= 0; i-- )
+	target = qt_x11_findClientWindow( children[i], property, leaf );
+    if ( children )
+	XFree( (char *)children );
+    return target;
+}
+
+
+/*!
+    Returns a pointer to the widget at global screen position \a
+    (x, y), or 0 if there is no Qt widget there.
+
+    If \a child is FALSE and there is a child widget at position \a
+    (x, y), the top-level widget containing it is returned. If \a child
+    is TRUE the child widget at position \a (x, y) is returned.
+
+    This function is normally rather slow.
+
+    \sa QCursor::pos(), QWidget::grabMouse(), QWidget::grabKeyboard()
+*/
+
+QWidget *QApplication::widgetAt( int x, int y, bool child )
+{
+    int screen = QCursor::x11Screen();
+    int lx, ly;
+
+    Window target;
+    if ( !XTranslateCoordinates(appDpy,
+				QPaintDevice::x11AppRootWindow(screen),
+				QPaintDevice::x11AppRootWindow(screen),
+				x, y, &lx, &ly, &target) ) {
+	return 0;
+    }
+    if ( !target || target == QPaintDevice::x11AppRootWindow(screen) )
+	return 0;
+    QWidget *w, *c;
+    w = QWidget::find( (WId)target );
+
+    if ( !w ) {
+	qt_ignore_badwindow();
+	target = qt_x11_findClientWindow( target, qt_wm_state, TRUE );
+	if (qt_badwindow() )
+	    return 0;
+	w = QWidget::find( (WId)target );
+#if 0
+	if ( !w ) {
+	    // Perhaps the widgets at (x,y) is inside a foreign application?
+	    // Search all toplevel widgets to see if one is within target
+	    QWidgetList *list   = topLevelWidgets();
+	    QWidget     *widget = list->first();
+	    while ( widget && !w ) {
+		Window	ctarget = target;
+		if ( widget->isVisible() && !widget->isDesktop() ) {
+		    Window wid = widget->winId();
+		    while ( ctarget && !w ) {
+			XTranslateCoordinates(appDpy,
+					      QPaintDevice::x11AppRootWindow(screen),
+					      ctarget, x, y, &lx, &ly, &ctarget);
+			if ( ctarget == wid ) {
+			    // Found
+			    w = widget;
+			    XTranslateCoordinates(appDpy,
+						  QPaintDevice::x11AppRootWindow(screen),
+						  ctarget, x, y, &lx, &ly, &ctarget);
+			}
+		    }
+		}
+		widget = list->next();
+	    }
+	    delete list;
+	}
+#endif
+    }
+    if ( child && w ) {
+	if ( (c = w->childAt( w->mapFromGlobal(QPoint(x, y ) ) ) ) )
+	    return c;
+    }
+    return w;
+}
+
+/*!
+    \overload QWidget *QApplication::widgetAt( const QPoint &pos, bool child )
+
+    Returns a pointer to the widget at global screen position \a pos,
+    or 0 if there is no Qt widget there.
+
+    If \a child is FALSE and there is a child widget at position \a
+    pos, the top-level widget containing it is returned. If \a child
+    is TRUE the child widget at position \a pos is returned.
+*/
+
+
+/*!
+    Flushes the X event queue in the X11 implementation. This normally
+    returns almost immediately. Does nothing on other platforms.
+
+    \sa syncX()
+*/
+
+void QApplication::flushX()
+{
+    if ( appDpy )
+	XFlush( appDpy );
+}
+
+/*!
+    Flushes the window system specific event queues.
+
+    If you are doing graphical changes inside a loop that does not
+    return to the event loop on asynchronous window systems like X11
+    or double buffered window systems like MacOS X, and you want to
+    visualize these changes immediately (e.g. Splash Screens), call
+    this function.
+
+    \sa flushX() sendPostedEvents() QPainter::flush()
+*/
+
+void QApplication::flush()
+{
+    flushX();
+}
+
+/*!
+    Synchronizes with the X server in the X11 implementation. This
+    normally takes some time. Does nothing on other platforms.
+
+    \sa flushX()
+*/
+
+void QApplication::syncX()
+{
+    if ( appDpy )
+	XSync( appDpy, False );			// don't discard events
+}
+
+
+/*!
+    Sounds the bell, using the default volume and sound.
+*/
+
+void QApplication::beep()
+{
+    if ( appDpy )
+	XBell( appDpy, 0 );
+}
+
+
+
+/*****************************************************************************
+  Special lookup functions for windows that have been reparented recently
+ *****************************************************************************/
+
+static QWidgetIntDict *wPRmapper = 0;		// alternative widget mapper
+
+void qPRCreate( const QWidget *widget, Window oldwin )
+{						// QWidget::reparent mechanism
+    if ( !wPRmapper ) {
+	wPRmapper = new QWidgetIntDict;
+	Q_CHECK_PTR( wPRmapper );
+    }
+    wPRmapper->insert( (long)oldwin, widget );	// add old window to mapper
+    QETWidget *w = (QETWidget *)widget;
+    w->setWState( Qt::WState_Reparented );	// set reparented flag
+}
+
+void qPRCleanup( QWidget *widget )
+{
+    QETWidget *etw = (QETWidget *)widget;
+    if ( !(wPRmapper && etw->testWState(Qt::WState_Reparented)) )
+	return;					// not a reparented widget
+    QWidgetIntDictIt it(*wPRmapper);
+    QWidget *w;
+    while ( (w=it.current()) ) {
+	int key = it.currentKey();
+	++it;
+	if ( w == etw ) {                       // found widget
+	    etw->clearWState( Qt::WState_Reparented ); // clear flag
+	    wPRmapper->remove( key );// old window no longer needed
+	    if ( wPRmapper->count() == 0 ) {	// became empty
+		delete wPRmapper;		// then reset alt mapper
+		wPRmapper = 0;
+		return;
+	    }
+	}
+    }
+}
+
+static QETWidget *qPRFindWidget( Window oldwin )
+{
+    return wPRmapper ? (QETWidget*)wPRmapper->find((long)oldwin) : 0;
+}
+
+/*!
+    \internal
+*/
+int QApplication::x11ClientMessage(QWidget* w, XEvent* event, bool passive_only)
+{
+    QETWidget *widget = (QETWidget*)w;
+    if ( event->xclient.format == 32 && event->xclient.message_type ) {
+	if ( event->xclient.message_type == qt_wm_protocols ) {
+	    Atom a = event->xclient.data.l[0];
+	    if ( a == qt_wm_delete_window ) {
+		if ( passive_only ) return 0;
+		widget->translateCloseEvent(event);
+	    }
+	    else if ( a == qt_wm_take_focus ) {
+		QWidget * amw = activeModalWidget();
+		if ( (ulong) event->xclient.data.l[1] > qt_x_time )
+		    qt_x_time = event->xclient.data.l[1];
+		if ( amw && amw != widget ) {
+		    QWidget* groupLeader = widget;
+		    while ( groupLeader && !groupLeader->testWFlags( Qt::WGroupLeader ) )
+			groupLeader = groupLeader->parentWidget();
+		    if ( !groupLeader ) {
+			if ( ! qt_net_supported_list )
+			    amw->raise(); // help broken window managers
+			amw->setActiveWindow();
+		    }
+		}
+#ifndef QT_NO_WHATSTHIS
+	    } else if ( a == qt_net_wm_context_help ) {
+		QWhatsThis::enterWhatsThisMode();
+#endif // QT_NO_WHATSTHIS
+	    } else if ( a == qt_net_wm_ping ) {
+		// avoid send/reply loops
+		Window root = QPaintDevice::x11AppRootWindow( w->x11Screen() );
+		if (event->xclient.window != root) {
+		    event->xclient.window = root;
+		    XSendEvent( event->xclient.display, event->xclient.window,
+				False, SubstructureNotifyMask|SubstructureRedirectMask, event );
+		}
+	    }
+	} else if ( event->xclient.message_type == qt_qt_scrolldone ) {
+	    widget->translateScrollDoneEvent(event);
+	} else if ( event->xclient.message_type == qt_xdnd_position ) {
+	    qt_handle_xdnd_position( widget, event, passive_only );
+	} else if ( event->xclient.message_type == qt_xdnd_enter ) {
+	    qt_handle_xdnd_enter( widget, event, passive_only );
+	} else if ( event->xclient.message_type == qt_xdnd_status ) {
+	    qt_handle_xdnd_status( widget, event, passive_only );
+	} else if ( event->xclient.message_type == qt_xdnd_leave ) {
+	    qt_handle_xdnd_leave( widget, event, passive_only );
+	} else if ( event->xclient.message_type == qt_xdnd_drop ) {
+	    qt_handle_xdnd_drop( widget, event, passive_only );
+	} else if ( event->xclient.message_type == qt_xdnd_finished ) {
+	    qt_handle_xdnd_finished( widget, event, passive_only );
+	} else {
+	    if ( passive_only ) return 0;
+	    // All other are interactions
+	}
+    } else {
+	qt_motifdnd_handle_msg( widget, event, passive_only );
+    }
+
+    return 0;
+}
+
+/*!
+    This function does the core processing of individual X
+    \a{event}s, normally by dispatching Qt events to the right
+    destination.
+
+    It returns 1 if the event was consumed by special handling, 0 if
+    the \a event was consumed by normal handling, and -1 if the \a
+    event was for an unrecognized widget.
+
+    \sa x11EventFilter()
+*/
+int QApplication::x11ProcessEvent( XEvent* event )
+{
+    switch ( event->type ) {
+    case ButtonPress:
+	ignoreNextMouseReleaseEvent = FALSE;
+	qt_x_user_time = event->xbutton.time;
+	// fallthrough intended
+    case ButtonRelease:
+	qt_x_time = event->xbutton.time;
+	break;
+    case MotionNotify:
+	qt_x_time = event->xmotion.time;
+	break;
+    case XKeyPress:
+	qt_x_user_time = event->xkey.time;
+	// fallthrough intended
+    case XKeyRelease:
+	qt_x_time = event->xkey.time;
+	break;
+    case PropertyNotify:
+	qt_x_time = event->xproperty.time;
+	break;
+    case EnterNotify:
+    case LeaveNotify:
+	qt_x_time = event->xcrossing.time;
+	break;
+    case SelectionClear:
+	qt_x_time = event->xselectionclear.time;
+	break;
+    default:
+	break;
+    }
+
+    QETWidget *widget = (QETWidget*)QWidget::find( (WId)event->xany.window );
+
+    if ( wPRmapper ) {				// just did a widget reparent?
+	if ( widget == 0 ) {			// not in std widget mapper
+	    switch ( event->type ) {		// only for mouse/key events
+	    case ButtonPress:
+	    case ButtonRelease:
+	    case MotionNotify:
+	    case XKeyPress:
+	    case XKeyRelease:
+		widget = qPRFindWidget( event->xany.window );
+		break;
+	    }
+	}
+	else if ( widget->testWState(WState_Reparented) )
+	    qPRCleanup( widget );		// remove from alt mapper
+    }
+
+    QETWidget *keywidget=0;
+    bool grabbed=FALSE;
+    if ( event->type==XKeyPress || event->type==XKeyRelease ) {
+	keywidget = (QETWidget*)QWidget::keyboardGrabber();
+	if ( keywidget ) {
+	    grabbed = TRUE;
+	} else {
+	    if ( focus_widget )
+		keywidget = (QETWidget*)focus_widget;
+	    if ( !keywidget ) {
+		if ( inPopupMode() ) // no focus widget, see if we have a popup
+		    keywidget = (QETWidget*) activePopupWidget();
+		else if ( widget )
+		    keywidget = (QETWidget*)widget->topLevelWidget();
+	    }
+	}
+    }
+
+    int xkey_keycode = event->xkey.keycode;
+    if ( XFilterEvent( event,
+		       keywidget ? keywidget->topLevelWidget()->winId() : None ) ) {
+	if ( keywidget )
+	    composingKeycode = xkey_keycode; // ### not documented in xlib
+
+#ifndef QT_NO_XIM
+ 	if ( event->type != XKeyPress || ! (qt_xim_style & XIMPreeditCallbacks) )
+	    return 1;
+
+	/*
+	 * The Solaris htt input method will transform a ClientMessage
+	 * event into a filtered KeyPress event, in which case our
+	 * keywidget is still zero.
+	 */
+        if ( ! keywidget ) {
+ 	    keywidget = (QETWidget*)QWidget::keyboardGrabber();
+	    if ( keywidget ) {
+	        grabbed = TRUE;
+	    } else {
+	        if ( focus_widget )
+		    keywidget = (QETWidget*)focus_widget;
+	        if ( !keywidget ) {
+		    if ( inPopupMode() ) // no focus widget, see if we have a popup
+		        keywidget = (QETWidget*) activePopupWidget();
+		    else if ( widget )
+		        keywidget = (QETWidget*)widget->topLevelWidget();
+	        }
+	    }
+        }
+
+	/*
+	  if the composition string has been emptied, we need to send
+	  an IMEnd event.  however, we have no way to tell if the user
+	  has cancelled input, or if the user has accepted the
+	  composition.
+
+	  so, we have to look for the next keypress and see if it is
+	  the 'commit' key press (keycode == 0).  if it is, we deliver
+	  an IMEnd event with the final text, otherwise we deliver an
+	  IMEnd with empty text (meaning the user has cancelled the
+	  input).
+	*/
+	QInputContext *qic =
+	    (QInputContext *) keywidget->topLevelWidget()->topData()->xic;
+	extern bool qt_compose_emptied; // qinputcontext_x11.cpp
+	if ( qic && qic->composing && qic->focusWidget && qt_compose_emptied ) {
+	    XEvent event2;
+	    bool found = FALSE;
+	    if ( XCheckTypedEvent( QPaintDevice::x11AppDisplay(),
+				   XKeyPress, &event2 ) ) {
+		if ( event2.xkey.keycode == 0 ) {
+		    // found a key event with the 'commit' string
+		    found = TRUE;
+		    XPutBackEvent( QPaintDevice::x11AppDisplay(), &event2 );
+		}
+	    }
+
+	    if ( !found ) {
+		// no key event, so the user must have cancelled the composition
+		QIMEvent endevent( QEvent::IMEnd, QString::null, -1 );
+		QApplication::sendEvent( qic->focusWidget, &endevent );
+
+		qic->focusWidget = 0;
+	    }
+
+	    qt_compose_emptied = FALSE;
+	}
+#endif // QT_NO_XIM
+
+	return 1;
+    }
+
+    if ( qt_x11EventFilter(event) )		// send through app filter
+	return 1;
+
+    if ( event->type == MappingNotify ) {	// keyboard mapping changed
+	XRefreshKeyboardMapping( &event->xmapping );
+	return 0;
+    }
+
+    if ( event->type == PropertyNotify ) {	// some properties changed
+	if ( event->xproperty.window == QPaintDevice::x11AppRootWindow( 0 ) ) {
+	    // root properties for the first screen
+	    if ( event->xproperty.atom == qt_clipboard_sentinel ) {
+		if (qt_check_clipboard_sentinel() )
+		    emit clipboard()->dataChanged();
+	    } else if ( event->xproperty.atom == qt_selection_sentinel ) {
+		if (qt_check_selection_sentinel() )
+		    emit clipboard()->selectionChanged();
+	    } else if ( obey_desktop_settings ) {
+		if ( event->xproperty.atom == qt_resource_manager )
+		    qt_set_x11_resources();
+		else if ( event->xproperty.atom == qt_settings_timestamp )
+		    QApplication::x11_apply_settings();
+	    }
+	}
+	if ( event->xproperty.window == QPaintDevice::x11AppRootWindow() ) {
+	    // root properties for the default screen
+	    if ( event->xproperty.atom == qt_input_encoding ) {
+		qt_set_input_encoding();
+	    } else if ( event->xproperty.atom == qt_net_supported ) {
+		qt_get_net_supported();
+	    } else if ( event->xproperty.atom == qt_net_virtual_roots ) {
+		qt_get_net_virtual_roots();
+	    } else if ( event->xproperty.atom == qt_net_workarea ) {
+		qt_desktopwidget_update_workarea();
+	    }
+	} else if ( widget ) {
+	    widget->translatePropertyEvent(event);
+	}  else {
+	    return -1; // don't know this window
+	}
+	return 0;
+    }
+
+    if ( !widget ) {				// don't know this windows
+	QWidget* popup = QApplication::activePopupWidget();
+	if ( popup ) {
+
+	    /*
+	      That is more than suboptimal. The real solution should
+	      do some keyevent and buttonevent translation, so that
+	      the popup still continues to work as the user expects.
+	      Unfortunately this translation is currently only
+	      possible with a known widget. I'll change that soon
+	      (Matthias).
+	    */
+
+	    // Danger - make sure we don't lock the server
+	    switch ( event->type ) {
+	    case ButtonPress:
+	    case ButtonRelease:
+	    case XKeyPress:
+	    case XKeyRelease:
+		do {
+		    popup->close();
+		} while ( (popup = qApp->activePopupWidget()) );
+		return 1;
+	    }
+	}
+	return -1;
+    }
+
+    if ( event->type == XKeyPress || event->type == XKeyRelease )
+	widget = keywidget; // send XKeyEvents through keywidget->x11Event()
+
+    if ( app_do_modal )				// modal event handling
+	if ( !qt_try_modal(widget, event) ) {
+	    if ( event->type == ClientMessage )
+		x11ClientMessage( widget, event, TRUE );
+	    return 1;
+	}
+
+
+    if ( widget->x11Event(event) )		// send through widget filter
+	return 1;
+#if defined (QT_TABLET_SUPPORT)
+    if ( event->type == xinput_motion ||
+	 event->type == xinput_button_release ||
+	 event->type == xinput_button_press ) {
+	widget->translateXinputEvent( event );
+	return 0;
+    }
+#endif
+
+#ifndef QT_NO_XRANDR
+    if (event->type == xrandr_eventbase + RRScreenChangeNotify) {
+	// update Xlib internals with the latest screen configuration
+	XRRUpdateConfiguration(event);
+
+	// update the size for desktop widget
+	int scr = XRRRootToScreen( appDpy, event->xany.window );
+	QWidget *w = desktop()->screen( scr );
+	QSize oldSize( w->size() );
+	w->crect.setWidth( DisplayWidth( appDpy, scr ) );
+        w->crect.setHeight( DisplayHeight( appDpy, scr ) );
+	if ( w->size() != oldSize ) {
+	    QResizeEvent e( w->size(), oldSize );
+	    QApplication::sendEvent( w, &e );
+	    emit desktop()->resized( scr );
+	}
+    }
+#endif // QT_NO_XRANDR
+
+    switch ( event->type ) {
+
+    case ButtonRelease:			// mouse event
+	if ( ignoreNextMouseReleaseEvent ) {
+	    ignoreNextMouseReleaseEvent = FALSE;
+	    break;
+	}
+	// fall through intended
+    case ButtonPress:
+	if (event->xbutton.root != RootWindow(widget->x11Display(), widget->x11Screen())
+	    && ! qt_xdnd_dragging) {
+	    while ( activePopupWidget() )
+		activePopupWidget()->close();
+	    return 1;
+	}
+	if (event->type == ButtonPress)
+	    qt_net_update_user_time(widget->topLevelWidget());
+	// fall through intended
+    case MotionNotify:
+#if defined(QT_TABLET_SUPPORT)
+	if ( !chokeMouse ) {
+#endif
+	    widget->translateMouseEvent( event );
+#if defined(QT_TABLET_SUPPORT)
+	} else {
+	    chokeMouse = FALSE;
+	}
+#endif
+	break;
+
+    case XKeyPress:				// keyboard event
+	qt_net_update_user_time(widget->topLevelWidget());
+	// fallthrough intended
+    case XKeyRelease:
+	{
+	    if ( keywidget && keywidget->isEnabled() ) { // should always exist
+#ifndef QT_NO_XIM
+		QInputContext *qic =
+		    (QInputContext *) keywidget->topLevelWidget()->topData()->xic;
+
+		if ((qt_xim_style & XIMPreeditCallbacks) && event->xkey.keycode == 0 &&
+		    qic && qic->composing && qic->focusWidget) {
+		    // input method has sent us a commit string
+		    QCString data(513);
+		    KeySym sym;    // unused
+		    Status status; // unused
+		    QString text;
+		    int count = qic->lookupString( &(event->xkey), data,
+						   &sym, &status );
+		    if ( count > 0 )
+			text = input_mapper->toUnicode( data, count );
+
+		    // qDebug( "sending IMEnd with %d chars", text.length() );
+		    QIMEvent endevent( QEvent::IMEnd, text, -1 );
+		    QApplication::sendEvent( qic->focusWidget, &endevent );
+
+		    qic->focusWidget = 0;
+		    qic->text = QString::null;
+		} else
+#endif // !QT_NO_XIM
+		    {
+			// qDebug( "sending key event" );
+			keywidget->translateKeyEvent( event, grabbed );
+		    }
+	    }
+	    break;
+	}
+
+    case GraphicsExpose:
+    case Expose:				// paint event
+	widget->translatePaintEvent( event );
+	break;
+
+    case ConfigureNotify:			// window move/resize event
+	if ( event->xconfigure.event == event->xconfigure.window )
+	    widget->translateConfigEvent( event );
+	break;
+
+    case XFocusIn: {				// got focus
+	if ( widget->isDesktop() )
+	    break;
+	if ( inPopupMode() ) // some delayed focus event to ignore
+	    break;
+	if ( !widget->isTopLevel() )
+	    break;
+	if ( event->xfocus.detail != NotifyAncestor &&
+	     event->xfocus.detail != NotifyInferior &&
+	     event->xfocus.detail != NotifyNonlinear )
+	    break;
+	widget->createInputContext();
+	setActiveWindow( widget );
+	if ( qt_focus_model == FocusModel_PointerRoot ) {
+	    // We got real input focus from somewhere, but we were in PointerRoot
+	    // mode, so we don't trust this event.  Check the focus model to make
+	    // sure we know what focus mode we are using...
+	    qt_check_focus_model();
+	}
+    }
+	break;
+
+    case XFocusOut:				// lost focus
+	if ( widget->isDesktop() )
+	    break;
+	if ( !widget->isTopLevel() )
+	    break;
+	if ( event->xfocus.mode == NotifyGrab )
+	    qt_xfocusout_grab_counter++;
+	if ( event->xfocus.mode != NotifyNormal )
+	    break;
+	if ( event->xfocus.detail != NotifyAncestor &&
+	     event->xfocus.detail != NotifyNonlinearVirtual &&
+	     event->xfocus.detail != NotifyNonlinear )
+	    break;
+	if ( !inPopupMode() && widget == active_window )
+	    setActiveWindow( 0 );
+	break;
+
+    case EnterNotify: {			// enter window
+	if ( QWidget::mouseGrabber()  && widget != QWidget::mouseGrabber() )
+	    break;
+	if ( inPopupMode() && widget->topLevelWidget() != activePopupWidget() )
+	    break;
+	if ( event->xcrossing.mode != NotifyNormal ||
+	     event->xcrossing.detail == NotifyVirtual  ||
+	     event->xcrossing.detail == NotifyNonlinearVirtual )
+	    break;
+	if ( event->xcrossing.focus &&
+	     !widget->isDesktop() && !widget->isActiveWindow() ) {
+	    if ( qt_focus_model == FocusModel_Unknown ) // check focus model
+		qt_check_focus_model();
+	    if ( qt_focus_model == FocusModel_PointerRoot ) // PointerRoot mode
+		setActiveWindow( widget );
+	}
+	qt_dispatchEnterLeave( widget, QWidget::find( curWin ) );
+	curWin = widget->winId();
+	widget->translateMouseEvent( event ); //we don't get MotionNotify, emulate it
+    }
+	break;
+
+    case LeaveNotify: {			// leave window
+	if ( QWidget::mouseGrabber()  && widget != QWidget::mouseGrabber() )
+	    break;
+	if ( curWin && widget->winId() != curWin )
+	    break;
+	if ( event->xcrossing.mode != NotifyNormal )
+	    break;
+	if ( !widget->isDesktop() )
+	    widget->translateMouseEvent( event ); //we don't get MotionNotify, emulate it
+
+	QWidget* enter = 0;
+	XEvent ev;
+	while ( XCheckMaskEvent( widget->x11Display(), EnterWindowMask | LeaveWindowMask , &ev )
+		&& !qt_x11EventFilter( &ev )) {
+            QWidget* event_widget = QWidget::find( ev.xcrossing.window );
+            if( event_widget && event_widget->x11Event( &ev ) )
+                break;
+	    if ( ev.type == LeaveNotify && ev.xcrossing.mode == NotifyNormal ){
+		enter = event_widget;
+		XPutBackEvent( widget->x11Display(), &ev );
+		break;
+	    }
+	    if (  ev.xcrossing.mode != NotifyNormal ||
+		  ev.xcrossing.detail == NotifyVirtual  ||
+		  ev.xcrossing.detail == NotifyNonlinearVirtual )
+		continue;
+	    enter = event_widget;
+	    if ( ev.xcrossing.focus &&
+		 enter && !enter->isDesktop() && !enter->isActiveWindow() ) {
+		if ( qt_focus_model == FocusModel_Unknown ) // check focus model
+		    qt_check_focus_model();
+		if ( qt_focus_model == FocusModel_PointerRoot ) // PointerRoot mode
+		    setActiveWindow( enter );
+	    }
+	    break;
+	}
+
+	if ( ( ! enter || enter->isDesktop() ) &&
+	     event->xcrossing.focus && widget == active_window &&
+	     qt_focus_model == FocusModel_PointerRoot // PointerRoot mode
+	     ) {
+	    setActiveWindow( 0 );
+	}
+
+	if ( !curWin )
+	    qt_dispatchEnterLeave( widget, 0 );
+
+	qt_dispatchEnterLeave( enter, widget );
+	curWin = enter ? enter->winId() : 0;
+    }
+	break;
+
+    case UnmapNotify:				// window hidden
+	if ( widget->isTopLevel() && widget->isShown() ) {
+	    widget->topData()->spont_unmapped = 1;
+	    QHideEvent e;
+	    QApplication::sendSpontaneousEvent( widget, &e );
+	    widget->hideChildren( TRUE );
+	}
+	break;
+
+    case MapNotify:				// window shown
+	if ( widget->isTopLevel() &&
+	     widget->topData()->spont_unmapped ) {
+	    widget->topData()->spont_unmapped = 0;
+	    widget->showChildren( TRUE );
+	    QShowEvent e;
+	    QApplication::sendSpontaneousEvent( widget, &e );
+	}
+	break;
+
+    case ClientMessage:			// client message
+	return x11ClientMessage(widget,event,False);
+
+    case ReparentNotify:			// window manager reparents
+	while ( XCheckTypedWindowEvent( widget->x11Display(),
+					widget->winId(),
+					ReparentNotify,
+					event ) )
+	    ;	// skip old reparent events
+	if ( event->xreparent.parent == QPaintDevice::x11AppRootWindow() ) {
+	    if ( widget->isTopLevel() ) {
+		widget->topData()->parentWinId = event->xreparent.parent;
+		if ( qt_deferred_map_contains( widget ) ) {
+		    qt_deferred_map_take( widget );
+		    XMapWindow( appDpy, widget->winId() );
+		}
+	    }
+	} else
+	    // store the parent. Useful for many things, embedding for instance.
+	    widget->topData()->parentWinId = event->xreparent.parent;
+	if ( widget->isTopLevel() ) {
+	    // the widget frame strut should also be invalidated
+	    widget->topData()->fleft = widget->topData()->fright =
+	     widget->topData()->ftop = widget->topData()->fbottom = 0;
+
+	    if ( qt_focus_model != FocusModel_Unknown ) {
+		// toplevel reparented...
+		QWidget *newparent = QWidget::find( event->xreparent.parent );
+		if ( ! newparent || newparent->isDesktop() ) {
+		    // we dont' know about the new parent (or we've been
+		    // reparented to root), perhaps a window manager
+		    // has been (re)started?  reset the focus model to unknown
+		    qt_focus_model = FocusModel_Unknown;
+		}
+	    }
+	}
+	break;
+
+    case SelectionRequest: {
+	XSelectionRequestEvent *req = &event->xselectionrequest;
+	if (! req)
+	    break;
+
+	if ( qt_xdnd_selection && req->selection == qt_xdnd_selection ) {
+	    qt_xdnd_handle_selection_request( req );
+
+	} else if (qt_clipboard) {
+	    QCustomEvent e( QEvent::Clipboard, event );
+	    QApplication::sendSpontaneousEvent( qt_clipboard, &e );
+	}
+	break;
+    }
+    case SelectionClear: {
+	XSelectionClearEvent *req = &event->xselectionclear;
+	// don't deliver dnd events to the clipboard, it gets confused
+	if (! req || qt_xdnd_selection && req->selection == qt_xdnd_selection)
+	    break;
+
+	if (qt_clipboard) {
+	    QCustomEvent e( QEvent::Clipboard, event );
+	    QApplication::sendSpontaneousEvent( qt_clipboard, &e );
+	}
+	break;
+    }
+
+    case SelectionNotify: {
+	XSelectionEvent *req = &event->xselection;
+	// don't deliver dnd events to the clipboard, it gets confused
+	if (! req || qt_xdnd_selection && req->selection == qt_xdnd_selection)
+	    break;
+
+	if (qt_clipboard) {
+	    QCustomEvent e( QEvent::Clipboard, event );
+	    QApplication::sendSpontaneousEvent( qt_clipboard, &e );
+	}
+	break;
+    }
+
+    default:
+	break;
+    }
+
+    return 0;
+}
+
+/*!
+    This virtual function is only implemented under X11.
+
+    If you create an application that inherits QApplication and
+    reimplement this function, you get direct access to all X events
+    that the are received from the X server.
+
+    Return TRUE if you want to stop the event from being processed.
+    Return FALSE for normal event dispatching.
+
+    \sa x11ProcessEvent()
+*/
+
+bool QApplication::x11EventFilter( XEvent * )
+{
+    return FALSE;
+}
+
+
+
+/*****************************************************************************
+  Modal widgets; Since Xlib has little support for this we roll our own
+  modal widget mechanism.
+  A modal widget without a parent becomes application-modal.
+  A modal widget with a parent becomes modal to its parent and grandparents..
+
+  qt_enter_modal()
+	Enters modal state
+	Arguments:
+	    QWidget *widget	A modal widget
+
+  qt_leave_modal()
+	Leaves modal state for a widget
+	Arguments:
+	    QWidget *widget	A modal widget
+ *****************************************************************************/
+
+bool qt_modal_state()
+{
+    return app_do_modal;
+}
+
+void qt_enter_modal( QWidget *widget )
+{
+    if ( !qt_modal_stack ) {			// create modal stack
+	qt_modal_stack = new QWidgetList;
+	Q_CHECK_PTR( qt_modal_stack );
+    }
+    if (widget->parentWidget()) {
+	QEvent e(QEvent::WindowBlocked);
+	QApplication::sendEvent(widget->parentWidget(), &e);
+    }
+
+    qt_dispatchEnterLeave( 0, QWidget::find((WId)curWin) );
+    qt_modal_stack->insert( 0, widget );
+    app_do_modal = TRUE;
+    curWin = 0;
+    ignoreNextMouseReleaseEvent = FALSE;
+}
+
+
+void qt_leave_modal( QWidget *widget )
+{
+    if ( qt_modal_stack && qt_modal_stack->removeRef(widget) ) {
+	if ( qt_modal_stack->isEmpty() ) {
+	    delete qt_modal_stack;
+	    qt_modal_stack = 0;
+	    QPoint p( QCursor::pos() );
+	    QWidget* w = QApplication::widgetAt( p.x(), p.y(), TRUE );
+	    qt_dispatchEnterLeave( w, QWidget::find( curWin ) ); // send synthetic enter event
+	    curWin = w? w->winId() : 0;
+	}
+    }
+    app_do_modal = qt_modal_stack != 0;
+    ignoreNextMouseReleaseEvent = TRUE;
+
+    if (widget->parentWidget()) {
+	QEvent e(QEvent::WindowUnblocked);
+	QApplication::sendEvent(widget->parentWidget(), &e);
+    }
+}
+
+
+bool qt_try_modal( QWidget *widget, XEvent *event )
+{
+    if (qt_xdnd_dragging) {
+	// allow mouse events while DnD is active
+	switch (event->type) {
+	case ButtonPress:
+	case ButtonRelease:
+	case MotionNotify:
+	    return TRUE;
+	default:
+	    break;
+	}
+    }
+
+    if ( qt_tryModalHelper( widget ) )
+	return TRUE;
+
+    bool block_event  = FALSE;
+    switch ( event->type ) {
+	case ButtonPress:			// disallow mouse/key events
+	case ButtonRelease:
+	case MotionNotify:
+	case XKeyPress:
+	case XKeyRelease:
+	case EnterNotify:
+	case LeaveNotify:
+	case ClientMessage:
+	    block_event	 = TRUE;
+	    break;
+    	default:
+            break;
+    }
+
+    return !block_event;
+}
+
+
+/*****************************************************************************
+  Popup widget mechanism
+
+  openPopup()
+	Adds a widget to the list of popup widgets
+	Arguments:
+	    QWidget *widget	The popup widget to be added
+
+  closePopup()
+	Removes a widget from the list of popup widgets
+	Arguments:
+	    QWidget *widget	The popup widget to be removed
+ *****************************************************************************/
+
+
+static int openPopupCount = 0;
+void QApplication::openPopup( QWidget *popup )
+{
+    openPopupCount++;
+    if ( !popupWidgets ) {			// create list
+	popupWidgets = new QWidgetList;
+	Q_CHECK_PTR( popupWidgets );
+    }
+    popupWidgets->append( popup );		// add to end of list
+
+    if ( popupWidgets->count() == 1 && !qt_nograb() ){ // grab mouse/keyboard
+	int r = XGrabKeyboard( popup->x11Display(), popup->winId(), FALSE,
+			       GrabModeSync, GrabModeAsync, CurrentTime );
+	if ( (popupGrabOk = (r == GrabSuccess)) ) {
+	    r = XGrabPointer( popup->x11Display(), popup->winId(), TRUE,
+			      (uint)(ButtonPressMask | ButtonReleaseMask |
+				     ButtonMotionMask | EnterWindowMask |
+				     LeaveWindowMask | PointerMotionMask),
+			      GrabModeSync, GrabModeAsync,
+			      None, None, CurrentTime );
+
+	    if ( (popupGrabOk = (r == GrabSuccess)) )
+		XAllowEvents( popup->x11Display(), SyncPointer, CurrentTime );
+	    else
+		XUngrabKeyboard( popup->x11Display(), CurrentTime );
+	}
+    } else if ( popupGrabOk ) {
+	XAllowEvents(  popup->x11Display(), SyncPointer, CurrentTime );
+    }
+
+    // popups are not focus-handled by the window system (the first
+    // popup grabbed the keyboard), so we have to do that manually: A
+    // new popup gets the focus
+    QFocusEvent::setReason( QFocusEvent::Popup );
+    if ( popup->focusWidget())
+	popup->focusWidget()->setFocus();
+    else
+	popup->setFocus();
+    QFocusEvent::resetReason();
+}
+
+void QApplication::closePopup( QWidget *popup )
+{
+    if ( !popupWidgets )
+	return;
+    popupWidgets->removeRef( popup );
+    if (popup == popupOfPopupButtonFocus) {
+	popupButtonFocus = 0;
+	popupOfPopupButtonFocus = 0;
+    }
+    if ( popupWidgets->count() == 0 ) {		// this was the last popup
+	popupCloseDownMode = TRUE;		// control mouse events
+	delete popupWidgets;
+	popupWidgets = 0;
+	if ( !qt_nograb() && popupGrabOk ) {	// grabbing not disabled
+	    if ( mouseButtonState != 0
+		 || popup->geometry(). contains(QPoint(mouseGlobalXPos, mouseGlobalYPos) ) )
+		{	// mouse release event or inside
+		    XAllowEvents( popup->x11Display(), AsyncPointer,
+				  CurrentTime );
+	    } else {				// mouse press event
+		mouseButtonPressTime -= 10000;	// avoid double click
+		XAllowEvents( popup->x11Display(), ReplayPointer,CurrentTime );
+	    }
+	    XUngrabPointer( popup->x11Display(), CurrentTime );
+	    XFlush( popup->x11Display() );
+	}
+	if ( active_window ) {
+	    QFocusEvent::setReason( QFocusEvent::Popup );
+	    if ( active_window->focusWidget() )
+		active_window->focusWidget()->setFocus();
+	    else
+		active_window->setFocus();
+	    QFocusEvent::resetReason();
+	}
+    } else {
+	// popups are not focus-handled by the window system (the
+	// first popup grabbed the keyboard), so we have to do that
+	// manually: A popup was closed, so the previous popup gets
+	// the focus.
+	 QFocusEvent::setReason( QFocusEvent::Popup );
+	 QWidget* aw = popupWidgets->getLast();
+	 if (aw->focusWidget())
+	     aw->focusWidget()->setFocus();
+	 else
+	     aw->setFocus();
+	 QFocusEvent::resetReason();
+	 if ( popupWidgets->count() == 1 && !qt_nograb() ){ // grab mouse/keyboard
+	     int r = XGrabKeyboard( aw->x11Display(), aw->winId(), FALSE,
+				    GrabModeSync, GrabModeAsync, CurrentTime );
+	     if ( (popupGrabOk = (r == GrabSuccess)) ) {
+		 r = XGrabPointer( aw->x11Display(), aw->winId(), TRUE,
+				   (uint)(ButtonPressMask | ButtonReleaseMask |
+					  ButtonMotionMask | EnterWindowMask |
+					  LeaveWindowMask | PointerMotionMask),
+				   GrabModeSync, GrabModeAsync,
+				   None, None, CurrentTime );
+
+		 if ( (popupGrabOk = (r == GrabSuccess)) )
+		     XAllowEvents( aw->x11Display(), SyncPointer, CurrentTime );
+	     }
+	 }
+     }
+}
+
+/*****************************************************************************
+  Event translation; translates X11 events to Qt events
+ *****************************************************************************/
+
+//
+// Mouse event translation
+//
+// Xlib doesn't give mouse double click events, so we generate them by
+// comparing window, time and position between two mouse press events.
+//
+
+//
+// Keyboard event translation
+//
+
+int qt_x11_translateButtonState( int s )
+{
+    int bst = 0;
+    if ( s & Button1Mask )
+	bst |= Qt::LeftButton;
+    if ( s & Button2Mask )
+	bst |= Qt::MidButton;
+    if ( s & Button3Mask )
+	bst |= Qt::RightButton;
+    if ( s & ShiftMask )
+	bst |= Qt::ShiftButton;
+    if ( s & ControlMask )
+	bst |= Qt::ControlButton;
+    if ( s & qt_alt_mask )
+	bst |= Qt::AltButton;
+    if ( s & qt_meta_mask )
+	bst |= Qt::MetaButton;
+    return bst;
+}
+
+bool QETWidget::translateMouseEvent( const XEvent *event )
+{
+    static bool manualGrab = FALSE;
+    QEvent::Type type;				// event parameters
+    QPoint pos;
+    QPoint globalPos;
+    int button = 0;
+    int state;
+    XEvent nextEvent;
+
+    if ( sm_blockUserInput ) // block user interaction during session management
+	return TRUE;
+
+    static int x_root_save = -1, y_root_save = -1;
+
+    if ( event->type == MotionNotify ) { // mouse move
+	if (event->xmotion.root != RootWindow(appDpy, x11Screen()) &&
+	    ! qt_xdnd_dragging )
+	    return FALSE;
+
+	XMotionEvent lastMotion = event->xmotion;
+	while( XPending( appDpy ) )  { // compres mouse moves
+	    XNextEvent( appDpy, &nextEvent );
+	    if ( nextEvent.type == ConfigureNotify
+		 || nextEvent.type == PropertyNotify
+		 || nextEvent.type == Expose
+		 || nextEvent.type == NoExpose ) {
+		qApp->x11ProcessEvent( &nextEvent );
+		continue;
+	    } else if ( nextEvent.type != MotionNotify ||
+			nextEvent.xmotion.window != event->xmotion.window ||
+			nextEvent.xmotion.state != event->xmotion.state ) {
+		XPutBackEvent( appDpy, &nextEvent );
+		break;
+	    }
+	    if ( !qt_x11EventFilter(&nextEvent)
+		 && !x11Event( &nextEvent ) ) // send event through filter
+		lastMotion = nextEvent.xmotion;
+	    else
+		break;
+	}
+	type = QEvent::MouseMove;
+	pos.rx() = lastMotion.x;
+	pos.ry() = lastMotion.y;
+	globalPos.rx() = lastMotion.x_root;
+	globalPos.ry() = lastMotion.y_root;
+	state = qt_x11_translateButtonState( lastMotion.state );
+	if ( qt_button_down && (state & (LeftButton |
+					 MidButton |
+					 RightButton ) ) == 0 )
+	    qt_button_down = 0;
+
+	// throw away mouse move events that are sent multiple times to the same
+	// position
+	bool throw_away = FALSE;
+	if ( x_root_save == globalPos.x() &&
+	     y_root_save == globalPos.y() )
+	    throw_away = TRUE;
+	x_root_save = globalPos.x();
+	y_root_save = globalPos.y();
+	if ( throw_away )
+	    return TRUE;
+    } else if ( event->type == EnterNotify || event->type == LeaveNotify) {
+	XEvent *xevent = (XEvent *)event;
+	//unsigned int xstate = event->xcrossing.state;
+	type = QEvent::MouseMove;
+	pos.rx() = xevent->xcrossing.x;
+	pos.ry() = xevent->xcrossing.y;
+	globalPos.rx() = xevent->xcrossing.x_root;
+	globalPos.ry() = xevent->xcrossing.y_root;
+	state = qt_x11_translateButtonState( xevent->xcrossing.state );
+	if ( qt_button_down && (state & (LeftButton |
+					 MidButton |
+					 RightButton ) ) == 0 )
+	    qt_button_down = 0;
+	if ( !qt_button_down )
+	    state = state & ~(LeftButton | MidButton | RightButton );
+    } else {					// button press or release
+	pos.rx() = event->xbutton.x;
+	pos.ry() = event->xbutton.y;
+	globalPos.rx() = event->xbutton.x_root;
+	globalPos.ry() = event->xbutton.y_root;
+	state = qt_x11_translateButtonState( event->xbutton.state );
+	switch ( event->xbutton.button ) {
+	case Button1: button = LeftButton; break;
+	case Button2: button = MidButton; break;
+	case Button3: button = RightButton; break;
+	case Button4:
+	case Button5:
+	case 6:
+	case 7:
+	    // the fancy mouse wheel.
+
+	    // take care about grabbing. We do this here since it
+	    // is clear that we return anyway
+	    if ( qApp->inPopupMode() && popupGrabOk )
+		XAllowEvents( x11Display(), SyncPointer, CurrentTime );
+
+	    // We are only interested in ButtonPress.
+	    if (event->type == ButtonPress ){
+
+		// compress wheel events (the X Server will simply
+		// send a button press for each single notch,
+		// regardless whether the application can catch up
+		// or not)
+		int delta = 1;
+		XEvent xevent;
+		while ( XCheckTypedWindowEvent(x11Display(),winId(),
+					       ButtonPress,&xevent) ){
+		    if (xevent.xbutton.button != event->xbutton.button){
+			XPutBackEvent(x11Display(), &xevent);
+			break;
+		    }
+		    delta++;
+		}
+
+		// the delta is defined as multiples of
+		// WHEEL_DELTA, which is set to 120. Future wheels
+		// may offer a finer-resolution. A positive delta
+		// indicates forward rotation, a negative one
+		// backward rotation respectively.
+		int btn = event->xbutton.button;
+		delta *= 120 * ( (btn == Button4 || btn == 6) ? 1 : -1 );
+		bool hor = ( (btn == Button4 || btn == Button5) && (state&AltButton) ||
+			     (btn == 6 || btn == 7) );
+		translateWheelEvent( globalPos.x(), globalPos.y(), delta, state, (hor)?Horizontal:Vertical );
+	    }
+	    return TRUE;
+	}
+	if ( event->type == ButtonPress ) {	// mouse button pressed
+#if defined(Q_OS_IRIX) && defined(QT_TABLET_SUPPORT)
+	    XEvent myEv;
+	    if ( XCheckTypedEvent( appDpy, xinput_button_press, &myEv ) ) {
+		if ( translateXinputEvent( &myEv ) ) {
+		    //Spontaneous event sent.  Check if we need to continue.
+		    if ( chokeMouse ) {
+			chokeMouse = FALSE;
+			return FALSE;
+		    }
+		}
+	    }
+#endif
+	    qt_button_down = childAt( pos );	//magic for masked widgets
+	    if ( !qt_button_down || !qt_button_down->testWFlags(WMouseNoMask) )
+		qt_button_down = this;
+	    if ( mouseActWindow == event->xbutton.window &&
+		 mouseButtonPressed == button &&
+		 (long)event->xbutton.time -(long)mouseButtonPressTime
+		 < QApplication::doubleClickInterval() &&
+		 QABS(event->xbutton.x - mouseXPos) < 5 &&
+		 QABS(event->xbutton.y - mouseYPos) < 5 ) {
+		type = QEvent::MouseButtonDblClick;
+		mouseButtonPressTime -= 2000;	// no double-click next time
+	    } else {
+		type = QEvent::MouseButtonPress;
+		mouseButtonPressTime = event->xbutton.time;
+	    }
+	    mouseButtonPressed = button;	// save event params for
+	    mouseXPos = pos.x();		// future double click tests
+	    mouseYPos = pos.y();
+	    mouseGlobalXPos = globalPos.x();
+	    mouseGlobalYPos = globalPos.y();
+	} else {				// mouse button released
+#if defined(Q_OS_IRIX) && defined(QT_TABLET_SUPPORT)
+	    XEvent myEv;
+	    if ( XCheckTypedEvent( appDpy, xinput_button_release, &myEv ) ) {
+		if ( translateXinputEvent( &myEv ) ) {
+		    //Spontaneous event sent.  Check if we need to continue.
+		    if ( chokeMouse ) {
+			chokeMouse = FALSE;
+			return FALSE;
+		    }
+		}
+	    }
+#endif
+	    if ( manualGrab ) {			// release manual grab
+		manualGrab = FALSE;
+		XUngrabPointer( x11Display(), CurrentTime );
+		XFlush( x11Display() );
+	    }
+
+	    type = QEvent::MouseButtonRelease;
+	}
+    }
+    mouseActWindow = winId();			// save some event params
+    mouseButtonState = state;
+    if ( type == 0 )				// don't send event
+	return FALSE;
+
+    if ( qApp->inPopupMode() ) {			// in popup mode
+	QWidget *popup = qApp->activePopupWidget();
+	if ( popup != this ) {
+	    if ( testWFlags(WType_Popup) && rect().contains(pos) )
+		popup = this;
+	    else				// send to last popup
+		pos = popup->mapFromGlobal( globalPos );
+	}
+	bool releaseAfter = FALSE;
+	QWidget *popupChild  = popup->childAt( pos );
+	QWidget *popupTarget = popupChild ? popupChild : popup;
+
+	if (popup != popupOfPopupButtonFocus){
+	    popupButtonFocus = 0;
+	    popupOfPopupButtonFocus = 0;
+	}
+
+	if ( !popupTarget->isEnabled() ) {
+	    if ( popupGrabOk )
+		XAllowEvents( x11Display(), SyncPointer, CurrentTime );
+	}
+
+	switch ( type ) {
+	case QEvent::MouseButtonPress:
+	case QEvent::MouseButtonDblClick:
+	    popupButtonFocus = popupChild;
+	    popupOfPopupButtonFocus = popup;
+	    break;
+	case QEvent::MouseButtonRelease:
+	    releaseAfter = TRUE;
+	    break;
+	default:
+	    break;				// nothing for mouse move
+	}
+
+	Display* dpy = x11Display(); // store display, send() may destroy us
+
+
+	int oldOpenPopupCount = openPopupCount;
+
+	if ( popupButtonFocus ) {
+	    QMouseEvent e( type, popupButtonFocus->mapFromGlobal(globalPos),
+			   globalPos, button, state );
+	    QApplication::sendSpontaneousEvent( popupButtonFocus, &e );
+	    if ( releaseAfter ) {
+		popupButtonFocus = 0;
+		popupOfPopupButtonFocus = 0;
+	    }
+	} else if ( popupChild ) {
+	    QMouseEvent e( type, popupChild->mapFromGlobal(globalPos),
+			   globalPos, button, state );
+	    QApplication::sendSpontaneousEvent( popupChild, &e );
+	} else {
+	    QMouseEvent e( type, pos, globalPos, button, state );
+	    QApplication::sendSpontaneousEvent( popup, &e );
+	}
+
+	if ( type == QEvent::MouseButtonPress && button == RightButton && ( openPopupCount == oldOpenPopupCount ) ) {
+	    QWidget *popupEvent = popup;
+	    if(popupButtonFocus)
+		popupEvent = popupButtonFocus;
+	    else if(popupChild)
+		popupEvent = popupChild;
+	    QContextMenuEvent e( QContextMenuEvent::Mouse, pos, globalPos, state );
+	    QApplication::sendSpontaneousEvent( popupEvent, &e );
+	}
+
+	if ( releaseAfter )
+	    qt_button_down = 0;
+
+	if ( qApp->inPopupMode() ) { // still in popup mode
+	    if ( popupGrabOk )
+		XAllowEvents( dpy, SyncPointer, CurrentTime );
+	} else {
+	    if ( type != QEvent::MouseButtonRelease && state != 0 &&
+		 QWidget::find((WId)mouseActWindow) ) {
+		manualGrab = TRUE;		// need to manually grab
+		XGrabPointer( dpy, mouseActWindow, False,
+			      (uint)(ButtonPressMask | ButtonReleaseMask |
+				     ButtonMotionMask |
+				     EnterWindowMask | LeaveWindowMask),
+			      GrabModeAsync, GrabModeAsync,
+			      None, None, CurrentTime );
+	    }
+	}
+
+    } else {
+	QWidget *widget = this;
+	QWidget *w = QWidget::mouseGrabber();
+	if ( !w )
+	    w = qt_button_down;
+	if ( w && w != this ) {
+	    widget = w;
+	    pos = w->mapFromGlobal( globalPos );
+	}
+
+	if ( popupCloseDownMode ) {
+	    popupCloseDownMode = FALSE;
+	    if ( testWFlags(WType_Popup) )	// ignore replayed event
+		return TRUE;
+	}
+
+	if ( type == QEvent::MouseButtonRelease &&
+	     (state & (~button) & ( LeftButton |
+				    MidButton |
+				    RightButton)) == 0 ) {
+	    qt_button_down = 0;
+	}
+
+	int oldOpenPopupCount = openPopupCount;
+
+	QMouseEvent e( type, pos, globalPos, button, state );
+	QApplication::sendSpontaneousEvent( widget, &e );
+
+	if ( type == QEvent::MouseButtonPress && button == RightButton && ( openPopupCount == oldOpenPopupCount ) ) {
+	    QContextMenuEvent e( QContextMenuEvent::Mouse, pos, globalPos, state );
+	    QApplication::sendSpontaneousEvent( widget, &e );
+	}
+    }
+    return TRUE;
+}
+
+
+//
+// Wheel event translation
+//
+bool QETWidget::translateWheelEvent( int global_x, int global_y, int delta, int state, Orientation orient )
+{
+    // send the event to the widget or its ancestors
+    {
+	QWidget* popup = qApp->activePopupWidget();
+	if ( popup && topLevelWidget() != popup )
+	    popup->close();
+	QWheelEvent e( mapFromGlobal(QPoint( global_x, global_y)),
+		       QPoint(global_x, global_y), delta, state, orient );
+	if ( QApplication::sendSpontaneousEvent( this, &e ) )
+	    return TRUE;
+    }
+
+    // send the event to the widget that has the focus or its ancestors, if different
+    QWidget *w = this;
+    if ( w != qApp->focusWidget() && ( w = qApp->focusWidget() ) ) {
+	QWidget* popup = qApp->activePopupWidget();
+	if ( popup && w != popup )
+	    popup->hide();
+	QWheelEvent e( mapFromGlobal(QPoint( global_x, global_y)),
+		       QPoint(global_x, global_y), delta, state, orient );
+	if ( QApplication::sendSpontaneousEvent( w, &e ) )
+	    return TRUE;
+    }
+    return FALSE;
+}
+
+
+//
+// XInput Translation Event
+//
+#if defined (QT_TABLET_SUPPORT)
+bool QETWidget::translateXinputEvent( const XEvent *ev )
+{
+#if defined (Q_OS_IRIX)
+    // Wacom has put defines in their wacom.h file so it would be quite wise
+    // to use them, need to think of a decent way of not using
+    // it when it doesn't exist...
+    XDeviceState *s;
+    XInputClass *iClass;
+    XValuatorState *vs;
+    int j;
+#endif
+    QWidget *w = this;
+    QPoint global,
+	curr;
+    static int pressure = 0;
+    static int xTilt = 0,
+	       yTilt = 0;
+    int deviceType = QTabletEvent::NoDevice;
+    QPair<int, int> tId;
+    XEvent xinputMotionEvent;
+    XEvent mouseMotionEvent;
+    XDevice *dev;
+    const XDeviceMotionEvent *motion = 0;
+    XDeviceButtonEvent *button = 0;
+    QEvent::Type t;
+
+    if ( ev->type == xinput_motion ) {
+	motion = (const XDeviceMotionEvent*)ev;
+	for (;;) {
+	    if (!XCheckTypedWindowEvent(x11Display(), winId(), MotionNotify, &mouseMotionEvent))
+		break;
+	    if (!XCheckTypedWindowEvent(x11Display(), winId(), xinput_motion, &xinputMotionEvent)) {
+		XPutBackEvent(x11Display(), &mouseMotionEvent);
+		break;
+	    }
+	    if (mouseMotionEvent.xmotion.time != motion->time) {
+		XPutBackEvent(x11Display(), &mouseMotionEvent);
+		XPutBackEvent(x11Display(), &xinputMotionEvent);
+		break;
+	    }
+	    motion = ((const XDeviceMotionEvent*)&xinputMotionEvent);
+	}
+	t = QEvent::TabletMove;
+	curr = QPoint( motion->x, motion->y );
+    } else {
+	if ( ev->type == xinput_button_press ) {
+	    t = QEvent::TabletPress;
+        } else {
+	    t = QEvent::TabletRelease;
+	}
+	button = (XDeviceButtonEvent*)ev;
+/*
+	qDebug( "\n\nXInput Button Event" );
+	qDebug( "serial:\t%d", button->serial );
+	qDebug( "send_event:\t%d", button->send_event );
+	qDebug( "display:\t%p", button->display );
+	qDebug( "window:\t%d", button->window );
+	qDebug( "deviceID:\t%d", button->deviceid );
+	qDebug( "root:\t%d", button->root );
+	qDebug( "subwindot:\t%d", button->subwindow );
+	qDebug( "x:\t%d", button->x );
+	qDebug( "y:\t%d", button->y );
+	qDebug( "x_root:\t%d", button->x_root );
+	qDebug( "y_root:\t%d", button->y_root );
+	qDebug( "state:\t%d", button->state );
+	qDebug( "button:\t%d", button->button );
+	qDebug( "same_screen:\t%d", button->same_screen );
+	qDebug( "time:\t%d", button->time );
+*/
+	curr = QPoint( button->x, button->y );
+    }
+#if defined(Q_OS_IRIX)
+    // default...
+    dev = devStylus;
+#else
+    if ( ev->type == xinput_motion ) {
+	if ( motion->deviceid == devStylus->device_id ) {
+	    dev = devStylus;
+	    deviceType = QTabletEvent::Stylus;
+	} else if ( motion->deviceid == devEraser->device_id ) {
+	    dev = devEraser;
+	    deviceType = QTabletEvent::Eraser;
+	}
+    } else {
+	if ( button->deviceid == devStylus->device_id ) {
+	    dev = devStylus;
+	    deviceType = QTabletEvent::Stylus;
+	} else if ( button->deviceid == devEraser->device_id ) {
+	    dev = devEraser;
+	    deviceType = QTabletEvent::Eraser;
+	}
+    }
+#endif
+
+    const int PRESSURE_LEVELS = 255;
+    // we got the maximum pressure at start time, since various tablets have
+    // varying levels of distinguishing pressure changes, let's standardize and
+    // scale everything to 256 different levels...
+    static int scaleFactor = -1;
+    if ( scaleFactor == -1 ) {
+	if ( max_pressure > PRESSURE_LEVELS )
+	    scaleFactor = max_pressure / PRESSURE_LEVELS;
+	else
+	    scaleFactor = PRESSURE_LEVELS / max_pressure;
+    }
+#if defined (Q_OS_IRIX)
+    s = XQueryDeviceState( appDpy, dev );
+    if ( s == NULL )
+        return FALSE;
+    iClass = s->data;
+    for ( j = 0; j < s->num_classes; j++ ) {
+        if ( iClass->c_class == ValuatorClass ) {
+            vs = (XValuatorState *)iClass;
+            // figure out what device we have, based on bitmasking...
+            if ( vs->valuators[WAC_TRANSDUCER_I]
+                 & WAC_TRANSDUCER_PROX_MSK ) {
+                switch ( vs->valuators[WAC_TRANSDUCER_I]
+                         & WAC_TRANSDUCER_MSK ) {
+                case WAC_PUCK_ID:
+                    deviceType = QTabletEvent::Puck;
+                    break;
+                case WAC_STYLUS_ID:
+                    deviceType = QTabletEvent::Stylus;
+                    break;
+                case WAC_ERASER_ID:
+                    deviceType = QTabletEvent::Eraser;
+                    break;
+                }
+                // Get a Unique Id for the device, Wacom gives us this ability
+                tId.first = vs->valuators[WAC_TRANSDUCER_I] & WAC_TRANSDUCER_ID_MSK;
+                tId.second = vs->valuators[WAC_SERIAL_NUM_I];
+            } else
+                deviceType = QTabletEvent::NoDevice;
+            // apparently Wacom needs a cast for the +/- values to make sense
+            xTilt = short(vs->valuators[WAC_XTILT_I]);
+            yTilt = short(vs->valuators[WAC_YTILT_I]);
+            if ( max_pressure > PRESSURE_LEVELS )
+                pressure = vs->valuators[WAC_PRESSURE_I] / scaleFactor;
+            else
+                pressure = vs->valuators[WAC_PRESSURE_I] * scaleFactor;
+	    global = QPoint( vs->valuators[WAC_XCOORD_I],
+                             vs->valuators[WAC_YCOORD_I] );
+	    break;
+	}
+	iClass = (XInputClass*)((char*)iClass + iClass->length);
+    }
+    XFreeDeviceState( s );
+#else
+    if ( motion ) {
+	xTilt = short(motion->axis_data[3]);
+	yTilt = short(motion->axis_data[4]);
+	if ( max_pressure > PRESSURE_LEVELS )
+	    pressure = motion->axis_data[2] / scaleFactor;
+	else
+	    pressure = motion->axis_data[2] * scaleFactor;
+	global = QPoint( motion->axis_data[0], motion->axis_data[1] );
+    } else {
+	xTilt = short(button->axis_data[3]);
+	yTilt = short(button->axis_data[4]);
+	if ( max_pressure > PRESSURE_LEVELS )
+	    pressure = button->axis_data[2]  / scaleFactor;
+	else
+	    pressure = button->axis_data[2] * scaleFactor;
+	global = QPoint( button->axis_data[0], button->axis_data[1] );
+    }
+    // The only way to get these Ids is to scan the XFree86 log, which I'm not going to do.
+    tId.first = tId.second = -1;
+#endif
+
+    QTabletEvent e( t, curr, global, deviceType, pressure, xTilt, yTilt, tId );
+    QApplication::sendSpontaneousEvent( w, &e );
+    return TRUE;
+}
+#endif
+
+bool QETWidget::translatePropertyEvent(const XEvent *event)
+{
+    if (!isTopLevel()) return TRUE;
+
+    Atom ret;
+    int format, e;
+    unsigned char *data = 0;
+    unsigned long nitems, after;
+
+    if (event->xproperty.atom == qt_net_wm_frame_strut) {
+	topData()->fleft = topData()->fright = topData()->ftop = topData()->fbottom = 0;
+	fstrut_dirty = 1;
+
+	if (event->xproperty.state == PropertyNewValue) {
+	    e = XGetWindowProperty(appDpy, event->xproperty.window, qt_net_wm_frame_strut,
+				   0, 4, // struts are 4 longs
+				   False, XA_CARDINAL, &ret, &format, &nitems, &after, &data);
+
+	    if (e == Success && ret == XA_CARDINAL &&
+		format == 32 && nitems == 4) {
+		long *strut = (long *) data;
+		topData()->fleft   = strut[0];
+		topData()->fright  = strut[1];
+		topData()->ftop    = strut[2];
+		topData()->fbottom = strut[3];
+		fstrut_dirty = 0;
+	    }
+	}
+    } else if (event->xproperty.atom == qt_net_wm_state) {
+	bool max = FALSE;
+	bool full = FALSE;
+
+	if (event->xproperty.state == PropertyNewValue) {
+	    // using length of 1024 should be safe for all current and
+	    // possible NET states...
+	    e = XGetWindowProperty(appDpy, event->xproperty.window, qt_net_wm_state, 0, 1024,
+				   False, XA_ATOM, &ret, &format, &nitems, &after, &data);
+
+	    if (e == Success && ret == XA_ATOM && format == 32 && nitems > 0) {
+		Atom *states = (Atom *) data;
+
+		unsigned long i;
+		for (i = 0; i < nitems; i++) {
+		    if (states[i] == qt_net_wm_state_max_v || states[i] == qt_net_wm_state_max_h)
+			max = TRUE;
+		    else if (states[i] == qt_net_wm_state_fullscreen)
+			full = TRUE;
+		}
+	    }
+	}
+
+	bool send_event = FALSE;
+	if (max && !isMaximized()) {
+	    setWState(WState_Maximized);
+	    send_event = TRUE;
+	} else if (!max && isMaximized()) {
+	    clearWState(WState_Maximized);
+	    send_event = TRUE;
+	}
+
+	if (full && !isFullScreen()) {
+	    setWState(WState_FullScreen);
+	    send_event = TRUE;
+	} else if (!full && isFullScreen()) {
+	    clearWState(WState_FullScreen);
+	    send_event = TRUE;
+	}
+
+	if (send_event) {
+	    QEvent e(QEvent::WindowStateChange);
+	    QApplication::sendSpontaneousEvent(this, &e);
+	}
+    } else if (event->xproperty.atom == qt_wm_state) {
+	// the widget frame strut should also be invalidated
+	topData()->fleft = topData()->fright = topData()->ftop = topData()->fbottom = 0;
+	fstrut_dirty = 1;
+
+	if (event->xproperty.state == PropertyDelete) {
+	    // the window manager has removed the WM State property,
+	    // so it is now in the withdrawn state (ICCCM 4.1.3.1) and
+	    // we are free to reuse this window
+	    topData()->parentWinId = 0;
+	    // map the window if we were waiting for a transition to
+	    // withdrawn
+	    if ( qt_deferred_map_contains( this ) ) {
+		qt_deferred_map_take( this );
+		XMapWindow( appDpy, winId() );
+	    }
+	} else if (topData()->parentWinId != QPaintDevice::x11AppRootWindow(x11Screen())) {
+	    // the window manager has changed the WM State property...
+	    // we are wanting to see if we are withdrawn so that we
+	    // can reuse this window... we only do this check *IF* we
+	    // haven't been reparented to root - (the parentWinId !=
+	    // QPaintDevice::x11AppRootWindow(x11Screen())) check
+	    // above
+
+	    e = XGetWindowProperty(appDpy, winId(), qt_wm_state, 0, 2, False, qt_wm_state,
+				   &ret, &format, &nitems, &after, &data );
+
+	    if (e == Success && ret == qt_wm_state && format == 32 && nitems > 0) {
+		long *state = (long *) data;
+		switch (state[0]) {
+		case WithdrawnState:
+		    // if we are in the withdrawn state, we are free
+		    // to reuse this window provided we remove the
+		    // WM_STATE property (ICCCM 4.1.3.1)
+		    XDeleteProperty(appDpy, winId(), qt_wm_state);
+
+		    // set the parent id to zero, so that show() will
+		    // work again
+		    topData()->parentWinId = 0;
+		    // map the window if we were waiting for a
+		    // transition to withdrawn
+		    if ( qt_deferred_map_contains( this ) ) {
+			qt_deferred_map_take( this );
+			XMapWindow( appDpy, winId() );
+		    }
+		    break;
+
+		case IconicState:
+		    if (!isMinimized()) {
+			// window was minimized
+			setWState(WState_Minimized);
+			QEvent e(QEvent::WindowStateChange);
+			QApplication::sendSpontaneousEvent(this, &e);
+		    }
+		    break;
+
+		default:
+		    if (isMinimized()) {
+			// window was un-minimized
+			clearWState(WState_Minimized);
+			QEvent e(QEvent::WindowStateChange);
+			QApplication::sendSpontaneousEvent(this, &e);
+		    }
+		    break;
+		}
+	    }
+	}
+    }
+
+    if (data)
+	XFree(data);
+
+    return TRUE;
+}
+
+#ifndef XK_ISO_Left_Tab
+#define	XK_ISO_Left_Tab					0xFE20
+#endif
+
+// the next lines are taken from XFree > 4.0 (X11/XF86keysyms.h), defining some special
+// multimedia keys. They are included here as not every system has them.
+#define XF86XK_Standby		0x1008FF10
+#define XF86XK_AudioLowerVolume	0x1008FF11
+#define XF86XK_AudioMute	0x1008FF12
+#define XF86XK_AudioRaiseVolume	0x1008FF13
+#define XF86XK_AudioPlay	0x1008FF14
+#define XF86XK_AudioStop	0x1008FF15
+#define XF86XK_AudioPrev	0x1008FF16
+#define XF86XK_AudioNext	0x1008FF17
+#define XF86XK_HomePage		0x1008FF18
+#define XF86XK_Calculator	0x1008FF1D
+#define XF86XK_Mail		0x1008FF19
+#define XF86XK_Start		0x1008FF1A
+#define XF86XK_Search		0x1008FF1B
+#define XF86XK_AudioRecord	0x1008FF1C
+#define XF86XK_Back		0x1008FF26
+#define XF86XK_Forward		0x1008FF27
+#define XF86XK_Stop		0x1008FF28
+#define XF86XK_Refresh		0x1008FF29
+#define XF86XK_Favorites	0x1008FF30
+#define XF86XK_AudioPause	0x1008FF31
+#define XF86XK_AudioMedia	0x1008FF32
+#define XF86XK_MyComputer	0x1008FF33
+#define XF86XK_OpenURL		0x1008FF38
+#define XF86XK_Launch0		0x1008FF40
+#define XF86XK_Launch1		0x1008FF41
+#define XF86XK_Launch2		0x1008FF42
+#define XF86XK_Launch3		0x1008FF43
+#define XF86XK_Launch4		0x1008FF44
+#define XF86XK_Launch5		0x1008FF45
+#define XF86XK_Launch6		0x1008FF46
+#define XF86XK_Launch7		0x1008FF47
+#define XF86XK_Launch8		0x1008FF48
+#define XF86XK_Launch9		0x1008FF49
+#define XF86XK_LaunchA		0x1008FF4A
+#define XF86XK_LaunchB		0x1008FF4B
+#define XF86XK_LaunchC		0x1008FF4C
+#define XF86XK_LaunchD		0x1008FF4D
+#define XF86XK_LaunchE		0x1008FF4E
+#define XF86XK_LaunchF		0x1008FF4F
+// end of XF86keysyms.h
+
+
+
+static const KeySym KeyTbl[] = {		// keyboard mapping table
+    XK_Escape,		Qt::Key_Escape,		// misc keys
+    XK_Tab,		Qt::Key_Tab,
+    XK_ISO_Left_Tab,    Qt::Key_Backtab,
+    XK_BackSpace,	Qt::Key_Backspace,
+    XK_Return,		Qt::Key_Return,
+    XK_Insert,		Qt::Key_Insert,
+    XK_KP_Insert,	Qt::Key_Insert,
+    XK_Delete,		Qt::Key_Delete,
+    XK_KP_Delete,	Qt::Key_Delete,
+    XK_Clear,		Qt::Key_Delete,
+    XK_Pause,		Qt::Key_Pause,
+    XK_Print,		Qt::Key_Print,
+    XK_KP_Begin,	Qt::Key_Clear,
+    0x1005FF60,		Qt::Key_SysReq,		// hardcoded Sun SysReq
+    0x1007ff00,		Qt::Key_SysReq,		// hardcoded X386 SysReq
+    XK_Home,		Qt::Key_Home,		// cursor movement
+    XK_End,		Qt::Key_End,
+    XK_Left,		Qt::Key_Left,
+    XK_Up,		Qt::Key_Up,
+    XK_Right,		Qt::Key_Right,
+    XK_Down,		Qt::Key_Down,
+    XK_Prior,		Qt::Key_Prior,
+    XK_Next,		Qt::Key_Next,
+    XK_KP_Home,		Qt::Key_Home,
+    XK_KP_End,		Qt::Key_End,
+    XK_KP_Left,		Qt::Key_Left,
+    XK_KP_Up,		Qt::Key_Up,
+    XK_KP_Right,	Qt::Key_Right,
+    XK_KP_Down,		Qt::Key_Down,
+    XK_KP_Prior,	Qt::Key_Prior,
+    XK_KP_Next,		Qt::Key_Next,
+    XK_Shift_L,		Qt::Key_Shift,		// modifiers
+    XK_Shift_R,		Qt::Key_Shift,
+    XK_Shift_Lock,	Qt::Key_Shift,
+    XK_Control_L,	Qt::Key_Control,
+    XK_Control_R,	Qt::Key_Control,
+    XK_Meta_L,		Qt::Key_Meta,
+    XK_Meta_R,		Qt::Key_Meta,
+    XK_Alt_L,		Qt::Key_Alt,
+    XK_Alt_R,		Qt::Key_Alt,
+    XK_Caps_Lock,	Qt::Key_CapsLock,
+    XK_Num_Lock,	Qt::Key_NumLock,
+    XK_Scroll_Lock,	Qt::Key_ScrollLock,
+    XK_KP_Space,	Qt::Key_Space,		// numeric keypad
+    XK_KP_Tab,		Qt::Key_Tab,
+    XK_KP_Enter,	Qt::Key_Enter,
+    XK_KP_Equal,	Qt::Key_Equal,
+    XK_KP_Multiply,	Qt::Key_Asterisk,
+    XK_KP_Add,		Qt::Key_Plus,
+    XK_KP_Separator,	Qt::Key_Comma,
+    XK_KP_Subtract,	Qt::Key_Minus,
+    XK_KP_Decimal,	Qt::Key_Period,
+    XK_KP_Divide,	Qt::Key_Slash,
+    XK_Super_L,		Qt::Key_Super_L,
+    XK_Super_R,		Qt::Key_Super_R,
+    XK_Menu,		Qt::Key_Menu,
+    XK_Hyper_L,		Qt::Key_Hyper_L,
+    XK_Hyper_R,		Qt::Key_Hyper_R,
+    XK_Help,		Qt::Key_Help,
+    0x1000FF74,         Qt::Key_BackTab,     // hardcoded HP backtab
+
+    // Special multimedia keys
+    // currently only tested with MS internet keyboard
+
+    // browsing keys
+    XF86XK_Back,	Qt::Key_Back,
+    XF86XK_Forward,	Qt::Key_Forward,
+    XF86XK_Stop,	Qt::Key_Stop,
+    XF86XK_Refresh,	Qt::Key_Refresh,
+    XF86XK_Favorites,	Qt::Key_Favorites,
+    XF86XK_AudioMedia,	Qt::Key_LaunchMedia,
+    XF86XK_OpenURL,	Qt::Key_OpenUrl,
+    XF86XK_HomePage,	Qt::Key_HomePage,
+    XF86XK_Search,	Qt::Key_Search,
+
+    // media keys
+    XF86XK_AudioLowerVolume, Qt::Key_VolumeDown,
+    XF86XK_AudioMute,	Qt::Key_VolumeMute,
+    XF86XK_AudioRaiseVolume, Qt::Key_VolumeUp,
+    XF86XK_AudioPlay,	Qt::Key_MediaPlay,
+    XF86XK_AudioStop,	Qt::Key_MediaStop,
+    XF86XK_AudioPrev,	Qt::Key_MediaPrev,
+    XF86XK_AudioNext,	Qt::Key_MediaNext,
+    XF86XK_AudioRecord,	Qt::Key_MediaRecord,
+
+    // launch keys
+    XF86XK_Mail,	Qt::Key_LaunchMail,
+    XF86XK_MyComputer,	Qt::Key_Launch0,
+    XF86XK_Calculator,	Qt::Key_Launch1,
+    XF86XK_Standby, 	Qt::Key_Standby,
+
+    XF86XK_Launch0,	Qt::Key_Launch2,
+    XF86XK_Launch1,	Qt::Key_Launch3,
+    XF86XK_Launch2,	Qt::Key_Launch4,
+    XF86XK_Launch3,	Qt::Key_Launch5,
+    XF86XK_Launch4,	Qt::Key_Launch6,
+    XF86XK_Launch5,	Qt::Key_Launch7,
+    XF86XK_Launch6,	Qt::Key_Launch8,
+    XF86XK_Launch7,	Qt::Key_Launch9,
+    XF86XK_Launch8,	Qt::Key_LaunchA,
+    XF86XK_Launch9,	Qt::Key_LaunchB,
+    XF86XK_LaunchA,	Qt::Key_LaunchC,
+    XF86XK_LaunchB,	Qt::Key_LaunchD,
+    XF86XK_LaunchC,	Qt::Key_LaunchE,
+    XF86XK_LaunchD,	Qt::Key_LaunchF,
+
+    0,			0
+};
+
+
+static QIntDict<void>    *keyDict  = 0;
+static QIntDict<void>    *textDict = 0;
+
+static void deleteKeyDicts()
+{
+    if ( keyDict )
+	delete keyDict;
+    keyDict = 0;
+    if ( textDict )
+	delete textDict;
+    textDict = 0;
+}
+
+#if !defined(QT_NO_XIM)
+static const unsigned short katakanaKeysymsToUnicode[] = {
+    0x0000, 0x3002, 0x300C, 0x300D, 0x3001, 0x30FB, 0x30F2, 0x30A1,
+    0x30A3, 0x30A5, 0x30A7, 0x30A9, 0x30E3, 0x30E5, 0x30E7, 0x30C3,
+    0x30FC, 0x30A2, 0x30A4, 0x30A6, 0x30A8, 0x30AA, 0x30AB, 0x30AD,
+    0x30AF, 0x30B1, 0x30B3, 0x30B5, 0x30B7, 0x30B9, 0x30BB, 0x30BD,
+    0x30BF, 0x30C1, 0x30C4, 0x30C6, 0x30C8, 0x30CA, 0x30CB, 0x30CC,
+    0x30CD, 0x30CE, 0x30CF, 0x30D2, 0x30D5, 0x30D8, 0x30DB, 0x30DE,
+    0x30DF, 0x30E0, 0x30E1, 0x30E2, 0x30E4, 0x30E6, 0x30E8, 0x30E9,
+    0x30EA, 0x30EB, 0x30EC, 0x30ED, 0x30EF, 0x30F3, 0x309B, 0x309C
+};
+
+static const unsigned short cyrillicKeysymsToUnicode[] = {
+    0x0000, 0x0452, 0x0453, 0x0451, 0x0454, 0x0455, 0x0456, 0x0457,
+    0x0458, 0x0459, 0x045a, 0x045b, 0x045c, 0x0000, 0x045e, 0x045f,
+    0x2116, 0x0402, 0x0403, 0x0401, 0x0404, 0x0405, 0x0406, 0x0407,
+    0x0408, 0x0409, 0x040a, 0x040b, 0x040c, 0x0000, 0x040e, 0x040f,
+    0x044e, 0x0430, 0x0431, 0x0446, 0x0434, 0x0435, 0x0444, 0x0433,
+    0x0445, 0x0438, 0x0439, 0x043a, 0x043b, 0x043c, 0x043d, 0x043e,
+    0x043f, 0x044f, 0x0440, 0x0441, 0x0442, 0x0443, 0x0436, 0x0432,
+    0x044c, 0x044b, 0x0437, 0x0448, 0x044d, 0x0449, 0x0447, 0x044a,
+    0x042e, 0x0410, 0x0411, 0x0426, 0x0414, 0x0415, 0x0424, 0x0413,
+    0x0425, 0x0418, 0x0419, 0x041a, 0x041b, 0x041c, 0x041d, 0x041e,
+    0x041f, 0x042f, 0x0420, 0x0421, 0x0422, 0x0423, 0x0416, 0x0412,
+    0x042c, 0x042b, 0x0417, 0x0428, 0x042d, 0x0429, 0x0427, 0x042a
+};
+
+static const unsigned short greekKeysymsToUnicode[] = {
+    0x0000, 0x0386, 0x0388, 0x0389, 0x038a, 0x03aa, 0x0000, 0x038c,
+    0x038e, 0x03ab, 0x0000, 0x038f, 0x0000, 0x0000, 0x0385, 0x2015,
+    0x0000, 0x03ac, 0x03ad, 0x03ae, 0x03af, 0x03ca, 0x0390, 0x03cc,
+    0x03cd, 0x03cb, 0x03b0, 0x03ce, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0391, 0x0392, 0x0393, 0x0394, 0x0395, 0x0396, 0x0397,
+    0x0398, 0x0399, 0x039a, 0x039b, 0x039c, 0x039d, 0x039e, 0x039f,
+    0x03a0, 0x03a1, 0x03a3, 0x0000, 0x03a4, 0x03a5, 0x03a6, 0x03a7,
+    0x03a8, 0x03a9, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x03b1, 0x03b2, 0x03b3, 0x03b4, 0x03b5, 0x03b6, 0x03b7,
+    0x03b8, 0x03b9, 0x03ba, 0x03bb, 0x03bc, 0x03bd, 0x03be, 0x03bf,
+    0x03c0, 0x03c1, 0x03c3, 0x03c2, 0x03c4, 0x03c5, 0x03c6, 0x03c7,
+    0x03c8, 0x03c9, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
+};
+
+static const unsigned short technicalKeysymsToUnicode[] = {
+    0x0000, 0x23B7, 0x250C, 0x2500, 0x2320, 0x2321, 0x2502, 0x23A1,
+    0x23A3, 0x23A4, 0x23A6, 0x239B, 0x239D, 0x239E, 0x23A0, 0x23A8,
+    0x23AC, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x2264, 0x2260, 0x2265, 0x222B,
+    0x2234, 0x221D, 0x221E, 0x0000, 0x0000, 0x2207, 0x0000, 0x0000,
+    0x223C, 0x2243, 0x0000, 0x0000, 0x0000, 0x21D4, 0x21D2, 0x2261,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x221A, 0x0000,
+    0x0000, 0x0000, 0x2282, 0x2283, 0x2229, 0x222A, 0x2227, 0x2228,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2202,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0192, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x2190, 0x2191, 0x2192, 0x2193, 0x0000
+};
+
+static const unsigned short specialKeysymsToUnicode[] = {
+    0x25C6, 0x2592, 0x2409, 0x240C, 0x240D, 0x240A, 0x0000, 0x0000,
+    0x2424, 0x240B, 0x2518, 0x2510, 0x250C, 0x2514, 0x253C, 0x23BA,
+    0x23BB, 0x2500, 0x23BC, 0x23BD, 0x251C, 0x2524, 0x2534, 0x252C,
+    0x2502, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
+};
+
+static const unsigned short publishingKeysymsToUnicode[] = {
+    0x0000, 0x2003, 0x2002, 0x2004, 0x2005, 0x2007, 0x2008, 0x2009,
+    0x200a, 0x2014, 0x2013, 0x0000, 0x0000, 0x0000, 0x2026, 0x2025,
+    0x2153, 0x2154, 0x2155, 0x2156, 0x2157, 0x2158, 0x2159, 0x215a,
+    0x2105, 0x0000, 0x0000, 0x2012, 0x2329, 0x0000, 0x232a, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x215b, 0x215c, 0x215d, 0x215e, 0x0000,
+    0x0000, 0x2122, 0x2613, 0x0000, 0x25c1, 0x25b7, 0x25cb, 0x25af,
+    0x2018, 0x2019, 0x201c, 0x201d, 0x211e, 0x0000, 0x2032, 0x2033,
+    0x0000, 0x271d, 0x0000, 0x25ac, 0x25c0, 0x25b6, 0x25cf, 0x25ae,
+    0x25e6, 0x25ab, 0x25ad, 0x25b3, 0x25bd, 0x2606, 0x2022, 0x25aa,
+    0x25b2, 0x25bc, 0x261c, 0x261e, 0x2663, 0x2666, 0x2665, 0x0000,
+    0x2720, 0x2020, 0x2021, 0x2713, 0x2717, 0x266f, 0x266d, 0x2642,
+    0x2640, 0x260e, 0x2315, 0x2117, 0x2038, 0x201a, 0x201e, 0x0000
+};
+
+static const unsigned short aplKeysymsToUnicode[] = {
+    0x0000, 0x0000, 0x0000, 0x003c, 0x0000, 0x0000, 0x003e, 0x0000,
+    0x2228, 0x2227, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x00af, 0x0000, 0x22a5, 0x2229, 0x230a, 0x0000, 0x005f, 0x0000,
+    0x0000, 0x0000, 0x2218, 0x0000, 0x2395, 0x0000, 0x22a4, 0x25cb,
+    0x0000, 0x0000, 0x0000, 0x2308, 0x0000, 0x0000, 0x222a, 0x0000,
+    0x2283, 0x0000, 0x2282, 0x0000, 0x22a2, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+    0x0000, 0x0000, 0x0000, 0x0000, 0x22a3, 0x0000, 0x0000, 0x0000
+};
+
+static const unsigned short koreanKeysymsToUnicode[] = {
+    0x0000, 0x3131, 0x3132, 0x3133, 0x3134, 0x3135, 0x3136, 0x3137,
+    0x3138, 0x3139, 0x313a, 0x313b, 0x313c, 0x313d, 0x313e, 0x313f,
+    0x3140, 0x3141, 0x3142, 0x3143, 0x3144, 0x3145, 0x3146, 0x3147,
+    0x3148, 0x3149, 0x314a, 0x314b, 0x314c, 0x314d, 0x314e, 0x314f,
+    0x3150, 0x3151, 0x3152, 0x3153, 0x3154, 0x3155, 0x3156, 0x3157,
+    0x3158, 0x3159, 0x315a, 0x315b, 0x315c, 0x315d, 0x315e, 0x315f,
+    0x3160, 0x3161, 0x3162, 0x3163, 0x11a8, 0x11a9, 0x11aa, 0x11ab,
+    0x11ac, 0x11ad, 0x11ae, 0x11af, 0x11b0, 0x11b1, 0x11b2, 0x11b3,
+    0x11b4, 0x11b5, 0x11b6, 0x11b7, 0x11b8, 0x11b9, 0x11ba, 0x11bb,
+    0x11bc, 0x11bd, 0x11be, 0x11bf, 0x11c0, 0x11c1, 0x11c2, 0x316d,
+    0x3171, 0x3178, 0x317f, 0x3181, 0x3184, 0x3186, 0x318d, 0x318e,
+    0x11eb, 0x11f0, 0x11f9, 0x0000, 0x0000, 0x0000, 0x0000, 0x20a9
+};
+
+
+static QChar keysymToUnicode(unsigned char byte3, unsigned char byte4)
+{
+    if ( byte3 == 0x04 ) {
+        // katakana
+        if ( byte4 > 0xa0 && byte4 < 0xe0 )
+           return QChar( katakanaKeysymsToUnicode[byte4 - 0xa0] );
+        else if ( byte4 == 0x7e )
+            return QChar( 0x203e ); // Overline
+    } else if ( byte3 == 0x06 ) {
+	// russian, use lookup table
+	if ( byte4 > 0xa0 )
+	    return QChar( cyrillicKeysymsToUnicode[byte4 - 0xa0] );
+    } else if ( byte3 == 0x07 ) {
+	// greek
+	if ( byte4 > 0xa0 )
+	    return QChar( greekKeysymsToUnicode[byte4 - 0xa0] );
+    } else if ( byte3 == 0x08 ) {
+       // technical
+       if ( byte4 > 0xa0 )
+           return QChar( technicalKeysymsToUnicode[byte4 - 0xa0] );
+    } else if ( byte3 == 0x09 ) {
+       // special
+       if ( byte4 >= 0xe0 )
+           return QChar( specialKeysymsToUnicode[byte4 - 0xe0] );
+    } else if ( byte3 == 0x0a ) {
+       // publishing
+       if ( byte4 > 0xa0 )
+           return QChar( publishingKeysymsToUnicode[byte4 - 0xa0] );
+    } else if ( byte3 == 0x0b ) {
+       // APL
+       if ( byte4 > 0xa0 )
+           return QChar( aplKeysymsToUnicode[byte4 - 0xa0] );
+    } else if ( byte3 == 0x0e ) {
+       // Korean
+       if ( byte4 > 0xa0 )
+           return QChar( koreanKeysymsToUnicode[byte4 - 0xa0] );
+    }
+    return QChar(0x0);
+}
+#endif
+
+
+bool QETWidget::translateKeyEventInternal( const XEvent *event, int& count,
+					   QString& text,
+					   int& state,
+					   char& ascii, int& code, QEvent::Type &type, bool willRepeat )
+{
+    QTextCodec *mapper = input_mapper;
+    // some XmbLookupString implementations don't return buffer overflow correctly,
+    // so we increase the input buffer to allow for long strings...
+    // 256 chars * 2 bytes + 1 null-term == 513 bytes
+    QCString chars(513);
+    QChar converted;
+    KeySym key = 0;
+
+    if ( !keyDict ) {
+	keyDict = new QIntDict<void>( 13 );
+	keyDict->setAutoDelete( FALSE );
+	textDict = new QIntDict<void>( 13 );
+	textDict->setAutoDelete( FALSE );
+	qAddPostRoutine( deleteKeyDicts );
+    }
+
+    QWidget* tlw = topLevelWidget();
+
+    XKeyEvent xkeyevent = event->xkey;
+
+    // save the modifier state, we will use the keystate uint later by passing
+    // it to qt_x11_translateButtonState
+    uint keystate = event->xkey.state;
+    // remove the modifiers where mode_switch exists... HPUX machines seem
+    // to have alt *AND* mode_switch both in Mod1Mask, which causes
+    // XLookupString to return things like '' (aring) for ALT-A.  This
+    // completely breaks modifiers.  If we remove the modifier for Mode_switch,
+    // then things work correctly...
+    xkeyevent.state &= ~qt_mode_switch_remove_mask;
+
+    type = (event->type == XKeyPress)
+           ? QEvent::KeyPress : QEvent::KeyRelease;
+#if defined(QT_NO_XIM)
+
+    count = XLookupString( &xkeyevent, chars.data(), chars.size(), &key, 0 );
+
+    if ( count == 1 )
+	ascii = chars[0];
+
+#else
+    // Implementation for X11R5 and newer, using XIM
+
+    int	       keycode = event->xkey.keycode;
+    Status     status;
+
+    if ( type == QEvent::KeyPress ) {
+	bool mb=FALSE;
+	if ( qt_xim ) {
+	    QTLWExtra*  xd = tlw->topData();
+	    QInputContext *qic = (QInputContext *) xd->xic;
+	    if ( qic ) {
+		mb=TRUE;
+		count = qic->lookupString(&xkeyevent, chars, &key, &status);
+	    }
+	}
+	if ( !mb ) {
+	    count = XLookupString( &xkeyevent,
+				   chars.data(), chars.size(), &key, 0 );
+	}
+	if ( count && !keycode ) {
+	    keycode = composingKeycode;
+	    composingKeycode = 0;
+	}
+	if ( key )
+	    keyDict->replace( keycode, (void*)key );
+	// all keysyms smaller than that are actally keys that can be mapped
+	// to unicode chars
+	if ( count == 0 && key < 0xff00 ) {
+	    unsigned char byte3 = (unsigned char )(key >> 8);
+	    int mib = -1;
+	    switch( byte3 ) {
+	    case 0: // Latin 1
+	    case 1: // Latin 2
+	    case 2: //latin 3
+	    case 3: // latin4
+		mib = byte3 + 4; break;
+	    case 5: // arabic
+		mib = 82; break;
+	    case 12: // Hebrew
+		mib = 85; break;
+	    case 13: // Thai
+		mib = 2259; break;
+	    case 4: // kana
+	    case 6: // cyrillic
+	    case 7: // greek
+	    case 8: // technical, no mapping here at the moment
+	    case 9: // Special
+	    case 10: // Publishing
+	    case 11: // APL
+	    case 14: // Korean, no mapping
+		mib = -1; // manual conversion
+		mapper = 0;
+		converted = keysymToUnicode( byte3, key & 0xff );
+	    case 0x20:
+		// currency symbols
+		if ( key >= 0x20a0 && key <= 0x20ac ) {
+		    mib = -1; // manual conversion
+		    mapper = 0;
+		    converted = (uint)key;
+		}
+		break;
+	    default:
+		break;
+	    }
+	    if ( mib != -1 ) {
+		mapper = QTextCodec::codecForMib( mib );
+		chars[0] = (unsigned char) (key & 0xff); // get only the fourth bit for conversion later
+		count++;
+	    }
+	} else if ( key >= 0x1000000 && key <= 0x100ffff ) {
+	    converted = (ushort) (key - 0x1000000);
+	    mapper = 0;
+	}
+	if ( count < (int)chars.size()-1 )
+	    chars[count] = '\0';
+	if ( count == 1 ) {
+	    ascii = chars[0];
+	    // +256 so we can store all eight-bit codes, including ascii 0,
+	    // and independent of whether char is signed or not.
+	    textDict->replace( keycode, (void*)(256+ascii) );
+	}
+	tlw = 0;
+    } else {
+	key = (int)(long)keyDict->find( keycode );
+	if ( key )
+	    if( !willRepeat ) // Take out key of dictionary only if this call.
+		keyDict->take( keycode );
+	long s = (long)textDict->find( keycode );
+	if ( s ) {
+	    textDict->take( keycode );
+	    ascii = (char)(s-256);
+	}
+    }
+#endif // !QT_NO_XIM
+
+    state = qt_x11_translateButtonState( keystate );
+
+    static int directionKeyEvent = 0;
+    if ( qt_use_rtl_extensions && type == QEvent::KeyRelease ) {
+	if (directionKeyEvent == Key_Direction_R || directionKeyEvent == Key_Direction_L ) {
+	    type = QEvent::KeyPress;
+	    code = directionKeyEvent;
+	    chars[0] = 0;
+	    directionKeyEvent = 0;
+	    return TRUE;
+	} else {
+	    directionKeyEvent = 0;
+	}
+    }
+
+    // Watch for keypresses and if its a key belonging to the Ctrl-Shift
+    // direction-changing accel, remember it.
+    // We keep track of those keys instead of using the event's state
+    // (to figure out whether the Ctrl modifier is held while Shift is pressed,
+    // or Shift is held while Ctrl is pressed) since the 'state' doesn't tell
+    // us whether the modifier held is Left or Right.
+    if (qt_use_rtl_extensions && type  == QEvent::KeyPress)
+        if (key == XK_Control_L || key == XK_Control_R || key == XK_Shift_L || key == XK_Shift_R) {
+           if (!directionKeyEvent)
+	      directionKeyEvent = key;
+        } else {
+           // this can no longer be a direction-changing accel.
+	   // if any other key was pressed.
+           directionKeyEvent = Key_Space;
+        }
+
+    // Commentary in X11/keysymdef says that X codes match ASCII, so it
+    // is safe to use the locale functions to process X codes in ISO8859-1.
+    //
+    // This is mainly for compatibility - applications should not use the
+    // Qt keycodes between 128 and 255, but should rather use the
+    // QKeyEvent::text().
+    //
+    if ( key < 128 || (key < 256 && (!input_mapper || input_mapper->mibEnum()==4)) ) {
+	code = isprint((int)key) ? toupper((int)key) : 0; // upper-case key, if known
+    } else if ( key >= XK_F1 && key <= XK_F35 ) {
+	code = Key_F1 + ((int)key - XK_F1);	// function keys
+    } else if ( key >= XK_KP_0 && key <= XK_KP_9) {
+	code = Key_0 + ((int)key - XK_KP_0);	// numeric keypad keys
+	state |= Keypad;
+    } else {
+	int i = 0;				// any other keys
+	while ( KeyTbl[i] ) {
+	    if ( key == KeyTbl[i] ) {
+		code = (int)KeyTbl[i+1];
+		break;
+	    }
+	    i += 2;
+	}
+	switch ( key ) {
+	case XK_KP_Insert:
+	case XK_KP_Delete:
+	case XK_KP_Home:
+	case XK_KP_End:
+	case XK_KP_Left:
+	case XK_KP_Up:
+	case XK_KP_Right:
+	case XK_KP_Down:
+	case XK_KP_Prior:
+	case XK_KP_Next:
+	case XK_KP_Space:
+	case XK_KP_Tab:
+	case XK_KP_Enter:
+	case XK_KP_Equal:
+	case XK_KP_Multiply:
+	case XK_KP_Add:
+	case XK_KP_Separator:
+	case XK_KP_Subtract:
+	case XK_KP_Decimal:
+	case XK_KP_Divide:
+	    state |= Keypad;
+	    break;
+	default:
+	    break;
+	}
+
+	if ( code == Key_Tab &&
+	     (state & ShiftButton) == ShiftButton ) {
+            // map shift+tab to shift+backtab, QAccel knows about it
+            // and will handle it.
+	    code = Key_Backtab;
+	    chars[0] = 0;
+	}
+
+	if ( qt_use_rtl_extensions && type  == QEvent::KeyPress ) {
+	    if ( directionKeyEvent ) {
+		if ( key == XK_Shift_L && directionKeyEvent == XK_Control_L ||
+		     key == XK_Control_L && directionKeyEvent == XK_Shift_L ) {
+		    directionKeyEvent = Key_Direction_L;
+		} else if ( key == XK_Shift_R && directionKeyEvent == XK_Control_R ||
+			    key == XK_Control_R && directionKeyEvent == XK_Shift_R ) {
+		    directionKeyEvent = Key_Direction_R;
+		}
+	    }
+	    else if ( directionKeyEvent == Key_Direction_L || directionKeyEvent == Key_Direction_R ) {
+		directionKeyEvent = Key_Space; // invalid
+	    }
+	}
+    }
+
+#if 0
+#ifndef Q_EE
+    static int c  = 0;
+    extern void qt_dialog_default_key();
+#define Q_EE(x) c = (c == x || (!c && x == 0x1000) )? x+1 : 0
+    if ( tlw && state == '0' ) {
+	switch ( code ) {
+	case 0x4f: Q_EE(Key_Backtab); break;
+	case 0x52: Q_EE(Key_Tab); break;
+	case 0x54: Q_EE(Key_Escape); break;
+	case 0x4c:
+	    if (c == Key_Return )
+		qt_dialog_default_key();
+	    else
+		Q_EE(Key_Backspace);
+	    break;
+	}
+    }
+#undef Q_EE
+#endif
+#endif
+
+    // convert chars (8bit) to text (unicode).
+    if ( mapper )
+	text = mapper->toUnicode(chars,count);
+    else if ( !mapper && converted.unicode() != 0x0 )
+	text = converted;
+    else
+	text = chars;
+    return TRUE;
+}
+
+
+struct qt_auto_repeat_data
+{
+    // match the window and keycode with timestamp delta of 10ms
+    Window window;
+    KeyCode keycode;
+    Time timestamp;
+
+    // queue scanner state
+    bool release;
+    bool error;
+};
+
+#if defined(Q_C_CALLBACKS)
+extern "C" {
+#endif
+
+static Bool qt_keypress_scanner(Display *, XEvent *event, XPointer arg)
+{
+    if (event->type != XKeyPress && event->type != XKeyRelease)
+        return FALSE;
+
+    qt_auto_repeat_data *d = (qt_auto_repeat_data *) arg;
+    if (d->error ||
+        event->xkey.window  != d->window ||
+        event->xkey.keycode != d->keycode)
+        return FALSE;
+
+    if (event->type == XKeyPress) {
+        d->error = (! d->release || event->xkey.time - d->timestamp > 10);
+        return (! d->error);
+    }
+
+    // must be XKeyRelease event
+    if (d->release) {
+        // found a second release
+        d->error = TRUE;
+        return FALSE;
+    }
+
+    // found a single release
+    d->release = TRUE;
+    d->timestamp = event->xkey.time;
+
+    return FALSE;
+}
+
+static Bool qt_keyrelease_scanner(Display *, XEvent *event, XPointer arg)
+{
+    const qt_auto_repeat_data *d = (const qt_auto_repeat_data *) arg;
+    return (event->type == XKeyRelease &&
+            event->xkey.window  == d->window &&
+            event->xkey.keycode == d->keycode);
+}
+
+#if defined(Q_C_CALLBACKS)
+}
+#endif
+
+bool QETWidget::translateKeyEvent( const XEvent *event, bool grab )
+{
+    int	   code = -1;
+    int	   count = 0;
+    int	   state;
+    char   ascii = 0;
+
+    if ( sm_blockUserInput ) // block user interaction during session management
+	return TRUE;
+
+    Display *dpy = x11Display();
+
+    if ( !isEnabled() )
+	return TRUE;
+
+    QEvent::Type type;
+    bool    autor = FALSE;
+    QString text;
+
+    translateKeyEventInternal( event, count, text, state, ascii, code, type,
+			       qt_mode_switch_remove_mask != 0 );
+
+    // once chained accelerators are possible in Qt, the accelavailable code should
+    // be removed completely from Qt, and instead we should use an internal
+    // QAccelManager which we feed key events, and it will tell us if the key
+    // is an accelerator (in which case we return, doing nothing) or a normal
+    // key event
+
+    // process accelerators before doing key compression
+    if ( type == QEvent::KeyPress && !grab ) {
+	// send accel events if the keyboard is not grabbed
+	QKeyEvent a( type, code, ascii, state, text, autor,
+		     QMAX( QMAX(count,1), int(text.length())) );
+	if ( qt_tryAccelEvent( this, &a ) )
+	    return TRUE;
+    }
+
+    long save = 0;
+    if ( qt_mode_switch_remove_mask != 0 ) {
+	save = qt_mode_switch_remove_mask;
+	qt_mode_switch_remove_mask = 0;
+
+	// translate the key event again, but this time apply any Mode_switch
+	// modifiers
+	translateKeyEventInternal( event, count, text, state, ascii, code, type );
+    }
+
+    // compress keys
+    if ( !text.isEmpty() && testWState(WState_CompressKeys) &&
+	 // do not compress keys if the key event we just got above matches
+	 // one of the key ranges used to compute stopCompression
+	 ! ( ( code >= Key_Escape && code <= Key_SysReq ) ||
+	     ( code >= Key_Home && code <= Key_Next ) ||
+	     ( code >= Key_Super_L && code <= Key_Direction_R ) ||
+	     ( ( code == 0 ) && ( ascii == '\n' ) ) ) ) {
+	// the widget wants key compression so it gets it
+	int	codeIntern = -1;
+	int	countIntern = 0;
+	int	stateIntern;
+	char	asciiIntern = 0;
+	XEvent	evRelease;
+	XEvent	evPress;
+
+	// sync the event queue, this makes key compress work better
+	XSync( dpy, FALSE );
+
+	for (;;) {
+	    QString textIntern;
+	    if ( !XCheckTypedWindowEvent(dpy,event->xkey.window,
+					 XKeyRelease,&evRelease) )
+		break;
+	    if ( !XCheckTypedWindowEvent(dpy,event->xkey.window,
+					 XKeyPress,&evPress) ) {
+		XPutBackEvent(dpy, &evRelease);
+		break;
+	    }
+	    QEvent::Type t;
+	    translateKeyEventInternal( &evPress, countIntern, textIntern,
+				       stateIntern, asciiIntern, codeIntern, t );
+	    // use stopCompression to stop key compression for the following
+	    // key event ranges:
+	    bool stopCompression =
+		// 1) misc keys
+		( codeIntern >= Key_Escape && codeIntern <= Key_SysReq ) ||
+		// 2) cursor movement
+		( codeIntern >= Key_Home && codeIntern <= Key_Next ) ||
+		// 3) extra keys
+		( codeIntern >= Key_Super_L && codeIntern <= Key_Direction_R ) ||
+		// 4) something that a) doesn't translate to text or b) translates
+		//    to newline text
+		((codeIntern == 0) && (asciiIntern == '\n'));
+	    if (stateIntern == state && !textIntern.isEmpty() && !stopCompression) {
+		text += textIntern;
+		count += countIntern;
+	    } else {
+		XPutBackEvent(dpy, &evPress);
+		XPutBackEvent(dpy, &evRelease);
+		break;
+	    }
+	}
+    }
+
+    if ( save != 0 )
+	qt_mode_switch_remove_mask = save;
+
+    // was this the last auto-repeater?
+    qt_auto_repeat_data auto_repeat_data;
+    auto_repeat_data.window = event->xkey.window;
+    auto_repeat_data.keycode = event->xkey.keycode;
+    auto_repeat_data.timestamp = event->xkey.time;
+
+    static uint curr_autorep = 0;
+    if ( event->type == XKeyPress ) {
+	if ( curr_autorep == event->xkey.keycode ) {
+	    autor = TRUE;
+	    curr_autorep = 0;
+	}
+    } else {
+	// look ahead for auto-repeat
+        XEvent nextpress;
+
+        auto_repeat_data.release = TRUE;
+        auto_repeat_data.error = FALSE;
+        if (XCheckIfEvent(dpy, &nextpress, &qt_keypress_scanner,
+                          (XPointer) &auto_repeat_data)) {
+            autor = TRUE;
+
+	    // Put it back... we COULD send the event now and not need
+	    // the static curr_autorep variable.
+	    XPutBackEvent(dpy,&nextpress);
+	}
+	curr_autorep = autor ? event->xkey.keycode : 0;
+    }
+
+    // autorepeat compression makes sense for all widgets (Windows
+    // does it automatically .... )
+    if ( event->type == XKeyPress && text.length() <= 1 ) {
+	XEvent dummy;
+
+        for (;;) {
+            auto_repeat_data.release = FALSE;
+            auto_repeat_data.error = FALSE;
+            if (! XCheckIfEvent(dpy, &dummy, &qt_keypress_scanner,
+                                (XPointer) &auto_repeat_data))
+                break;
+            if (! XCheckIfEvent(dpy, &dummy, &qt_keyrelease_scanner,
+                                (XPointer) &auto_repeat_data))
+                break;
+
+	    count++;
+	    if (!text.isEmpty())
+		text += text[0];
+	}
+    }
+
+    if (code == 0 && ascii == '\n') {
+	code = Key_Return;
+	ascii = '\r';
+	text = "\r";
+    }
+
+    // try the menukey first
+    if ( type == QEvent::KeyPress && code == Qt::Key_Menu ) {
+	QContextMenuEvent e( QContextMenuEvent::Keyboard, QPoint( 5, 5 ), mapToGlobal( QPoint( 5, 5 ) ), 0 );
+	QApplication::sendSpontaneousEvent( this, &e );
+	if( e.isAccepted() )
+	    return TRUE;
+    }
+
+    QKeyEvent e( type, code, ascii, state, text, autor,
+		 QMAX(QMAX(count,1), int(text.length())) );
+    return QApplication::sendSpontaneousEvent( this, &e );
+}
+
+
+//
+// Paint event translation
+//
+// When receiving many expose events, we compress them (union of all expose
+// rectangles) into one event which is sent to the widget.
+
+struct PaintEventInfo {
+    Window window;
+};
+
+#if defined(Q_C_CALLBACKS)
+extern "C" {
+#endif
+
+static Bool isPaintOrScrollDoneEvent( Display *, XEvent *ev, XPointer a )
+{
+    PaintEventInfo *info = (PaintEventInfo *)a;
+    if ( ev->type == Expose || ev->type == GraphicsExpose
+      ||    ev->type == ClientMessage
+	 && ev->xclient.message_type == qt_qt_scrolldone )
+    {
+	if ( ev->xexpose.window == info->window )
+	    return True;
+    }
+    return False;
+}
+
+#if defined(Q_C_CALLBACKS)
+}
+#endif
+
+
+// declared above: static QPtrList<QScrollInProgress> *sip_list = 0;
+
+void qt_insert_sip( QWidget* scrolled_widget, int dx, int dy )
+{
+    if ( !sip_list ) {
+	sip_list = new QPtrList<QScrollInProgress>;
+	sip_list->setAutoDelete( TRUE );
+    }
+
+    QScrollInProgress* sip = new QScrollInProgress( scrolled_widget, dx, dy );
+    sip_list->append( sip );
+
+    XClientMessageEvent client_message;
+    client_message.type = ClientMessage;
+    client_message.window = scrolled_widget->winId();
+    client_message.format = 32;
+    client_message.message_type = qt_qt_scrolldone;
+    client_message.data.l[0] = sip->id;
+
+    XSendEvent( appDpy, scrolled_widget->winId(), False, NoEventMask,
+	(XEvent*)&client_message );
+}
+
+int qt_sip_count( QWidget* scrolled_widget )
+{
+    if ( !sip_list )
+	return 0;
+
+    int sips=0;
+
+    for (QScrollInProgress* sip = sip_list->first();
+	sip; sip=sip_list->next())
+    {
+	if ( sip->scrolled_widget == scrolled_widget )
+	    sips++;
+    }
+
+    return sips;
+}
+
+static
+bool translateBySips( QWidget* that, QRect& paintRect )
+{
+    if ( sip_list ) {
+	int dx=0, dy=0;
+	int sips=0;
+	for (QScrollInProgress* sip = sip_list->first();
+	    sip; sip=sip_list->next())
+	{
+	    if ( sip->scrolled_widget == that ) {
+		if ( sips ) {
+		    dx += sip->dx;
+		    dy += sip->dy;
+		}
+		sips++;
+	    }
+	}
+	if ( sips > 1 ) {
+	    paintRect.moveBy( dx, dy );
+	    return TRUE;
+	}
+    }
+    return FALSE;
+}
+
+bool QETWidget::translatePaintEvent( const XEvent *event )
+{
+    setWState( WState_Exposed );
+    QRect  paintRect( event->xexpose.x,	   event->xexpose.y,
+		      event->xexpose.width, event->xexpose.height );
+    bool   merging_okay = !testWFlags(WPaintClever);
+    XEvent xevent;
+    PaintEventInfo info;
+    info.window = winId();
+    bool should_clip = translateBySips( this, paintRect );
+
+    QRegion paintRegion( paintRect );
+
+    if ( merging_okay ) {
+	// WARNING: this is O(number_of_events * number_of_matching_events)
+	while ( XCheckIfEvent(x11Display(),&xevent,isPaintOrScrollDoneEvent,
+			      (XPointer)&info) &&
+		!qt_x11EventFilter(&xevent)  &&
+		!x11Event( &xevent ) ) // send event through filter
+	{
+	    if ( xevent.type == Expose || xevent.type == GraphicsExpose ) {
+		QRect exposure(xevent.xexpose.x,
+			       xevent.xexpose.y,
+			       xevent.xexpose.width,
+			       xevent.xexpose.height);
+		if ( translateBySips( this, exposure ) )
+		    should_clip = TRUE;
+		paintRegion = paintRegion.unite( exposure );
+	    } else {
+		translateScrollDoneEvent( &xevent );
+	    }
+	}
+    }
+
+    if ( should_clip ) {
+	paintRegion = paintRegion.intersect( rect() );
+	if ( paintRegion.isEmpty() )
+	    return TRUE;
+    }
+
+    QPaintEvent e( paintRegion );
+    setWState( WState_InPaintEvent );
+    if ( !isTopLevel() && backgroundOrigin() != WidgetOrigin )
+	erase( paintRegion );
+    qt_set_paintevent_clipping( this, paintRegion );
+    QApplication::sendSpontaneousEvent( this, &e );
+    qt_clear_paintevent_clipping();
+    clearWState( WState_InPaintEvent );
+    return TRUE;
+}
+
+//
+// Scroll-done event translation.
+//
+
+bool QETWidget::translateScrollDoneEvent( const XEvent *event )
+{
+    if ( !sip_list ) return FALSE;
+
+    long id = event->xclient.data.l[0];
+
+    // Remove any scroll-in-progress record for the given id.
+    for (QScrollInProgress* sip = sip_list->first(); sip; sip=sip_list->next()) {
+	if ( sip->id == id ) {
+	    sip_list->remove( sip_list->current() );
+	    return TRUE;
+	}
+    }
+
+    return FALSE;
+}
+
+
+//
+// ConfigureNotify (window move and resize) event translation
+
+bool QETWidget::translateConfigEvent( const XEvent *event )
+{
+    // config pending is only set on resize, see qwidget_x11.cpp, internalSetGeometry()
+    bool was_resize = testWState( WState_ConfigPending );
+
+    clearWState(WState_ConfigPending);
+
+    if ( isTopLevel() ) {
+	QPoint newCPos( geometry().topLeft() );
+	QSize  newSize( event->xconfigure.width, event->xconfigure.height );
+
+	bool trust = (topData()->parentWinId == None ||
+		      topData()->parentWinId == QPaintDevice::x11AppRootWindow());
+
+	if (event->xconfigure.send_event || trust ) {
+	    // if a ConfigureNotify comes from a real sendevent request, we can
+	    // trust its values.
+	    newCPos.rx() = event->xconfigure.x + event->xconfigure.border_width;
+	    newCPos.ry() = event->xconfigure.y + event->xconfigure.border_width;
+	}
+
+	if ( isVisible() )
+	    QApplication::syncX();
+
+        if (! extra || extra->compress_events) {
+            // ConfigureNotify compression for faster opaque resizing
+            XEvent otherEvent;
+            while ( XCheckTypedWindowEvent( x11Display(), winId(), ConfigureNotify,
+                                            &otherEvent ) ) {
+                if ( qt_x11EventFilter( &otherEvent ) )
+                    continue;
+
+                if (x11Event( &otherEvent ) )
+                    continue;
+
+                if ( otherEvent.xconfigure.event != otherEvent.xconfigure.window )
+                    continue;
+
+                newSize.setWidth( otherEvent.xconfigure.width );
+                newSize.setHeight( otherEvent.xconfigure.height );
+
+                if ( otherEvent.xconfigure.send_event || trust ) {
+                    newCPos.rx() = otherEvent.xconfigure.x +
+                                   otherEvent.xconfigure.border_width;
+                    newCPos.ry() = otherEvent.xconfigure.y +
+                                   otherEvent.xconfigure.border_width;
+                }
+            }
+        }
+
+	QRect cr ( geometry() );
+	if ( newSize != cr.size() ) { // size changed
+	    was_resize = TRUE;
+	    QSize oldSize = size();
+	    cr.setSize( newSize );
+	    crect = cr;
+
+	    if ( isVisible() ) {
+		QResizeEvent e( newSize, oldSize );
+		QApplication::sendSpontaneousEvent( this, &e );
+	    } else {
+		QResizeEvent * e = new QResizeEvent( newSize, oldSize );
+		QApplication::postEvent( this, e );
+	    }
+	}
+
+	if ( newCPos != cr.topLeft() ) { // compare with cpos (exluding frame)
+	    QPoint oldPos = geometry().topLeft();
+	    cr.moveTopLeft( newCPos );
+	    crect = cr;
+	    if ( isVisible() ) {
+		QMoveEvent e( newCPos, oldPos ); // pos (including frame), not cpos
+		QApplication::sendSpontaneousEvent( this, &e );
+	    } else {
+		QMoveEvent * e = new QMoveEvent( newCPos, oldPos );
+		QApplication::postEvent( this, e );
+	    }
+	}
+    } else {
+	XEvent xevent;
+	while ( XCheckTypedWindowEvent(x11Display(),winId(), ConfigureNotify,&xevent) &&
+		!qt_x11EventFilter(&xevent)  &&
+		!x11Event( &xevent ) ) // send event through filter
+	    ;
+    }
+
+    bool transbg = backgroundOrigin() != WidgetOrigin;
+    // we ignore NorthWestGravity at the moment for reversed layout
+    if ( transbg ||
+	 (!testWFlags( WStaticContents ) &&
+	  testWState( WState_Exposed ) && was_resize ) ||
+	 QApplication::reverseLayout() ) {
+	// remove unnecessary paint events from the queue
+	XEvent xevent;
+	while ( XCheckTypedWindowEvent( x11Display(), winId(), Expose, &xevent ) &&
+		! qt_x11EventFilter( &xevent )  &&
+		! x11Event( &xevent ) ) // send event through filter
+	    ;
+	repaint( !testWFlags(WResizeNoErase) || transbg );
+    }
+
+    return TRUE;
+}
+
+
+//
+// Close window event translation.
+//
+bool QETWidget::translateCloseEvent( const XEvent * )
+{
+    return close(FALSE);
+}
+
+
+/*!
+    Sets the text cursor's flash (blink) time to \a msecs
+    milliseconds. The flash time is the time required to display,
+    invert and restore the caret display. Usually the text cursor is
+    displayed for \a msecs/2 milliseconds, then hidden for \a msecs/2
+    milliseconds, but this may vary.
+
+    Note that on Microsoft Windows, calling this function sets the
+    cursor flash time for all windows.
+
+    \sa cursorFlashTime()
+*/
+void  QApplication::setCursorFlashTime( int msecs )
+{
+    cursor_flash_time = msecs;
+}
+
+
+/*!
+    Returns the text cursor's flash (blink) time in milliseconds. The
+    flash time is the time required to display, invert and restore the
+    caret display.
+
+    The default value on X11 is 1000 milliseconds. On Windows, the
+    control panel value is used.
+
+    Widgets should not cache this value since it may be changed at any
+    time by the user changing the global desktop settings.
+
+    \sa setCursorFlashTime()
+*/
+int QApplication::cursorFlashTime()
+{
+    return cursor_flash_time;
+}
+
+/*!
+    Sets the time limit that distinguishes a double click from two
+    consecutive mouse clicks to \a ms milliseconds.
+
+    Note that on Microsoft Windows, calling this function sets the
+    double click interval for all windows.
+
+    \sa doubleClickInterval()
+*/
+
+void QApplication::setDoubleClickInterval( int ms )
+{
+    mouse_double_click_time = ms;
+}
+
+
+/*!
+    Returns the maximum duration for a double click.
+
+    The default value on X11 is 400 milliseconds. On Windows, the
+    control panel value is used.
+
+    \sa setDoubleClickInterval()
+*/
+
+int QApplication::doubleClickInterval()
+{
+    return mouse_double_click_time;
+}
+
+
+/*!
+    Sets the number of lines to scroll when the mouse wheel is rotated
+    to \a n.
+
+    If this number exceeds the number of visible lines in a certain
+    widget, the widget should interpret the scroll operation as a
+    single page up / page down operation instead.
+
+    \sa wheelScrollLines()
+*/
+void QApplication::setWheelScrollLines( int n )
+{
+    wheel_scroll_lines = n;
+}
+
+/*!
+    Returns the number of lines to scroll when the mouse wheel is
+    rotated.
+
+    \sa setWheelScrollLines()
+*/
+int QApplication::wheelScrollLines()
+{
+    return wheel_scroll_lines;
+}
+
+/*!
+    Enables the UI effect \a effect if \a enable is TRUE, otherwise
+    the effect will not be used.
+
+    Note: All effects are disabled on screens running at less than
+    16-bit color depth.
+
+    \sa isEffectEnabled(), Qt::UIEffect, setDesktopSettingsAware()
+*/
+void QApplication::setEffectEnabled( Qt::UIEffect effect, bool enable )
+{
+    switch (effect) {
+    case UI_AnimateMenu:
+	if ( enable ) fade_menu = FALSE;
+	animate_menu = enable;
+	break;
+    case UI_FadeMenu:
+	if ( enable )
+	    animate_menu = TRUE;
+	fade_menu = enable;
+	break;
+    case UI_AnimateCombo:
+	animate_combo = enable;
+	break;
+    case UI_AnimateTooltip:
+	if ( enable ) fade_tooltip = FALSE;
+	animate_tooltip = enable;
+	break;
+    case UI_FadeTooltip:
+	if ( enable )
+	    animate_tooltip = TRUE;
+	fade_tooltip = enable;
+	break;
+    case UI_AnimateToolBox:
+	animate_toolbox = enable;
+	break;
+    default:
+	animate_ui = enable;
+	break;
+    }
+}
+
+/*!
+    Returns TRUE if \a effect is enabled; otherwise returns FALSE.
+
+    By default, Qt will try to use the desktop settings. Call
+    setDesktopSettingsAware(FALSE) to prevent this.
+
+    Note: All effects are disabled on screens running at less than
+    16-bit color depth.
+
+    \sa setEffectEnabled(), Qt::UIEffect
+*/
+bool QApplication::isEffectEnabled( Qt::UIEffect effect )
+{
+    if ( QColor::numBitPlanes() < 16 || !animate_ui )
+	return FALSE;
+
+    switch( effect ) {
+    case UI_AnimateMenu:
+	return animate_menu;
+    case UI_FadeMenu:
+	return fade_menu;
+    case UI_AnimateCombo:
+	return animate_combo;
+    case UI_AnimateTooltip:
+	return animate_tooltip;
+    case UI_FadeTooltip:
+	return fade_tooltip;
+    case UI_AnimateToolBox:
+	return animate_toolbox;
+    default:
+	return animate_ui;
+    }
+}
+
+/*****************************************************************************
+  Session management support
+ *****************************************************************************/
+
+#ifndef QT_NO_SM_SUPPORT
+
+#include <X11/SM/SMlib.h>
+
+class QSessionManagerData
+{
+public:
+    QSessionManagerData( QSessionManager* mgr, QString& id, QString& key )
+	: sm( mgr ), sessionId( id ), sessionKey( key ) {}
+    QSessionManager* sm;
+    QStringList restartCommand;
+    QStringList discardCommand;
+    QString& sessionId;
+    QString& sessionKey;
+    QSessionManager::RestartHint restartHint;
+};
+
+class QSmSocketReceiver : public QObject
+{
+    Q_OBJECT
+public:
+    QSmSocketReceiver( int socket )
+	: QObject(0,0)
+	{
+	    QSocketNotifier* sn = new QSocketNotifier( socket, QSocketNotifier::Read, this );
+	    connect( sn, SIGNAL( activated(int) ), this, SLOT( socketActivated(int) ) );
+	}
+
+public slots:
+     void socketActivated(int);
+};
+
+
+static SmcConn smcConnection = 0;
+static bool sm_interactionActive;
+static bool sm_smActive;
+static int sm_interactStyle;
+static int sm_saveType;
+static bool sm_cancel;
+// static bool sm_waitingForPhase2;  ### never used?!?
+static bool sm_waitingForInteraction;
+static bool sm_isshutdown;
+// static bool sm_shouldbefast;  ### never used?!?
+static bool sm_phase2;
+static bool sm_in_phase2;
+
+static QSmSocketReceiver* sm_receiver = 0;
+
+static void resetSmState();
+static void sm_setProperty( const char* name, const char* type,
+			    int num_vals, SmPropValue* vals);
+static void sm_saveYourselfCallback( SmcConn smcConn, SmPointer clientData,
+				  int saveType, Bool shutdown , int interactStyle, Bool fast);
+static void sm_saveYourselfPhase2Callback( SmcConn smcConn, SmPointer clientData ) ;
+static void sm_dieCallback( SmcConn smcConn, SmPointer clientData ) ;
+static void sm_shutdownCancelledCallback( SmcConn smcConn, SmPointer clientData );
+static void sm_saveCompleteCallback( SmcConn smcConn, SmPointer clientData );
+static void sm_interactCallback( SmcConn smcConn, SmPointer clientData );
+static void sm_performSaveYourself( QSessionManagerData* );
+
+static void resetSmState()
+{
+//    sm_waitingForPhase2 = FALSE; ### never used?!?
+    sm_waitingForInteraction = FALSE;
+    sm_interactionActive = FALSE;
+    sm_interactStyle = SmInteractStyleNone;
+    sm_smActive = FALSE;
+    sm_blockUserInput = FALSE;
+    sm_isshutdown = FALSE;
+//    sm_shouldbefast = FALSE; ### never used?!?
+    sm_phase2 = FALSE;
+    sm_in_phase2 = FALSE;
+}
+
+
+// theoretically it's possible to set several properties at once. For
+// simplicity, however, we do just one property at a time
+static void sm_setProperty( const char* name, const char* type,
+			    int num_vals, SmPropValue* vals)
+{
+    if (num_vals ) {
+      SmProp prop;
+      prop.name = (char*)name;
+      prop.type = (char*)type;
+      prop.num_vals = num_vals;
+      prop.vals = vals;
+
+      SmProp* props[1];
+      props[0] = &prop;
+      SmcSetProperties( smcConnection, 1, props );
+    }
+    else {
+      char* names[1];
+      names[0] = (char*) name;
+      SmcDeleteProperties( smcConnection, 1, names );
+    }
+}
+
+static void sm_setProperty( const QString& name, const QString& value)
+{
+    SmPropValue prop;
+    prop.length = value.length();
+    prop.value = (SmPointer) value.latin1();
+    sm_setProperty( name.latin1(), SmARRAY8, 1, &prop );
+}
+
+static void sm_setProperty( const QString& name, const QStringList& value)
+{
+    SmPropValue *prop = new SmPropValue[ value.count() ];
+    int count = 0;
+    for ( QStringList::ConstIterator it = value.begin(); it != value.end(); ++it ) {
+      prop[ count ].length = (*it).length();
+      prop[ count ].value = (char*)(*it).latin1();
+      ++count;
+    }
+    sm_setProperty( name.latin1(), SmLISTofARRAY8, count, prop );
+    delete [] prop;
+}
+
+
+// workaround for broken libsm, see below
+struct QT_smcConn {
+    unsigned int save_yourself_in_progress : 1;
+    unsigned int shutdown_in_progress : 1;
+};
+
+static void sm_saveYourselfCallback( SmcConn smcConn, SmPointer clientData,
+				  int saveType, Bool shutdown , int interactStyle, Bool /*fast*/)
+{
+    if (smcConn != smcConnection )
+	return;
+    sm_cancel = FALSE;
+    sm_smActive = TRUE;
+    sm_isshutdown = shutdown;
+    sm_saveType = saveType;
+    sm_interactStyle = interactStyle;
+//    sm_shouldbefast = fast; ### never used?!?
+
+    // ugly workaround for broken libSM. libSM should do that _before_
+    // actually invoking the callback in sm_process.c
+    ( (QT_smcConn*)smcConn )->save_yourself_in_progress = TRUE;
+    if ( sm_isshutdown )
+	( (QT_smcConn*)smcConn )->shutdown_in_progress = TRUE;
+
+    sm_performSaveYourself( (QSessionManagerData*) clientData );
+    if ( !sm_isshutdown ) // we cannot expect a confirmation message in that case
+	resetSmState();
+}
+
+static void sm_performSaveYourself( QSessionManagerData* smd )
+{
+    if ( sm_isshutdown )
+	sm_blockUserInput = TRUE;
+
+    QSessionManager* sm = smd->sm;
+
+    // generate a new session key
+    timeval tv;
+    gettimeofday( &tv, 0 );
+    smd->sessionKey  = QString::number( tv.tv_sec ) + "_" + QString::number(tv.tv_usec);
+
+    // tell the session manager about our program in best POSIX style
+    sm_setProperty( SmProgram, QString( qApp->argv()[0] ) );
+    // tell the session manager about our user as well.
+    struct passwd* entry = getpwuid( geteuid() );
+    if ( entry )
+	sm_setProperty( SmUserID, QString::fromLatin1( entry->pw_name ) );
+
+    // generate a restart and discard command that makes sense
+    QStringList restart;
+    restart  << qApp->argv()[0] << "-session" << smd->sessionId + "_" + smd->sessionKey;
+    if (qstricmp(qAppName(), qAppClass()) != 0)
+	restart << "-name" << qAppName();
+    sm->setRestartCommand( restart );
+    QStringList discard;
+    sm->setDiscardCommand( discard );
+
+    switch ( sm_saveType ) {
+    case SmSaveBoth:
+	qApp->commitData( *sm );
+	if ( sm_isshutdown && sm_cancel)
+	    break; // we cancelled the shutdown, no need to save state
+    // fall through
+    case SmSaveLocal:
+	qApp->saveState( *sm );
+	break;
+    case SmSaveGlobal:
+	qApp->commitData( *sm );
+	break;
+    default:
+	break;
+    }
+
+    if ( sm_phase2 && !sm_in_phase2 ) {
+	SmcRequestSaveYourselfPhase2( smcConnection, sm_saveYourselfPhase2Callback, (SmPointer*) smd );
+	sm_blockUserInput = FALSE;
+    }
+    else {
+	// close eventual interaction monitors and cancel the
+	// shutdown, if required. Note that we can only cancel when
+	// performing a shutdown, it does not work for checkpoints
+	if ( sm_interactionActive ) {
+	    SmcInteractDone( smcConnection, sm_isshutdown && sm_cancel);
+	    sm_interactionActive = FALSE;
+	}
+	else if ( sm_cancel && sm_isshutdown ) {
+	    if ( sm->allowsErrorInteraction() ) {
+		SmcInteractDone( smcConnection, True );
+		sm_interactionActive = FALSE;
+	    }
+	}
+
+	// set restart and discard command in session manager
+	sm_setProperty( SmRestartCommand, sm->restartCommand() );
+	sm_setProperty( SmDiscardCommand, sm->discardCommand() );
+
+	// set the restart hint
+	SmPropValue prop;
+	prop.length = sizeof( int );
+	int value = sm->restartHint();
+	prop.value = (SmPointer) &value;
+	sm_setProperty( SmRestartStyleHint, SmCARD8, 1, &prop );
+
+	// we are done
+	SmcSaveYourselfDone( smcConnection, !sm_cancel );
+    }
+}
+
+static void sm_dieCallback( SmcConn smcConn, SmPointer /* clientData  */)
+{
+    if (smcConn != smcConnection )
+	return;
+    resetSmState();
+    QEvent quitEvent(QEvent::Quit);
+    QApplication::sendEvent(qApp, &quitEvent);
+}
+
+static void sm_shutdownCancelledCallback( SmcConn smcConn, SmPointer /* clientData */)
+{
+    if (smcConn != smcConnection )
+	return;
+    if ( sm_waitingForInteraction )
+	qApp->exit_loop();
+    resetSmState();
+}
+
+static void sm_saveCompleteCallback( SmcConn smcConn, SmPointer /*clientData */)
+{
+    if (smcConn != smcConnection )
+	return;
+    resetSmState();
+}
+
+static void sm_interactCallback( SmcConn smcConn, SmPointer /* clientData */ )
+{
+    if (smcConn != smcConnection )
+	return;
+    if ( sm_waitingForInteraction )
+	qApp->exit_loop();
+}
+
+static void sm_saveYourselfPhase2Callback( SmcConn smcConn, SmPointer clientData )
+{
+    if (smcConn != smcConnection )
+	return;
+    sm_in_phase2 = TRUE;
+    sm_performSaveYourself( (QSessionManagerData*) clientData );
+}
+
+
+void QSmSocketReceiver::socketActivated(int)
+{
+    IceProcessMessages( SmcGetIceConnection( smcConnection ), 0, 0);
+}
+
+
+#undef Bool
+#include "qapplication_x11.moc"
+
+QSessionManager::QSessionManager( QApplication * app, QString &id, QString& key )
+    : QObject( app, "session manager" )
+{
+    d = new QSessionManagerData( this, id, key );
+    d->restartHint = RestartIfRunning;
+
+    resetSmState();
+    char cerror[256];
+    char* myId = 0;
+    char* prevId = (char*)id.latin1(); // we know what we are doing
+
+    SmcCallbacks cb;
+    cb.save_yourself.callback = sm_saveYourselfCallback;
+    cb.save_yourself.client_data = (SmPointer) d;
+    cb.die.callback = sm_dieCallback;
+    cb.die.client_data = (SmPointer) d;
+    cb.save_complete.callback = sm_saveCompleteCallback;
+    cb.save_complete.client_data = (SmPointer) d;
+    cb.shutdown_cancelled.callback = sm_shutdownCancelledCallback;
+    cb.shutdown_cancelled.client_data = (SmPointer) d;
+
+    // avoid showing a warning message below
+    const char* session_manager = getenv("SESSION_MANAGER");
+    if ( !session_manager || !session_manager[0] )
+	return;
+
+    smcConnection = SmcOpenConnection( 0, 0, 1, 0,
+				       SmcSaveYourselfProcMask |
+				       SmcDieProcMask |
+				       SmcSaveCompleteProcMask |
+				       SmcShutdownCancelledProcMask,
+				       &cb,
+				       prevId,
+				       &myId,
+				       256, cerror );
+
+    id = QString::fromLatin1( myId );
+    ::free( myId ); // it was allocated by C
+
+    QString error = cerror;
+    if (!smcConnection ) {
+	qWarning("Session management error: %s", error.latin1() );
+    }
+    else {
+	sm_receiver = new QSmSocketReceiver(  IceConnectionNumber( SmcGetIceConnection( smcConnection ) ) );
+    }
+}
+
+QSessionManager::~QSessionManager()
+{
+    if ( smcConnection )
+      SmcCloseConnection( smcConnection, 0, 0 );
+    smcConnection = 0;
+    delete sm_receiver;
+    delete d;
+}
+
+QString QSessionManager::sessionId() const
+{
+    return d->sessionId;
+}
+
+QString QSessionManager::sessionKey() const
+{
+    return d->sessionKey;
+}
+
+
+void* QSessionManager::handle() const
+{
+    return (void*) smcConnection;
+}
+
+
+bool QSessionManager::allowsInteraction()
+{
+    if ( sm_interactionActive )
+	return TRUE;
+
+    if ( sm_waitingForInteraction )
+	return FALSE;
+
+    if ( sm_interactStyle == SmInteractStyleAny ) {
+	sm_waitingForInteraction =  SmcInteractRequest( smcConnection, SmDialogNormal,
+							sm_interactCallback, (SmPointer*) this );
+    }
+    if ( sm_waitingForInteraction ) {
+	qApp->enter_loop();
+	sm_waitingForInteraction = FALSE;
+	if ( sm_smActive ) { // not cancelled
+	    sm_interactionActive = TRUE;
+	    sm_blockUserInput = FALSE;
+	    return TRUE;
+	}
+    }
+    return FALSE;
+}
+
+bool QSessionManager::allowsErrorInteraction()
+{
+    if ( sm_interactionActive )
+	return TRUE;
+
+    if ( sm_waitingForInteraction )
+	return FALSE;
+
+    if ( sm_interactStyle == SmInteractStyleAny || sm_interactStyle == SmInteractStyleErrors ) {
+	sm_waitingForInteraction =  SmcInteractRequest( smcConnection, SmDialogError,
+							sm_interactCallback, (SmPointer*) this );
+    }
+    if ( sm_waitingForInteraction ) {
+	qApp->enter_loop();
+	sm_waitingForInteraction = FALSE;
+	if ( sm_smActive ) { // not cancelled
+	    sm_interactionActive = TRUE;
+	    sm_blockUserInput = FALSE;
+	    return TRUE;
+	}
+    }
+    return FALSE;
+}
+
+void QSessionManager::release()
+{
+    if ( sm_interactionActive ) {
+	SmcInteractDone( smcConnection, False );
+	sm_interactionActive = FALSE;
+	if ( sm_smActive && sm_isshutdown )
+	    sm_blockUserInput = TRUE;
+    }
+}
+
+void QSessionManager::cancel()
+{
+    sm_cancel = TRUE;
+}
+
+void QSessionManager::setRestartHint( QSessionManager::RestartHint hint)
+{
+    d->restartHint = hint;
+}
+
+QSessionManager::RestartHint QSessionManager::restartHint() const
+{
+    return d->restartHint;
+}
+
+void QSessionManager::setRestartCommand( const QStringList& command)
+{
+    d->restartCommand = command;
+}
+
+QStringList QSessionManager::restartCommand() const
+{
+    return d->restartCommand;
+}
+
+void QSessionManager::setDiscardCommand( const QStringList& command)
+{
+    d->discardCommand = command;
+}
+
+QStringList QSessionManager::discardCommand() const
+{
+    return d->discardCommand;
+}
+
+void QSessionManager::setManagerProperty( const QString& name, const QString& value)
+{
+    SmPropValue prop;
+    prop.length = value.length();
+    prop.value = (SmPointer) value.utf8().data();
+    sm_setProperty( name.latin1(), SmARRAY8, 1, &prop );
+}
+
+void QSessionManager::setManagerProperty( const QString& name, const QStringList& value)
+{
+    SmPropValue *prop = new SmPropValue[ value.count() ];
+    int count = 0;
+    for ( QStringList::ConstIterator it = value.begin(); it != value.end(); ++it ) {
+      prop[ count ].length = (*it).length();
+      prop[ count ].value = (char*)(*it).utf8().data();
+      ++count;
+    }
+    sm_setProperty( name.latin1(), SmLISTofARRAY8, count, prop );
+    delete [] prop;
+}
+
+bool QSessionManager::isPhase2() const
+{
+    return sm_in_phase2;
+}
+
+void QSessionManager::requestPhase2()
+{
+    sm_phase2 = TRUE;
+}
+
+
+#endif // QT_NO_SM_SUPPORT
diff -Nru qt-x11-free-3.3.3.orig/src/kernel/qclipboard_x11.cpp qt-x11-free-3.3.3/src/kernel/qclipboard_x11.cpp
--- qt-x11-free-3.3.3.orig/src/kernel/qclipboard_x11.cpp	2004-08-22 13:20:57.193999432 +0200
+++ qt-x11-free-3.3.3/src/kernel/qclipboard_x11.cpp	2004-08-22 13:24:12.988978379 +0200
@@ -109,6 +109,7 @@
 static bool pending_clipboard_changed = FALSE;
 static bool pending_selection_changed = FALSE;
 
+Q_EXPORT bool qt_qclipboard_bailout_hack = false;
 
 // event capture mechanism for qt_xclb_wait_for_event
 static bool waiting_for_data = FALSE;
@@ -453,6 +454,15 @@
     return 0;
 }
 
+static bool selection_request_pending = false;
+
+static Bool check_selection_request_pending( Display*, XEvent* e, XPointer )
+    {
+    if( e->type == SelectionRequest && e->xselectionrequest.owner == owner->winId())
+        selection_request_pending = true;
+    return False;
+    }
+
 bool qt_xclb_wait_for_event( Display *dpy, Window win, int type, XEvent *event,
 			     int timeout )
 {
@@ -504,6 +514,14 @@
     do {
         if ( XCheckTypedWindowEvent(dpy,win,type,event) )
 	    return TRUE;
+        if( qt_qclipboard_bailout_hack ) {
+            XEvent dummy;
+            selection_request_pending = false;
+            if ( owner != NULL )
+                XCheckIfEvent(dpy,&dummy,check_selection_request_pending,NULL);
+            if( selection_request_pending )
+	        return TRUE;
+        }
 
 	now = QTime::currentTime();
 	if ( started > now )			// crossed midnight
diff -Nru qt-x11-free-3.3.3.orig/src/kernel/qdesktopwidget_x11.cpp qt-x11-free-3.3.3/src/kernel/qdesktopwidget_x11.cpp
--- qt-x11-free-3.3.3.orig/src/kernel/qdesktopwidget_x11.cpp	2004-08-22 13:20:57.254987885 +0200
+++ qt-x11-free-3.3.3/src/kernel/qdesktopwidget_x11.cpp	2004-08-22 13:23:19.710043055 +0200
@@ -44,6 +44,9 @@
 // defined in qapplication_x11.cpp
 extern Atom qt_net_workarea;
 extern bool qt_net_supports(Atom atom);
+#ifndef QT_NO_XRANDR
+extern bool qt_use_xrandr;
+#endif
 
 // function to update the workarea of the screen
 static bool qt_desktopwidget_workarea_dirty = TRUE;
@@ -154,6 +157,22 @@
 		y = 0;
 		w = WidthOfScreen(ScreenOfDisplay(QPaintDevice::x11AppDisplay(), i));
 		h = HeightOfScreen(ScreenOfDisplay(QPaintDevice::x11AppDisplay(), i));
+
+#ifndef QT_NO_XRANDR
+		if (qt_use_xrandr) {
+		    XRRScreenConfiguration* xrrconfig;
+		    xrrconfig = XRRGetScreenInfo(QPaintDevice::x11AppDisplay(), QPaintDevice::x11AppRootWindow( i ));
+		    Rotation rotation;
+		    XRRConfigCurrentConfiguration(xrrconfig, &rotation);
+		    XRRFreeScreenConfigInfo(xrrconfig);
+
+		    if (rotation & (RR_Rotate_90 | RR_Rotate_270)) {
+			int tmp = h;
+			h = w;
+			w = tmp;
+		    }
+		}
+#endif
 	    }
 
 	rects[i].setRect(x, y, w, h);
diff -Nru qt-x11-free-3.3.3.orig/src/kernel/qdnd_x11.cpp qt-x11-free-3.3.3/src/kernel/qdnd_x11.cpp
--- qt-x11-free-3.3.3.orig/src/kernel/qdnd_x11.cpp	2004-08-22 13:20:57.232992049 +0200
+++ qt-x11-free-3.3.3/src/kernel/qdnd_x11.cpp	2004-08-22 13:23:41.658895998 +0200
@@ -49,13 +49,15 @@
 #include "qdragobject.h"
 #include "qobjectlist.h"
 #include "qcursor.h"
+#include "qbitmap.h"
+#include "qpainter.h"
 
 #include "qt_x11_p.h"
 
 // conflict resolution
 
-// unused, may be used again later: const int XKeyPress = KeyPress;
-// unused, may be used again later: const int XKeyRelease = KeyRelease;
+const int XKeyPress = KeyPress;
+const int XKeyRelease = KeyRelease;
 #undef KeyPress
 #undef KeyRelease
 
@@ -79,6 +81,7 @@
 extern Window qt_x11_findClientWindow( Window, Atom, bool );
 extern Atom qt_wm_state;
 extern Time qt_x_time;
+extern Time qt_x_user_time;
 
 // this stuff is copied from qclb_x11.cpp
 
@@ -112,6 +115,8 @@
 Atom qt_xdnd_type_list;
 const int qt_xdnd_version = 4;
 
+extern int qt_x11_translateButtonState( int s );
+
 // Actions
 //
 // The Xdnd spec allows for user-defined actions. This could be implemented
@@ -196,6 +201,8 @@
 static int qt_xdnd_current_screen = -1;
 // state of dragging... true if dragging, false if not
 bool qt_xdnd_dragging = FALSE;
+// need to check state of keyboard modifiers
+static bool need_modifiers_check = FALSE;
 
 // dict of payload data, sorted by type atom
 static QIntDict<QByteArray> * qt_xdnd_target_data = 0;
@@ -251,20 +258,47 @@
 public:
     QShapedPixmapWidget(int screen = -1) :
 	QWidget(QApplication::desktop()->screen( screen ),
-		0, WStyle_Customize | WStyle_Tool | WStyle_NoBorder | WX11BypassWM )
+		0, WStyle_Customize | WStyle_Tool | WStyle_NoBorder | WX11BypassWM ), oldpmser( 0 ), oldbmser( 0 )
     {
     }
 
-    void setPixmap(QPixmap pm)
+    void setPixmap(QPixmap pm, QPoint hot)
     {
-	if ( pm.mask() ) {
+	int bmser = pm.mask() ? pm.mask()->serialNumber() : 0;
+	if( oldpmser == pm.serialNumber() && oldbmser == bmser
+	    && oldhot == hot )
+	    return;
+	oldpmser = pm.serialNumber();
+	oldbmser = bmser;
+	oldhot = hot;
+	bool hotspot_in = !(hot.x() < 0 || hot.y() < 0 || hot.x() >= pm.width() || hot.y() >= pm.height());
+// if the pixmap has hotspot in its area, make a "hole" in it at that position
+// this will allow XTranslateCoordinates() to find directly the window below the cursor instead
+// of finding this pixmap, and therefore there won't be needed any (slow) search for the window
+// using findRealWindow()
+	if( hotspot_in ) {
+	    QBitmap mask = pm.mask() ? *pm.mask() : QBitmap( pm.width(), pm.height());
+	    if( !pm.mask())
+		mask.fill( Qt::color1 );
+	    QPainter p( &mask );
+	    p.setPen( Qt::color0 );
+	    p.drawPoint( hot.x(), hot.y());
+	    p.end();
+    	    pm.setMask( mask );
+    	    setMask( mask );
+	} else if ( pm.mask() ) {
 	    setMask( *pm.mask() );
 	} else {
 	    clearMask();
 	}
 	resize(pm.width(),pm.height());
 	setErasePixmap(pm);
+	erase();
     }
+private:
+    int oldpmser;
+    int oldbmser;
+    QPoint oldhot;
 };
 
 static QShapedPixmapWidget * qt_xdnd_deco = 0;
@@ -801,6 +835,9 @@
 	//       l[0], qt_xdnd_dragsource_xid );
 	return;
     }
+
+    if( l[2] != 0 )
+        qt_x_user_time = l[2];
     if ( qt_xdnd_source_object )
 	qt_xdnd_source_object->setTarget( qt_xdnd_current_widget );
 
@@ -851,8 +888,59 @@
 
 void QDragManager::timerEvent( QTimerEvent* e )
 {
-    if ( e->timerId() == heartbeat && qt_xdnd_source_sameanswer.isNull() )
-	move( QCursor::pos() );
+    if ( e->timerId() == heartbeat ) {
+        if( need_modifiers_check ) {
+            Window root, child;
+            int root_x, root_y, win_x, win_y;
+            unsigned int mask;
+            XQueryPointer( qt_xdisplay(), qt_xrootwin( qt_xdnd_current_screen ),
+                &root, &child, &root_x, &root_y, &win_x, &win_y, &mask );
+            if( updateMode( (ButtonState)qt_x11_translateButtonState( mask )))
+                qt_xdnd_source_sameanswer = QRect(); // force move
+        }
+        need_modifiers_check = TRUE;
+        if( qt_xdnd_source_sameanswer.isNull() )
+	    move( QCursor::pos() );
+    }
+}
+
+static bool qt_xdnd_was_move = false;
+static bool qt_xdnd_found = false;
+// check whole incoming X queue for move events
+// checking whole queue is done by always returning False in the predicate
+// if there's another move event in the queue, and there's not a mouse button
+// or keyboard or ClientMessage event before it, the current move event
+// may be safely discarded
+// this helps avoiding being overloaded by being flooded from many events
+// from the XServer
+static
+Bool qt_xdnd_predicate( Display*, XEvent* ev, XPointer )
+{
+    if( qt_xdnd_found )
+	return False;
+    if( ev->type == MotionNotify )
+    {
+	qt_xdnd_was_move = true;
+	qt_xdnd_found = true;
+    }
+    if( ev->type == ButtonPress || ev->type == ButtonRelease
+	|| ev->type == XKeyPress || ev->type == XKeyRelease
+	|| ev->type == ClientMessage )
+    {
+	qt_xdnd_was_move = false;
+	qt_xdnd_found = true;
+    }
+    return False;
+}
+
+static
+bool qt_xdnd_another_movement()
+{
+    qt_xdnd_was_move = false;
+    qt_xdnd_found = false;
+    XEvent dummy;
+    XCheckIfEvent( qt_xdisplay(), &dummy, qt_xdnd_predicate, NULL );
+    return qt_xdnd_was_move;
 }
 
 bool QDragManager::eventFilter( QObject * o, QEvent * e)
@@ -877,8 +965,11 @@
 
     if ( e->type() == QEvent::MouseMove ) {
 	QMouseEvent* me = (QMouseEvent *)e;
-	updateMode(me->stateAfter());
-	move( me->globalPos() );
+	if( !qt_xdnd_another_movement()) {
+	    updateMode(me->stateAfter());
+	    move( me->globalPos() );
+	}
+        need_modifiers_check = FALSE;
 	return TRUE;
     } else if ( e->type() == QEvent::MouseButtonRelease ) {
 	qApp->removeEventFilter( this );
@@ -917,9 +1008,11 @@
 	    beingCancelled = FALSE;
 	    qApp->exit_loop();
 	} else {
-	    updateMode(ke->stateAfter());
-	    qt_xdnd_source_sameanswer = QRect(); // force move
-	    move( QCursor::pos() );
+	    if( updateMode(ke->stateAfter())) {
+	        qt_xdnd_source_sameanswer = QRect(); // force move
+	        move( QCursor::pos() );
+            }
+            need_modifiers_check = FALSE;
 	}
 	return TRUE; // Eat all key events
     }
@@ -946,10 +1039,10 @@
 
 
 static Qt::ButtonState oldstate;
-void QDragManager::updateMode( ButtonState newstate )
+bool QDragManager::updateMode( ButtonState newstate )
 {
     if ( newstate == oldstate )
-	return;
+	return false;
     const int both = ShiftButton|ControlButton;
     if ( (newstate & both) == both ) {
 	global_requested_action = QDropEvent::Link;
@@ -973,6 +1066,7 @@
 	}
     }
     oldstate = newstate;
+    return true;
 }
 
 
@@ -1109,7 +1203,7 @@
 	    qt_xdnd_deco->grabMouse();
 	}
     }
-    updatePixmap();
+    updatePixmap( globalPos );
 
     if ( qt_xdnd_source_sameanswer.contains( globalPos ) &&
 	 qt_xdnd_source_sameanswer.isValid() ) {
@@ -1281,9 +1375,9 @@
     drop.format = 32;
     drop.message_type = qt_xdnd_drop;
     drop.data.l[0] = object->source()->winId();
-    drop.data.l[1] = 1 << 24; // flags
-    drop.data.l[2] = 0; // ###
-    drop.data.l[3] = qt_x_time;
+    drop.data.l[1] = 0; // flags
+    drop.data.l[2] = qt_x_time;
+    drop.data.l[3] = 0;
     drop.data.l[4] = 0;
 
     QWidget * w = QWidget::find( qt_xdnd_current_proxy_target );
@@ -1637,6 +1731,7 @@
     qt_xdnd_source_sameanswer = QRect();
     move(QCursor::pos());
     heartbeat = startTimer(200);
+    need_modifiers_check = FALSE;
 
 #ifndef QT_NO_CURSOR
     qApp->setOverrideCursor( arrowCursor );
@@ -1670,7 +1765,7 @@
     // qt_xdnd_source_object persists until we get an xdnd_finish message
 }
 
-void QDragManager::updatePixmap()
+void QDragManager::updatePixmap( const QPoint& cursorPos )
 {
     if ( qt_xdnd_deco ) {
 	QPixmap pm;
@@ -1685,9 +1780,8 @@
 		defaultPm = new QPixmap(default_pm);
 	    pm = *defaultPm;
 	}
-	qt_xdnd_deco->setPixmap(pm);
-	qt_xdnd_deco->move(QCursor::pos()-pm_hot);
-	qt_xdnd_deco->repaint(FALSE);
+	qt_xdnd_deco->setPixmap(pm, pm_hot);
+	qt_xdnd_deco->move(cursorPos-pm_hot);
 	    //if ( willDrop ) {
 	    qt_xdnd_deco->show();
 	    //} else {
@@ -1696,4 +1790,9 @@
     }
 }
 
+void QDragManager::updatePixmap()
+{
+    updatePixmap( QCursor::pos());
+}
+
 #endif // QT_NO_DRAGANDDROP
diff -Nru qt-x11-free-3.3.3.orig/src/kernel/qdnd_x11.cpp~ qt-x11-free-3.3.3/src/kernel/qdnd_x11.cpp~
--- qt-x11-free-3.3.3.orig/src/kernel/qdnd_x11.cpp~	1970-01-01 01:00:00.000000000 +0100
+++ qt-x11-free-3.3.3/src/kernel/qdnd_x11.cpp~	2004-08-22 13:22:29.656504608 +0200
@@ -0,0 +1,1794 @@
+/****************************************************************************
+** $Id: qt/qdnd_x11.cpp   3.3.3   edited Mar 8 13:13 $
+**
+** XDND implementation for Qt.  See http://www.cco.caltech.edu/~jafl/xdnd/
+**
+** Created : 980320
+**
+** Copyright (C) 1992-2003 Trolltech AS.  All rights reserved.
+**
+** This file is part of the kernel module of the Qt GUI Toolkit.
+**
+** This file may be distributed under the terms of the Q Public License
+** as defined by Trolltech AS of Norway and appearing in the file
+** LICENSE.QPL included in the packaging of this file.
+**
+** This file may be distributed and/or modified under the terms of the
+** GNU General Public License version 2 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.
+**
+** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
+** licenses for Unix/X11 may use this file in accordance with the Qt Commercial
+** License Agreement prqovided with the Software.
+**
+** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+**
+** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
+**   information about Qt Commercial License Agreements.
+** See http://www.trolltech.com/qpl/ for QPL licensing information.
+** See http://www.trolltech.com/gpl/ for GPL licensing information.
+**
+** Contact info@trolltech.com if any conditions of this licensing are
+** not clear to you.
+**
+**********************************************************************/
+
+#include "qplatformdefs.h"
+
+#include "qapplication.h"
+
+#ifndef QT_NO_DRAGANDDROP
+
+#include "qwidget.h"
+#include "qintdict.h"
+#include "qdatetime.h"
+#include "qdict.h"
+#include "qguardedptr.h"
+#include "qdragobject.h"
+#include "qobjectlist.h"
+#include "qcursor.h"
+#include "qbitmap.h"
+#include "qpainter.h"
+
+#include "qt_x11_p.h"
+
+// conflict resolution
+
+const int XKeyPress = KeyPress;
+const int XKeyRelease = KeyRelease;
+#undef KeyPress
+#undef KeyRelease
+
+// this stuff is copied from qapp_x11.cpp
+
+extern void qt_x11_intern_atom( const char *, Atom * );
+
+#if defined(Q_C_CALLBACKS)
+extern "C" {
+#endif
+
+extern void qt_ignore_badwindow();
+extern bool qt_badwindow();
+extern void qt_enter_modal( QWidget *widget );
+extern void qt_leave_modal( QWidget *widget );
+
+#if defined(Q_C_CALLBACKS)
+}
+#endif
+
+extern Window qt_x11_findClientWindow( Window, Atom, bool );
+extern Atom qt_wm_state;
+extern Time qt_x_time;
+
+// this stuff is copied from qclb_x11.cpp
+
+extern bool qt_xclb_wait_for_event( Display *dpy, Window win, int type,
+				    XEvent *event, int timeout );
+extern bool qt_xclb_read_property( Display *dpy, Window win, Atom property,
+				   bool deleteProperty,
+				   QByteArray *buffer, int *size, Atom *type,
+				   int *format, bool nullterm );
+extern QByteArray qt_xclb_read_incremental_property( Display *dpy, Window win,
+						     Atom property,
+						     int nbytes, bool nullterm );
+// and all this stuff is copied -into- qapp_x11.cpp
+
+void qt_xdnd_setup();
+void qt_handle_xdnd_enter( QWidget *, const XEvent *, bool );
+void qt_handle_xdnd_position( QWidget *, const XEvent *, bool );
+void qt_handle_xdnd_status( QWidget *, const XEvent *, bool );
+void qt_handle_xdnd_leave( QWidget *, const XEvent *, bool );
+void qt_handle_xdnd_drop( QWidget *, const XEvent *, bool );
+void qt_handle_xdnd_finished( QWidget *, const XEvent *, bool );
+void qt_xdnd_handle_selection_request( const XSelectionRequestEvent * );
+bool qt_xdnd_handle_badwindow();
+// client messages
+Atom qt_xdnd_enter;
+Atom qt_xdnd_position;
+Atom qt_xdnd_status;
+Atom qt_xdnd_leave;
+Atom qt_xdnd_drop;
+Atom qt_xdnd_finished;
+Atom qt_xdnd_type_list;
+const int qt_xdnd_version = 4;
+
+extern int qt_x11_translateButtonState( int s );
+
+// Actions
+//
+// The Xdnd spec allows for user-defined actions. This could be implemented
+// with a registration process in Qt. WE SHOULD do that later.
+//
+Atom qt_xdnd_action_copy;
+Atom qt_xdnd_action_link;
+Atom qt_xdnd_action_move;
+Atom qt_xdnd_action_private;
+static
+QDropEvent::Action xdndaction_to_qtaction(Atom atom)
+{
+    if ( atom == qt_xdnd_action_copy || atom == 0 )
+	return QDropEvent::Copy;
+    if ( atom == qt_xdnd_action_link )
+	return QDropEvent::Link;
+    if ( atom == qt_xdnd_action_move )
+	return QDropEvent::Move;
+    return QDropEvent::Private;
+}
+static
+int qtaction_to_xdndaction(QDropEvent::Action a)
+{
+    switch ( a ) {
+      case QDropEvent::Copy:
+	return qt_xdnd_action_copy;
+      case QDropEvent::Link:
+	return qt_xdnd_action_link;
+      case QDropEvent::Move:
+	return qt_xdnd_action_move;
+      case QDropEvent::Private:
+	return qt_xdnd_action_private;
+      default:
+	return qt_xdnd_action_copy;
+    }
+}
+
+// clean up the stuff used.
+static void qt_xdnd_cleanup();
+
+static void qt_xdnd_send_leave();
+
+// XDND selection
+Atom qt_xdnd_selection;
+// other selection
+static Atom qt_selection_property;
+// INCR
+static Atom qt_incr_atom;
+
+// properties for XDND drop sites
+Atom qt_xdnd_aware;
+Atom qt_xdnd_proxy;
+
+// real variables:
+// xid of current drag source
+static Atom qt_xdnd_dragsource_xid = 0;
+
+// the types in this drop. 100 is no good, but at least it's big.
+const int qt_xdnd_max_type = 100;
+static Atom qt_xdnd_types[qt_xdnd_max_type];
+
+static QIntDict<QCString> * qt_xdnd_drag_types = 0;
+static QDict<Atom> * qt_xdnd_atom_numbers = 0;
+
+// timer used when target wants "continuous" move messages (eg. scroll)
+static int heartbeat = -1;
+// rectangle in which the answer will be the same
+static QRect qt_xdnd_source_sameanswer;
+//static QRect qt_xdnd_target_sameanswer;
+static bool qt_xdnd_target_answerwas;
+// top-level window we sent position to last.
+static Window qt_xdnd_current_target;
+// window to send events to (always valid if qt_xdnd_current_target)
+static Window qt_xdnd_current_proxy_target;
+// widget we forwarded position to last, and local position
+static QGuardedPtr<QWidget> qt_xdnd_current_widget;
+static QPoint qt_xdnd_current_position;
+// time of this drop, as type Atom to save on casts
+static Atom qt_xdnd_source_current_time;
+//NOTUSED static Atom qt_xdnd_target_current_time;
+// screen number containing the pointer... -1 means default
+static int qt_xdnd_current_screen = -1;
+// state of dragging... true if dragging, false if not
+bool qt_xdnd_dragging = FALSE;
+// need to check state of keyboard modifiers
+static bool need_modifiers_check = FALSE;
+
+// dict of payload data, sorted by type atom
+static QIntDict<QByteArray> * qt_xdnd_target_data = 0;
+
+// first drag object, or 0
+static QDragObject * qt_xdnd_source_object = 0;
+
+// Motif dnd
+extern void qt_motifdnd_enable( QWidget *, bool );
+extern QByteArray qt_motifdnd_obtain_data( const char *format );
+extern const char *qt_motifdnd_format( int n );
+
+bool qt_motifdnd_active = FALSE;
+static bool dndCancelled = FALSE;
+
+// Shift/Ctrl handling, and final drop status
+static QDragObject::DragMode drag_mode;
+static QDropEvent::Action global_requested_action = QDropEvent::Copy;
+static QDropEvent::Action global_accepted_action = QDropEvent::Copy;
+
+// for embedding only
+static QWidget* current_embedding_widget  = 0;
+static XEvent last_enter_event;
+
+// cursors
+static QCursor *noDropCursor = 0;
+static QCursor *moveCursor = 0;
+static QCursor *copyCursor = 0;
+static QCursor *linkCursor = 0;
+
+static QPixmap *defaultPm = 0;
+
+static const int default_pm_hotx = -2;
+static const int default_pm_hoty = -16;
+static const char* const default_pm[] = {
+"13 9 3 1",
+".      c None",
+"       c #000000",
+"X      c #FFFFFF",
+"X X X X X X X",
+" X X X X X X ",
+"X ......... X",
+" X.........X ",
+"X ......... X",
+" X.........X ",
+"X ......... X",
+" X X X X X X ",
+"X X X X X X X"
+};
+
+class QShapedPixmapWidget : public QWidget {
+
+public:
+    QShapedPixmapWidget(int screen = -1) :
+	QWidget(QApplication::desktop()->screen( screen ),
+		0, WStyle_Customize | WStyle_Tool | WStyle_NoBorder | WX11BypassWM ), oldpmser( 0 ), oldbmser( 0 )
+    {
+    }
+
+    void setPixmap(QPixmap pm, QPoint hot)
+    {
+	int bmser = pm.mask() ? pm.mask()->serialNumber() : 0;
+	if( oldpmser == pm.serialNumber() && oldbmser == bmser
+	    && oldhot == hot )
+	    return;
+	oldpmser = pm.serialNumber();
+	oldbmser = bmser;
+	oldhot = hot;
+	bool hotspot_in = !(hot.x() < 0 || hot.y() < 0 || hot.x() >= pm.width() || hot.y() >= pm.height());
+// if the pixmap has hotspot in its area, make a "hole" in it at that position
+// this will allow XTranslateCoordinates() to find directly the window below the cursor instead
+// of finding this pixmap, and therefore there won't be needed any (slow) search for the window
+// using findRealWindow()
+	if( hotspot_in ) {
+	    QBitmap mask = pm.mask() ? *pm.mask() : QBitmap( pm.width(), pm.height());
+	    if( !pm.mask())
+		mask.fill( Qt::color1 );
+	    QPainter p( &mask );
+	    p.setPen( Qt::color0 );
+	    p.drawPoint( hot.x(), hot.y());
+	    p.end();
+    	    pm.setMask( mask );
+    	    setMask( mask );
+	} else if ( pm.mask() ) {
+	    setMask( *pm.mask() );
+	} else {
+	    clearMask();
+	}
+	resize(pm.width(),pm.height());
+	setErasePixmap(pm);
+	erase();
+    }
+private:
+    int oldpmser;
+    int oldbmser;
+    QPoint oldhot;
+};
+
+static QShapedPixmapWidget * qt_xdnd_deco = 0;
+
+static QWidget* desktop_proxy = 0;
+
+class QExtraWidget : public QWidget
+{
+public:
+    QWExtra* extraData() { return QWidget::extraData(); }
+    QTLWExtra* topData() { return QWidget::topData(); }
+};
+
+
+static bool qt_xdnd_enable( QWidget* w, bool on )
+{
+    if ( on ) {
+	QWidget * xdnd_widget = 0;
+	if ( w->isDesktop() ) {
+	    if ( desktop_proxy ) // *WE* already have one.
+		return FALSE;
+
+	    // As per Xdnd4, use XdndProxy
+	    XGrabServer( w->x11Display() );
+	    Atom type = None;
+	    int f;
+	    unsigned long n, a;
+	    WId *proxy_id_ptr;
+	    XGetWindowProperty( w->x11Display(), w->winId(),
+		qt_xdnd_proxy, 0, 1, False,
+		XA_WINDOW, &type, &f,&n,&a,(uchar**)&proxy_id_ptr );
+	    WId proxy_id = 0;
+	    if ( type == XA_WINDOW && proxy_id_ptr ) {
+		proxy_id = *proxy_id_ptr;
+		XFree(proxy_id_ptr);
+		proxy_id_ptr = 0;
+		// Already exists. Real?
+		qt_ignore_badwindow();
+		XGetWindowProperty( w->x11Display(), proxy_id,
+		    qt_xdnd_proxy, 0, 1, False,
+		    XA_WINDOW, &type, &f,&n,&a,(uchar**)&proxy_id_ptr );
+		if ( qt_badwindow() || type != XA_WINDOW || !proxy_id_ptr || *proxy_id_ptr != proxy_id ) {
+		    // Bogus - we will overwrite.
+		    proxy_id = 0;
+		}
+	    }
+	    if ( proxy_id_ptr )
+		XFree(proxy_id_ptr);
+
+	    if ( !proxy_id ) {
+		xdnd_widget = desktop_proxy = new QWidget;
+		proxy_id = desktop_proxy->winId();
+		XChangeProperty ( w->x11Display(),
+		    w->winId(), qt_xdnd_proxy,
+		    XA_WINDOW, 32, PropModeReplace,
+		    (unsigned char *)&proxy_id, 1 );
+		XChangeProperty ( w->x11Display(),
+		    proxy_id, qt_xdnd_proxy,
+		    XA_WINDOW, 32, PropModeReplace,
+		    (unsigned char *)&proxy_id, 1 );
+	    }
+
+	    XUngrabServer( w->x11Display() );
+	} else {
+	    xdnd_widget = w->topLevelWidget();
+	}
+	if ( xdnd_widget ) {
+	    Atom atm = (Atom)qt_xdnd_version;
+	    XChangeProperty ( xdnd_widget->x11Display(), xdnd_widget->winId(),
+			      qt_xdnd_aware, XA_ATOM, 32, PropModeReplace,
+			      (unsigned char *)&atm, 1 );
+	    return TRUE;
+	} else {
+	    return FALSE;
+	}
+    } else {
+	if ( w->isDesktop() ) {
+	    XDeleteProperty( w->x11Display(), w->winId(),
+			     qt_xdnd_proxy );
+	    delete desktop_proxy;
+	    desktop_proxy = 0;
+	}
+	return TRUE;
+    }
+}
+
+const char* qt_xdnd_atom_to_str( Atom a )
+{
+    if ( !a ) return 0;
+
+    if ( a == XA_STRING )
+	return "text/plain"; // some Xdnd clients are dumb
+
+    if ( !qt_xdnd_drag_types ) {
+	qt_xdnd_drag_types = new QIntDict<QCString>( 17 );
+	qt_xdnd_drag_types->setAutoDelete( TRUE );
+    }
+    QCString* result;
+    if ( !(result=qt_xdnd_drag_types->find( a )) ) {
+	const char* mimeType = XGetAtomName( QPaintDevice::x11AppDisplay(), a );
+	if ( !mimeType )
+	    return 0; // only happens on protocol error
+	result = new QCString( mimeType );
+	qt_xdnd_drag_types->insert( (long)a, result );
+	XFree((void*)mimeType);
+    }
+    return *result;
+}
+
+Atom* qt_xdnd_str_to_atom( const char *mimeType )
+{
+    if ( !mimeType || !*mimeType )
+	return 0;
+    if ( !qt_xdnd_atom_numbers ) {
+	qt_xdnd_atom_numbers = new QDict<Atom>( 17 );
+	qt_xdnd_atom_numbers->setAutoDelete( TRUE );
+    }
+
+    Atom * result;
+    if ( (result = qt_xdnd_atom_numbers->find( mimeType )) )
+	return result;
+
+    result = new Atom;
+    *result = 0;
+    qt_x11_intern_atom( mimeType, result );
+    qt_xdnd_atom_numbers->insert( mimeType, result );
+    qt_xdnd_atom_to_str( *result );
+
+    return result;
+}
+
+
+void qt_xdnd_setup() {
+    // set up protocol atoms
+    qt_x11_intern_atom( "XdndEnter", &qt_xdnd_enter );
+    qt_x11_intern_atom( "XdndPosition", &qt_xdnd_position );
+    qt_x11_intern_atom( "XdndStatus", &qt_xdnd_status );
+    qt_x11_intern_atom( "XdndLeave", &qt_xdnd_leave );
+    qt_x11_intern_atom( "XdndDrop", &qt_xdnd_drop );
+    qt_x11_intern_atom( "XdndFinished", &qt_xdnd_finished );
+    qt_x11_intern_atom( "XdndTypeList", &qt_xdnd_type_list );
+
+    qt_x11_intern_atom( "XdndSelection", &qt_xdnd_selection );
+
+    qt_x11_intern_atom( "XdndAware", &qt_xdnd_aware );
+    qt_x11_intern_atom( "XdndProxy", &qt_xdnd_proxy );
+
+
+    qt_x11_intern_atom( "XdndActionCopy", &qt_xdnd_action_copy );
+    qt_x11_intern_atom( "XdndActionLink", &qt_xdnd_action_link );
+    qt_x11_intern_atom( "XdndActionMove", &qt_xdnd_action_move );
+    qt_x11_intern_atom( "XdndActionPrivate", &qt_xdnd_action_private );
+
+    qt_x11_intern_atom( "QT_SELECTION", &qt_selection_property );
+    qt_x11_intern_atom( "INCR", &qt_incr_atom );
+
+    qAddPostRoutine( qt_xdnd_cleanup );
+}
+
+
+void qt_xdnd_cleanup()
+{
+    delete qt_xdnd_drag_types;
+    qt_xdnd_drag_types = 0;
+    delete qt_xdnd_atom_numbers;
+    qt_xdnd_atom_numbers = 0;
+    delete qt_xdnd_target_data;
+    qt_xdnd_target_data = 0;
+    delete noDropCursor;
+    noDropCursor = 0;
+    delete copyCursor;
+    copyCursor = 0;
+    delete moveCursor;
+    moveCursor = 0;
+    delete linkCursor;
+    linkCursor = 0;
+    delete defaultPm;
+    defaultPm = 0;
+    delete desktop_proxy;
+    desktop_proxy = 0;
+}
+
+
+static QWidget * find_child( QWidget * tlw, QPoint & p )
+{
+    QWidget * w = tlw;
+
+    p = w->mapFromGlobal( p );
+    bool done = FALSE;
+    while ( !done ) {
+	done = TRUE;
+	if ( ((QExtraWidget*)w)->extraData() &&
+	     ((QExtraWidget*)w)->extraData()->xDndProxy != 0 )
+	    break; // stop searching for widgets under the mouse cursor if found widget is a proxy.
+	if ( w->children() ) {
+	    QObjectListIt it( *w->children() );
+	    it.toLast();
+	    QObject * o;
+	    while( (o=it.current()) ) {
+		--it;
+		if ( o->isWidgetType() &&
+		     ((QWidget*)o)->isVisible() &&
+		     ((QWidget*)o)->geometry().contains( p ) &&
+		     !((QWidget*)o)->isTopLevel()) {
+		    w = (QWidget *)o;
+		    done = FALSE;
+		    p = w->mapFromParent( p );
+		    break;
+		}
+	    }
+	}
+    }
+    return w;
+}
+
+
+static bool checkEmbedded(QWidget* w, const XEvent* xe)
+{
+    if (!w)
+	return FALSE;
+
+    if (current_embedding_widget != 0 && current_embedding_widget != w) {
+	qt_xdnd_current_target = ((QExtraWidget*)current_embedding_widget)->extraData()->xDndProxy;
+	qt_xdnd_current_proxy_target = qt_xdnd_current_target;
+	qt_xdnd_send_leave();
+	qt_xdnd_current_target = 0;
+	qt_xdnd_current_proxy_target = 0;
+	current_embedding_widget = 0;
+    }
+
+    QWExtra* extra = ((QExtraWidget*)w)->extraData();
+    if ( extra && extra->xDndProxy != 0 ) {
+
+	if (current_embedding_widget != w) {
+
+	    last_enter_event.xany.window = extra->xDndProxy;
+	    XSendEvent( QPaintDevice::x11AppDisplay(), extra->xDndProxy, False, NoEventMask,
+			&last_enter_event );
+	    current_embedding_widget = w;
+	}
+
+	((XEvent*)xe)->xany.window = extra->xDndProxy;
+	XSendEvent( QPaintDevice::x11AppDisplay(), extra->xDndProxy, False, NoEventMask,
+		    (XEvent*)xe );
+	qt_xdnd_current_widget = w;
+	return TRUE;
+    }
+    current_embedding_widget = 0;
+    return FALSE;
+}
+
+void qt_handle_xdnd_enter( QWidget *, const XEvent * xe, bool /*passive*/ )
+{
+    //if ( !w->neveHadAChildWithDropEventsOn() )
+	//return; // haven't been set up for dnd
+
+    qt_motifdnd_active = FALSE;
+
+    last_enter_event.xclient = xe->xclient;
+
+    qt_xdnd_target_answerwas = FALSE;
+
+    const long *l = xe->xclient.data.l;
+    int version = (int)(((unsigned long)(l[1])) >> 24);
+
+    if ( version > qt_xdnd_version )
+	return;
+
+    qt_xdnd_dragsource_xid = l[0];
+
+    int j = 0;
+    if ( l[1] & 1 ) {
+	// get the types from XdndTypeList
+	Atom   type = None;
+	int f;
+	unsigned long n, a;
+	Atom *data;
+	XGetWindowProperty( QPaintDevice::x11AppDisplay(), qt_xdnd_dragsource_xid,
+		    qt_xdnd_type_list, 0,
+		    qt_xdnd_max_type, False, XA_ATOM, &type, &f,&n,&a,(uchar**)&data );
+	for ( ; j<qt_xdnd_max_type && j < (int)n; j++ ) {
+	    qt_xdnd_types[j] = data[j];
+	}
+	if ( data )
+	    XFree( (uchar*)data );
+    } else {
+	// get the types from the message
+	int i;
+	for( i=2; i < 5; i++ ) {
+	    qt_xdnd_types[j++] = l[i];
+	}
+    }
+    qt_xdnd_types[j] = 0;
+}
+
+
+
+void qt_handle_xdnd_position( QWidget *w, const XEvent * xe, bool passive )
+{
+    const unsigned long *l = (const unsigned long *)xe->xclient.data.l;
+
+    QPoint p( (l[2] & 0xffff0000) >> 16, l[2] & 0x0000ffff );
+    QWidget * c = find_child( w, p ); // changes p to to c-local coordinates
+
+    if (!passive && checkEmbedded(c, xe))
+	return;
+
+    if ( !c || !c->acceptDrops() && c->isDesktop() ) {
+	return;
+    }
+
+    if ( l[0] != qt_xdnd_dragsource_xid ) {
+	//qDebug( "xdnd drag position from unexpected source (%08lx not %08lx)",
+	//     l[0], qt_xdnd_dragsource_xid );
+	return;
+    }
+
+    XClientMessageEvent response;
+    response.type = ClientMessage;
+    response.window = qt_xdnd_dragsource_xid;
+    response.format = 32;
+    response.message_type = qt_xdnd_status;
+    response.data.l[0] = w->winId();
+    response.data.l[1] = 0; // flags
+    response.data.l[2] = 0; // x, y
+    response.data.l[3] = 0; // w, h
+    response.data.l[4] = 0; // action
+
+    if ( !passive ) { // otherwise just reject
+	while ( c && !c->acceptDrops() && !c->isTopLevel() ) {
+	    p = c->mapToParent( p );
+	    c = c->parentWidget();
+	}
+
+	QRect answerRect( c->mapToGlobal( p ), QSize( 1,1 ) );
+
+	QDragMoveEvent me( p );
+	QDropEvent::Action accepted_action = xdndaction_to_qtaction(l[4]);
+	me.setAction(accepted_action);
+
+	if ( c != qt_xdnd_current_widget ) {
+	    qt_xdnd_target_answerwas = FALSE;
+	    if ( qt_xdnd_current_widget ) {
+		QDragLeaveEvent e;
+		QApplication::sendEvent( qt_xdnd_current_widget, &e );
+	    }
+	    if ( c->acceptDrops() ) {
+		qt_xdnd_current_widget = c;
+		qt_xdnd_current_position = p;
+		//NOTUSED qt_xdnd_target_current_time = l[3]; // will be 0 for xdnd1
+
+		QDragEnterEvent de( p );
+		de.setAction(accepted_action);
+		QApplication::sendEvent( c, &de );
+		if ( de.isAccepted() ) {
+		    me.accept( de.answerRect() );
+		    if ( !de.isActionAccepted() ) // only as a copy (move if we del)
+			accepted_action = QDropEvent::Copy;
+		    else
+			me.acceptAction(TRUE);
+		} else {
+		    me.ignore( de.answerRect() );
+		}
+	    }
+	} else {
+	    if ( qt_xdnd_target_answerwas ) {
+		me.accept();
+		me.acceptAction(global_requested_action == global_accepted_action);
+	    }
+	}
+
+	if ( !c->acceptDrops() ) {
+	    qt_xdnd_current_widget = 0;
+	    answerRect = QRect( p, QSize( 1, 1 ) );
+	} else if ( xdndaction_to_qtaction(l[4]) < QDropEvent::Private ) {
+	    qt_xdnd_current_widget = c;
+	    qt_xdnd_current_position = p;
+	    //NOTUSED qt_xdnd_target_current_time = l[3]; // will be 0 for xdnd1
+
+	    QApplication::sendEvent( c, &me );
+	    qt_xdnd_target_answerwas = me.isAccepted();
+	    if ( me.isAccepted() ) {
+		response.data.l[1] = 1; // yes
+		if ( !me.isActionAccepted() ) // only as a copy (move if we del)
+		    accepted_action = QDropEvent::Copy;
+	    } else {
+		response.data.l[0] = 0;
+	    }
+	    answerRect = me.answerRect().intersect( c->rect() );
+	} else {
+	    response.data.l[0] = 0;
+	    answerRect = QRect( p, QSize( 1, 1 ) );
+	}
+	answerRect = QRect( c->mapToGlobal( answerRect.topLeft() ),
+			    answerRect.size() );
+
+	if ( answerRect.left() < 0 )
+	    answerRect.setLeft( 0 );
+	if ( answerRect.right() > 4096 )
+	    answerRect.setRight( 4096 );
+	if ( answerRect.top() < 0 )
+	    answerRect.setTop( 0 );
+	if ( answerRect.bottom() > 4096 )
+	    answerRect.setBottom( 4096 );
+	if ( answerRect.width() < 0 )
+	    answerRect.setWidth( 0 );
+	if ( answerRect.height() < 0 )
+	    answerRect.setHeight( 0 );
+
+	response.data.l[2] = (answerRect.x() << 16) + answerRect.y();
+	response.data.l[3] = (answerRect.width() << 16) + answerRect.height();
+	response.data.l[4] = qtaction_to_xdndaction(accepted_action);
+	global_accepted_action = accepted_action;
+    }
+
+    QWidget * source = QWidget::find( qt_xdnd_dragsource_xid );
+
+    if ( source && source->isDesktop() && !source->acceptDrops() )
+	source = 0;
+
+    if ( source )
+	qt_handle_xdnd_status( source, (const XEvent *)&response, passive );
+    else
+	XSendEvent( QPaintDevice::x11AppDisplay(), qt_xdnd_dragsource_xid, False,
+		    NoEventMask, (XEvent*)&response );
+}
+
+
+void qt_handle_xdnd_status( QWidget * w, const XEvent * xe, bool /*passive*/ )
+{
+    const unsigned long *l = (const unsigned long *)xe->xclient.data.l;
+    // Messy:  QDragResponseEvent is just a call to QDragManager function
+    global_accepted_action = xdndaction_to_qtaction(l[4]);
+    QDragResponseEvent e( (int)(l[1] & 1) );
+    QApplication::sendEvent( w, &e );
+
+    if ( (int)(l[1] & 2) == 0 ) {
+	QPoint p( (l[2] & 0xffff0000) >> 16, l[2] & 0x0000ffff );
+	QSize s( (l[3] & 0xffff0000) >> 16, l[3] & 0x0000ffff );
+	qt_xdnd_source_sameanswer = QRect( p, s );
+	if ( qt_xdnd_source_sameanswer.isNull() ) {
+	    // Application wants "coninutous" move events
+	}
+    } else {
+	qt_xdnd_source_sameanswer = QRect();
+    }
+}
+
+
+void qt_handle_xdnd_leave( QWidget *w, const XEvent * xe, bool /*passive*/ )
+{
+    //qDebug( "xdnd leave" );
+    if ( !qt_xdnd_current_widget ||
+	 w->topLevelWidget() != qt_xdnd_current_widget->topLevelWidget() ) {
+	return; // sanity
+    }
+
+    if (checkEmbedded(current_embedding_widget, xe)) {
+	current_embedding_widget = 0;
+	qt_xdnd_current_widget = 0;
+	return;
+    }
+
+    const unsigned long *l = (const unsigned long *)xe->xclient.data.l;
+
+    QDragLeaveEvent e;
+    QApplication::sendEvent( qt_xdnd_current_widget, &e );
+
+    if ( l[0] != qt_xdnd_dragsource_xid ) {
+	// This often happens - leave other-process window quickly
+	//qDebug( "xdnd drag leave from unexpected source (%08lx not %08lx",
+	       //l[0], qt_xdnd_dragsource_xid );
+	qt_xdnd_current_widget = 0;
+	return;
+    }
+
+    qt_xdnd_dragsource_xid = 0;
+    qt_xdnd_types[0] = 0;
+    qt_xdnd_current_widget = 0;
+}
+
+
+void qt_xdnd_send_leave()
+{
+    if ( !qt_xdnd_current_target )
+	return;
+
+    XClientMessageEvent leave;
+    leave.type = ClientMessage;
+    leave.window = qt_xdnd_current_target;
+    leave.format = 32;
+    leave.message_type = qt_xdnd_leave;
+    leave.data.l[0] = qt_xdnd_dragsource_xid;
+    leave.data.l[1] = 0; // flags
+    leave.data.l[2] = 0; // x, y
+    leave.data.l[3] = 0; // w, h
+    leave.data.l[4] = 0; // just null
+
+    QWidget * w = QWidget::find( qt_xdnd_current_proxy_target );
+
+    if ( w && w->isDesktop() && !w->acceptDrops() )
+	w = 0;
+
+    if ( w )
+	qt_handle_xdnd_leave( w, (const XEvent *)&leave, FALSE );
+    else
+	XSendEvent( QPaintDevice::x11AppDisplay(), qt_xdnd_current_proxy_target, False,
+		    NoEventMask, (XEvent*)&leave );
+    qt_xdnd_current_target = 0;
+    qt_xdnd_current_proxy_target = 0;
+}
+
+
+
+void qt_handle_xdnd_drop( QWidget *, const XEvent * xe, bool passive )
+{
+    if ( !qt_xdnd_current_widget ) {
+	qt_xdnd_dragsource_xid = 0;
+	return; // sanity
+    }
+
+    if (!passive && checkEmbedded(qt_xdnd_current_widget, xe)){
+	current_embedding_widget = 0;
+	qt_xdnd_dragsource_xid = 0;
+	qt_xdnd_current_widget = 0;
+	return;
+    }
+    const unsigned long *l = (const unsigned long *)xe->xclient.data.l;
+
+    //qDebug( "xdnd drop" );
+
+    if ( l[0] != qt_xdnd_dragsource_xid ) {
+	//qDebug( "xdnd drop from unexpected source (%08lx not %08lx",
+	//       l[0], qt_xdnd_dragsource_xid );
+	return;
+    }
+    if ( qt_xdnd_source_object )
+	qt_xdnd_source_object->setTarget( qt_xdnd_current_widget );
+
+    if ( !passive ) {
+	QDropEvent de( qt_xdnd_current_position );
+	de.setAction( global_accepted_action );
+	QApplication::sendEvent( qt_xdnd_current_widget, &de );
+	if ( !de.isAccepted() ) {
+	    // Ignore a failed drag
+	    global_accepted_action = QDropEvent::Copy;
+	    dndCancelled = TRUE;
+	}
+	XClientMessageEvent finished;
+	finished.type = ClientMessage;
+	finished.window = qt_xdnd_dragsource_xid;
+	finished.format = 32;
+	finished.message_type = qt_xdnd_finished;
+	finished.data.l[0] = qt_xdnd_current_widget?qt_xdnd_current_widget->topLevelWidget()->winId():0;
+	finished.data.l[1] = 0; // flags
+	XSendEvent( QPaintDevice::x11AppDisplay(), qt_xdnd_dragsource_xid, False,
+		    NoEventMask, (XEvent*)&finished );
+    } else {
+	QDragLeaveEvent e;
+	QApplication::sendEvent( qt_xdnd_current_widget, &e );
+    }
+    qt_xdnd_dragsource_xid = 0;
+    qt_xdnd_current_widget = 0;
+}
+
+
+void qt_handle_xdnd_finished( QWidget *, const XEvent * xe, bool passive )
+{
+    const unsigned long *l = (const unsigned long *)xe->xclient.data.l;
+
+    if ( l[0] && (l[0] == qt_xdnd_current_target
+	    || l[0] == qt_xdnd_current_proxy_target) ) {
+	//
+	if ( !passive )
+	    (void ) checkEmbedded( qt_xdnd_current_widget, xe);
+	current_embedding_widget = 0;
+	qt_xdnd_current_target = 0;
+	qt_xdnd_current_proxy_target = 0;
+	delete qt_xdnd_source_object;
+	qt_xdnd_source_object = 0;
+    }
+}
+
+
+void QDragManager::timerEvent( QTimerEvent* e )
+{
+    if ( e->timerId() == heartbeat ) {
+        if( need_modifiers_check ) {
+            Window root, child;
+            int root_x, root_y, win_x, win_y;
+            unsigned int mask;
+            XQueryPointer( qt_xdisplay(), qt_xrootwin( qt_xdnd_current_screen ),
+                &root, &child, &root_x, &root_y, &win_x, &win_y, &mask );
+            if( updateMode( (ButtonState)qt_x11_translateButtonState( mask )))
+                qt_xdnd_source_sameanswer = QRect(); // force move
+        }
+        need_modifiers_check = TRUE;
+        if( qt_xdnd_source_sameanswer.isNull() )
+	    move( QCursor::pos() );
+    }
+}
+
+static bool qt_xdnd_was_move = false;
+static bool qt_xdnd_found = false;
+// check whole incoming X queue for move events
+// checking whole queue is done by always returning False in the predicate
+// if there's another move event in the queue, and there's not a mouse button
+// or keyboard or ClientMessage event before it, the current move event
+// may be safely discarded
+// this helps avoiding being overloaded by being flooded from many events
+// from the XServer
+static
+Bool qt_xdnd_predicate( Display*, XEvent* ev, XPointer )
+{
+    if( qt_xdnd_found )
+	return False;
+    if( ev->type == MotionNotify )
+    {
+	qt_xdnd_was_move = true;
+	qt_xdnd_found = true;
+    }
+    if( ev->type == ButtonPress || ev->type == ButtonRelease
+	|| ev->type == XKeyPress || ev->type == XKeyRelease
+	|| ev->type == ClientMessage )
+    {
+	qt_xdnd_was_move = false;
+	qt_xdnd_found = true;
+    }
+    return False;
+}
+
+static
+bool qt_xdnd_another_movement()
+{
+    qt_xdnd_was_move = false;
+    qt_xdnd_found = false;
+    XEvent dummy;
+    XCheckIfEvent( qt_xdisplay(), &dummy, qt_xdnd_predicate, NULL );
+    return qt_xdnd_was_move;
+}
+
+bool QDragManager::eventFilter( QObject * o, QEvent * e)
+{
+    if ( beingCancelled ) {
+	if ( e->type() == QEvent::KeyRelease &&
+	     ((QKeyEvent*)e)->key() == Key_Escape ) {
+	    qApp->removeEventFilter( this );
+	    object = 0;
+	    dragSource = 0;
+	    beingCancelled = FALSE;
+	    qApp->exit_loop();
+	    return TRUE; // block the key release
+	}
+	return FALSE;
+    }
+
+    Q_ASSERT( object != 0 );
+
+    if ( !o->isWidgetType() )
+	return FALSE;
+
+    if ( e->type() == QEvent::MouseMove ) {
+	QMouseEvent* me = (QMouseEvent *)e;
+	if( !qt_xdnd_another_movement()) {
+	    updateMode(me->stateAfter());
+	    move( me->globalPos() );
+	}
+        need_modifiers_check = FALSE;
+	return TRUE;
+    } else if ( e->type() == QEvent::MouseButtonRelease ) {
+	qApp->removeEventFilter( this );
+	if ( willDrop )
+	    drop();
+	else
+	    cancel();
+	object = 0;
+	dragSource = 0;
+	beingCancelled = FALSE;
+	qApp->exit_loop();
+	return TRUE;
+    } else if ( e->type() == QEvent::DragResponse ) {
+	if ( ((QDragResponseEvent *)e)->dragAccepted() ) {
+	    if ( !willDrop ) {
+		willDrop = TRUE;
+	    }
+	} else {
+	    if ( willDrop ) {
+		willDrop = FALSE;
+	    }
+	}
+	updateCursor();
+	return TRUE;
+    }
+
+    if ( e->type() == QEvent::KeyPress
+      || e->type() == QEvent::KeyRelease )
+    {
+	QKeyEvent *ke = ((QKeyEvent*)e);
+	if ( ke->key() == Key_Escape && e->type() == QEvent::KeyPress ) {
+	    cancel();
+	    qApp->removeEventFilter( this );
+	    object = 0;
+	    dragSource = 0;
+	    beingCancelled = FALSE;
+	    qApp->exit_loop();
+	} else {
+	    if( updateMode(ke->stateAfter())) {
+	        qt_xdnd_source_sameanswer = QRect(); // force move
+	        move( QCursor::pos() );
+            }
+            need_modifiers_check = FALSE;
+	}
+	return TRUE; // Eat all key events
+    }
+
+    // ### We bind modality to widgets, so we have to do this
+    // ###  "manually".
+    // DnD is modal - eat all other interactive events
+    switch ( e->type() ) {
+      case QEvent::MouseButtonPress:
+      case QEvent::MouseButtonRelease:
+      case QEvent::MouseButtonDblClick:
+      case QEvent::MouseMove:
+      case QEvent::KeyPress:
+      case QEvent::KeyRelease:
+      case QEvent::Wheel:
+      case QEvent::Accel:
+      case QEvent::AccelAvailable:
+      case QEvent::AccelOverride:
+	return TRUE;
+      default:
+	return FALSE;
+    }
+}
+
+
+static Qt::ButtonState oldstate;
+bool QDragManager::updateMode( ButtonState newstate )
+{
+    if ( newstate == oldstate )
+	return false;
+    const int both = ShiftButton|ControlButton;
+    if ( (newstate & both) == both ) {
+	global_requested_action = QDropEvent::Link;
+    } else {
+	bool local = qt_xdnd_source_object != 0;
+	if ( drag_mode == QDragObject::DragMove )
+	    global_requested_action = QDropEvent::Move;
+	else if ( drag_mode == QDragObject::DragCopy )
+	    global_requested_action = QDropEvent::Copy;
+	else if ( drag_mode == QDragObject::DragLink )
+	    global_requested_action = QDropEvent::Link;
+	else {
+	    if ( drag_mode == QDragObject::DragDefault && local )
+		global_requested_action = QDropEvent::Move;
+	    else
+		global_requested_action = QDropEvent::Copy;
+	    if ( newstate & ShiftButton )
+		global_requested_action = QDropEvent::Move;
+	    else if ( newstate & ControlButton )
+		global_requested_action = QDropEvent::Copy;
+	}
+    }
+    oldstate = newstate;
+    return true;
+}
+
+
+void QDragManager::updateCursor()
+{
+    if ( !noDropCursor ) {
+	noDropCursor = new QCursor( ForbiddenCursor );
+	if ( !pm_cursor[0].isNull() )
+	    moveCursor = new QCursor(pm_cursor[0], 0,0);
+	if ( !pm_cursor[1].isNull() )
+	    copyCursor = new QCursor(pm_cursor[1], 0,0);
+	if ( !pm_cursor[2].isNull() )
+	    linkCursor = new QCursor(pm_cursor[2], 0,0);
+    }
+
+    QCursor *c;
+    if ( willDrop ) {
+	if ( global_accepted_action == QDropEvent::Copy ) {
+	    if ( global_requested_action == QDropEvent::Move )
+		c = moveCursor; // (source can delete)
+	    else
+		c = copyCursor;
+	} else if ( global_accepted_action == QDropEvent::Link ) {
+	    c = linkCursor;
+	} else {
+	    c = moveCursor;
+	}
+	if ( qt_xdnd_deco ) {
+	    qt_xdnd_deco->show();
+	    qt_xdnd_deco->raise();
+	}
+    } else {
+	c = noDropCursor;
+	//if ( qt_xdnd_deco )
+	//    qt_xdnd_deco->hide();
+    }
+#ifndef QT_NO_CURSOR
+    if ( c )
+	qApp->setOverrideCursor( *c, TRUE );
+#endif
+}
+
+
+void QDragManager::cancel( bool deleteSource )
+{
+    killTimer( heartbeat );
+    heartbeat = -1;
+    if ( object ) {
+	beingCancelled = TRUE;
+	object = 0;
+    }
+
+    if ( qt_xdnd_current_target ) {
+	qt_xdnd_send_leave();
+    }
+
+#ifndef QT_NO_CURSOR
+    if ( restoreCursor ) {
+	QApplication::restoreOverrideCursor();
+	restoreCursor = FALSE;
+    }
+#endif
+
+    if ( deleteSource )
+	delete qt_xdnd_source_object;
+    qt_xdnd_source_object = 0;
+    delete qt_xdnd_deco;
+    qt_xdnd_deco = 0;
+
+    dndCancelled = TRUE;
+}
+
+static
+Window findRealWindow( const QPoint & pos, Window w, int md )
+{
+    if ( qt_xdnd_deco && w == qt_xdnd_deco->winId() )
+	return 0;
+
+    if ( md ) {
+	XWindowAttributes attr;
+	XGetWindowAttributes( QPaintDevice::x11AppDisplay(), w, &attr );
+
+	if ( attr.map_state != IsUnmapped
+	    && QRect(attr.x,attr.y,attr.width,attr.height)
+		.contains(pos) )
+	{
+	    {
+		Atom   type = None;
+		int f;
+		unsigned long n, a;
+		unsigned char *data;
+
+		XGetWindowProperty( QPaintDevice::x11AppDisplay(), w, qt_wm_state, 0,
+		    0, False, AnyPropertyType, &type, &f,&n,&a,&data );
+		if ( data ) XFree(data);
+		if ( type ) return w;
+	    }
+
+	    Window r, p;
+	    Window* c;
+	    uint nc;
+	    if ( XQueryTree( QPaintDevice::x11AppDisplay(), w, &r, &p, &c, &nc ) ) {
+		r=0;
+		for (uint i=nc; !r && i--; ) {
+		    r = findRealWindow( pos-QPoint(attr.x,attr.y),
+					c[i], md-1 );
+		}
+		XFree(c);
+		if ( r )
+		    return r;
+
+		// We didn't find a client window!  Just use the
+		// innermost window.
+	    }
+
+	    // No children!
+	    return w;
+	}
+    }
+    return 0;
+}
+
+void QDragManager::move( const QPoint & globalPos )
+{
+    Q_ASSERT( object != 0 ); // ### remove in Qt 4.0 (object should never be 0 here)
+    int screen = QCursor::x11Screen();
+    if ( ( qt_xdnd_current_screen == -1 && screen != QPaintDevice::x11AppScreen() ) ||
+	 ( screen != qt_xdnd_current_screen ) ) {
+	// recreate the pixmap on the new screen...
+	delete qt_xdnd_deco;
+	qt_xdnd_deco = new QShapedPixmapWidget( screen );
+	if (!QWidget::mouseGrabber()) {
+	    updatePixmap();
+	    qt_xdnd_deco->grabMouse();
+	}
+    }
+    updatePixmap( globalPos );
+
+    if ( qt_xdnd_source_sameanswer.contains( globalPos ) &&
+	 qt_xdnd_source_sameanswer.isValid() ) {
+	return;
+    }
+
+    qt_xdnd_current_screen = screen;
+    Window rootwin = QPaintDevice::x11AppRootWindow( qt_xdnd_current_screen );
+    Window target = 0;
+    int lx = 0, ly = 0;
+    if ( !XTranslateCoordinates( QPaintDevice::x11AppDisplay(), rootwin, rootwin,
+				 globalPos.x(), globalPos.y(),
+				 &lx, &ly, &target) )
+	// some wierd error...
+	return;
+
+    if ( target == rootwin ) {
+	// Ok.
+    } else if ( target ) {
+	//me
+	Window targetW = qt_x11_findClientWindow( target, qt_wm_state, TRUE );
+	if (targetW)
+	    target = targetW;
+	if ( qt_xdnd_deco && (!target || target == qt_xdnd_deco->winId()) ) {
+	    target = findRealWindow(globalPos,rootwin,6);
+	}
+    }
+
+    QWidget* w;
+    if ( target ) {
+	w = QWidget::find( (WId)target );
+	if ( w && w->isDesktop() && !w->acceptDrops() )
+	    w = 0;
+    } else {
+	w = 0;
+	target = rootwin;
+    }
+
+    WId proxy_target = target;
+    int target_version = 1;
+
+    {
+	Atom   type = None;
+	int r, f;
+	unsigned long n, a;
+	WId *proxy_id;
+	qt_ignore_badwindow();
+	r = XGetWindowProperty( qt_xdisplay(), target, qt_xdnd_proxy, 0,
+				1, False, XA_WINDOW, &type, &f,&n,&a,(uchar**)&proxy_id );
+	if ( ( r != Success ) || qt_badwindow() ) {
+	    proxy_target = target = 0;
+	} else if ( type == XA_WINDOW && proxy_id ) {
+	    proxy_target = *proxy_id;
+	    XFree(proxy_id);
+	    proxy_id = 0;
+	    r = XGetWindowProperty( qt_xdisplay(), proxy_target, qt_xdnd_proxy, 0,
+				    1, False, XA_WINDOW, &type, &f,&n,&a,(uchar**)&proxy_id );
+	    if ( ( r != Success ) || qt_badwindow() || !type || !proxy_id || *proxy_id != proxy_target ) {
+		// Bogus
+		proxy_target = 0;
+		target = 0;
+	    }
+	    if ( proxy_id )
+		XFree(proxy_id);
+	}
+	if ( proxy_target ) {
+	    int *tv;
+	    qt_ignore_badwindow();
+	    r = XGetWindowProperty( qt_xdisplay(), proxy_target, qt_xdnd_aware, 0,
+				    1, False, AnyPropertyType, &type, &f,&n,&a,(uchar**)&tv );
+	    if ( r != Success ) {
+		target = 0;
+	    } else {
+		target_version = QMIN(qt_xdnd_version,tv ? *tv : 1);
+		if ( tv )
+		    XFree( tv );
+		if (!(!qt_badwindow() && type))
+		    target = 0;
+	    }
+	}
+    }
+
+    if ( target != qt_xdnd_current_target ) {
+	if ( qt_xdnd_current_target )
+	    qt_xdnd_send_leave();
+
+	qt_xdnd_current_target = target;
+	qt_xdnd_current_proxy_target = proxy_target;
+	if ( target ) {
+	    QMemArray<Atom> type;
+	    int flags = target_version << 24;
+	    const char* fmt;
+	    int nfmt=0;
+	    for (nfmt=0; (fmt=object->format(nfmt)); nfmt++) {
+		type.resize(nfmt+1);
+		type[nfmt] = *qt_xdnd_str_to_atom( fmt );
+	    }
+	    if ( nfmt >= 3 ) {
+		XChangeProperty( QPaintDevice::x11AppDisplay(),
+				 object->source()->winId(), qt_xdnd_type_list,
+				 XA_ATOM, 32, PropModeReplace,
+				 (unsigned char *)type.data(),
+				 type.size() );
+		flags |= 0x0001;
+	    }
+	    XClientMessageEvent enter;
+	    enter.type = ClientMessage;
+	    enter.window = target;
+	    enter.format = 32;
+	    enter.message_type = qt_xdnd_enter;
+	    enter.data.l[0] = object->source()->winId();
+	    enter.data.l[1] = flags;
+	    enter.data.l[2] = type.size()>0 ? type[0] : 0;
+	    enter.data.l[3] = type.size()>1 ? type[1] : 0;
+	    enter.data.l[4] = type.size()>2 ? type[2] : 0;
+	    // provisionally set the rectangle to 5x5 pixels...
+	    qt_xdnd_source_sameanswer = QRect( globalPos.x() - 2,
+					       globalPos.y() -2 , 5, 5 );
+
+	    if ( w ) {
+		qt_handle_xdnd_enter( w, (const XEvent *)&enter, FALSE );
+	    } else if ( target ) {
+		XSendEvent( QPaintDevice::x11AppDisplay(), proxy_target, False, NoEventMask,
+			    (XEvent*)&enter );
+	    }
+	}
+    }
+
+    if ( target ) {
+	XClientMessageEvent move;
+	move.type = ClientMessage;
+	move.window = target;
+	move.format = 32;
+	move.message_type = qt_xdnd_position;
+	move.window = target;
+	move.data.l[0] = object->source()->winId();
+	move.data.l[1] = 0; // flags
+	move.data.l[2] = (globalPos.x() << 16) + globalPos.y();
+	move.data.l[3] = qt_x_time;
+	move.data.l[4] = qtaction_to_xdndaction( global_requested_action );
+
+	if ( w )
+	    qt_handle_xdnd_position( w, (const XEvent *)&move, FALSE );
+	else
+	    XSendEvent( QPaintDevice::x11AppDisplay(), proxy_target, False, NoEventMask,
+			(XEvent*)&move );
+    } else {
+	if ( willDrop ) {
+	    willDrop = FALSE;
+	    updateCursor();
+	}
+    }
+}
+
+
+void QDragManager::drop()
+{
+    killTimer( heartbeat );
+    heartbeat = -1;
+    if ( !qt_xdnd_current_target )
+	return;
+
+    delete qt_xdnd_deco;
+    qt_xdnd_deco = 0;
+
+    XClientMessageEvent drop;
+    drop.type = ClientMessage;
+    drop.window = qt_xdnd_current_target;
+    drop.format = 32;
+    drop.message_type = qt_xdnd_drop;
+    drop.data.l[0] = object->source()->winId();
+    drop.data.l[1] = 1 << 24; // flags
+    drop.data.l[2] = 0; // ###
+    drop.data.l[3] = qt_x_time;
+    drop.data.l[4] = 0;
+
+    QWidget * w = QWidget::find( qt_xdnd_current_proxy_target );
+
+    if ( w && w->isDesktop() && !w->acceptDrops() )
+	w = 0;
+
+    if ( w )
+	qt_handle_xdnd_drop( w, (const XEvent *)&drop, FALSE );
+    else
+	XSendEvent( QPaintDevice::x11AppDisplay(), qt_xdnd_current_proxy_target, False,
+		    NoEventMask, (XEvent*)&drop );
+
+#ifndef QT_NO_CURSOR
+    if ( restoreCursor ) {
+	QApplication::restoreOverrideCursor();
+	restoreCursor = FALSE;
+    }
+#endif
+}
+
+
+
+bool qt_xdnd_handle_badwindow()
+{
+    if ( qt_xdnd_source_object && qt_xdnd_current_target ) {
+	qt_xdnd_current_target = 0;
+	qt_xdnd_current_proxy_target = 0;
+	delete qt_xdnd_source_object;
+	qt_xdnd_source_object = 0;
+	delete qt_xdnd_deco;
+	qt_xdnd_deco = 0;
+	return TRUE;
+    }
+    if ( qt_xdnd_dragsource_xid ) {
+	qt_xdnd_dragsource_xid = 0;
+	if ( qt_xdnd_current_widget ) {
+	    QDragLeaveEvent e;
+	    QApplication::sendEvent( qt_xdnd_current_widget, &e );
+	    qt_xdnd_current_widget = 0;
+	}
+	return TRUE;
+    }
+    return FALSE;
+}
+
+
+/*!
+    \class QDragMoveEvent qevent.h
+    \ingroup events
+    \ingroup draganddrop
+    \brief The QDragMoveEvent class provides an event which is sent while a drag and drop is in progress.
+
+    When a widget \link QWidget::setAcceptDrops() accepts drop
+    events\endlink, it will receive this event repeatedly while the
+    drag is within the widget's boundaries. The widget should examine
+    the event to see what data it \link QDragMoveEvent::provides()
+    provides\endlink, and accept() the drop if appropriate.
+
+    Note that this class inherits most of its functionality from
+    QDropEvent.
+*/
+
+
+/*!
+    Returns TRUE if this event provides format \a mimeType; otherwise
+    returns FALSE.
+
+    \sa data()
+*/
+
+bool QDropEvent::provides( const char *mimeType ) const
+{
+    if ( qt_motifdnd_active && qstrnicmp( mimeType, "text/", 5 ) == 0 )
+	return TRUE;
+
+    int n=0;
+    const char* f;
+    do {
+	f = format( n );
+	if ( !f )
+	    return FALSE;
+	n++;
+    } while( qstricmp( mimeType, f ) );
+    return TRUE;
+}
+
+void qt_xdnd_handle_selection_request( const XSelectionRequestEvent * req )
+{
+    if ( !req )
+	return;
+    XEvent evt;
+    evt.xselection.type = SelectionNotify;
+    evt.xselection.display = req->display;
+    evt.xselection.requestor = req->requestor;
+    evt.xselection.selection = req->selection;
+    evt.xselection.target = req->target;
+    evt.xselection.property = None;
+    evt.xselection.time = req->time;
+    const char* format = qt_xdnd_atom_to_str( req->target );
+    if ( format && qt_xdnd_source_object &&
+	 qt_xdnd_source_object->provides( format ) ) {
+	QByteArray a = qt_xdnd_source_object->encodedData(format);
+	XChangeProperty ( QPaintDevice::x11AppDisplay(), req->requestor, req->property,
+			  req->target, 8, PropModeReplace,
+			  (unsigned char *)a.data(), a.size() );
+	evt.xselection.property = req->property;
+    }
+    // ### this can die if req->requestor crashes at the wrong
+    // ### moment
+    XSendEvent( QPaintDevice::x11AppDisplay(), req->requestor, False, 0, &evt );
+}
+
+/*
+	XChangeProperty ( QPaintDevice::x11AppDisplay(), req->requestor, req->property,
+			  XA_STRING, 8,
+			  PropModeReplace,
+			  (uchar *)d->text(), strlen(d->text()) );
+	evt.xselection.property = req->property;
+*/
+
+static QByteArray qt_xdnd_obtain_data( const char *format )
+{
+    QByteArray result;
+
+    QWidget* w;
+    if ( qt_xdnd_dragsource_xid && qt_xdnd_source_object &&
+	 (w=QWidget::find( qt_xdnd_dragsource_xid ))
+	   && (!w->isDesktop() || w->acceptDrops()) )
+    {
+	QDragObject * o = qt_xdnd_source_object;
+	if ( o->provides( format ) )
+	    result = o->encodedData(format);
+	return result;
+    }
+
+    Atom * a = qt_xdnd_str_to_atom( format );
+    if ( !a || !*a )
+	return result;
+
+    if ( !qt_xdnd_target_data )
+	qt_xdnd_target_data = new QIntDict<QByteArray>( 17 );
+
+    if ( qt_xdnd_target_data->find( (int)*a ) ) {
+	result = *(qt_xdnd_target_data->find( (int)*a ));
+    } else {
+	if ( XGetSelectionOwner( QPaintDevice::x11AppDisplay(),
+				 qt_xdnd_selection ) == None )
+	    return result; // should never happen?
+
+	QWidget* tw = qt_xdnd_current_widget;
+	if ( !qt_xdnd_current_widget ||
+	     qt_xdnd_current_widget->isDesktop() ) {
+	    tw = new QWidget;
+	}
+	XConvertSelection( QPaintDevice::x11AppDisplay(),
+			   qt_xdnd_selection, *a,
+			   qt_xdnd_selection,
+			   tw->winId(), CurrentTime );
+	XFlush( QPaintDevice::x11AppDisplay() );
+
+	XEvent xevent;
+	bool got=qt_xclb_wait_for_event( QPaintDevice::x11AppDisplay(),
+				      tw->winId(),
+				      SelectionNotify, &xevent, 5000);
+	if ( got ) {
+	    Atom type;
+
+	    if ( qt_xclb_read_property( QPaintDevice::x11AppDisplay(),
+					tw->winId(),
+					qt_xdnd_selection, TRUE,
+					&result, 0, &type, 0, FALSE ) ) {
+		if ( type == qt_incr_atom ) {
+		    int nbytes = result.size() >= 4 ? *((int*)result.data()) : 0;
+		    result = qt_xclb_read_incremental_property( QPaintDevice::x11AppDisplay(),
+								tw->winId(),
+								qt_xdnd_selection,
+								nbytes, FALSE );
+		} else if ( type != *a ) {
+		    // (includes None) qDebug( "Qt clipboard: unknown atom %ld", type);
+		}
+#if 0
+		// this needs to be matched by a qt_xdnd_target_data->clear()
+		// when each drag is finished. for 2.0, we do the safe thing
+		// and disable the entire caching.
+		if ( type != None )
+		    qt_xdnd_target_data->insert( (int)((long)a), new QByteArray(result) );
+#endif
+	    }
+	}
+	if ( !qt_xdnd_current_widget ||
+	     qt_xdnd_current_widget->isDesktop() ) {
+	    delete tw;
+	}
+    }
+
+    return result;
+}
+
+
+/*
+  Enable drag and drop for widget w by installing the proper
+  properties on w's toplevel widget.
+*/
+bool qt_dnd_enable( QWidget* w, bool on )
+{
+    w = w->topLevelWidget();
+
+    if ( on ) {
+	if ( ( (QExtraWidget*)w)->topData()->dnd )
+	    return TRUE; // been there, done that
+	((QExtraWidget*)w)->topData()->dnd  = 1;
+    }
+
+    qt_motifdnd_enable( w, on );
+    return qt_xdnd_enable( w, on );
+}
+
+
+/*!
+    \class QDropEvent qevent.h
+    \ingroup events
+    \ingroup draganddrop
+
+    \brief The QDropEvent class provides an event which is sent when a drag and drop is completed.
+
+    When a widget \link QWidget::setAcceptDrops() accepts drop
+    events\endlink, it will receive this event if it has accepted the
+    most recent QDragEnterEvent or QDragMoveEvent sent to it.
+
+    The widget should use data() to extract the data in an appropriate
+    format.
+*/
+
+
+/*!
+    \fn QDropEvent::QDropEvent (const QPoint & pos, Type typ)
+
+    Constructs a drop event that drops a drop of type \a typ on point
+    \a pos.
+*/ // ### pos is in which coordinate system?
+
+
+/*!
+    Returns a byte array containing the drag's data, in \a format.
+
+    data() normally needs to get the data from the drag source, which
+    is potentially very slow, so it's advisable to call this function
+    only if you're sure that you will need the data in \a format.
+
+    The resulting data will have a size of 0 if the format was not
+    available.
+
+    \sa format() QByteArray::size()
+*/
+
+QByteArray QDropEvent::encodedData( const char *format ) const
+{
+    if ( qt_motifdnd_active )
+	return qt_motifdnd_obtain_data( format );
+    return qt_xdnd_obtain_data( format );
+}
+
+/*!
+    Returns a string describing one of the available data types for
+    this drag. Common examples are "text/plain" and "image/gif". If \a
+    n is less than zero or greater than the number of available data
+    types, format() returns 0.
+
+    This function is provided mainly for debugging. Most drop targets
+    will use provides().
+
+    \sa data() provides()
+*/
+
+const char* QDropEvent::format( int n ) const
+{
+    if ( qt_motifdnd_active )
+	return qt_motifdnd_format( n );
+
+    int i = 0;
+    while( i<n && qt_xdnd_types[i] )
+	i++;
+    if ( i < n )
+	return 0;
+
+    const char* name = qt_xdnd_atom_to_str( qt_xdnd_types[i] );
+    if ( !name )
+	return 0; // should never happen
+
+    return name;
+}
+
+bool QDragManager::drag( QDragObject * o, QDragObject::DragMode mode )
+{
+    if ( object == o || !o || !o->parent() )
+	return FALSE;
+
+    if ( object ) {
+	cancel();
+	qApp->removeEventFilter( this );
+	beingCancelled = FALSE;
+    }
+
+    if ( qt_xdnd_source_object ) {
+	// the last drag and drop operation hasn't finished, so we are going to wait
+	// for one second to see if it does... if the finish message comes after this,
+	// then we could still have problems, but this is highly unlikely
+	QApplication::flushX();
+
+	QTime started = QTime::currentTime();
+	QTime now = started;
+	do {
+	    XEvent event;
+	    if ( XCheckTypedEvent( QPaintDevice::x11AppDisplay(),
+				   ClientMessage, &event ) )
+		qApp->x11ProcessEvent( &event );
+
+	    now = QTime::currentTime();
+	    if ( started > now ) // crossed midnight
+		started = now;
+
+	    // sleep 50ms, so we don't use up CPU cycles all the time.
+	    struct timeval usleep_tv;
+	    usleep_tv.tv_sec = 0;
+	    usleep_tv.tv_usec = 50000;
+	    select(0, 0, 0, 0, &usleep_tv);
+	} while ( qt_xdnd_source_object && started.msecsTo(now) < 1000 );
+    }
+
+    qt_xdnd_source_object = o;
+    qt_xdnd_source_object->setTarget( 0 );
+    qt_xdnd_deco = new QShapedPixmapWidget();
+
+    willDrop = FALSE;
+
+    object = o;
+    updatePixmap();
+
+    dragSource = (QWidget *)(object->parent());
+
+    qApp->installEventFilter( this );
+    qt_xdnd_source_current_time = qt_x_time;
+    XSetSelectionOwner( QPaintDevice::x11AppDisplay(), qt_xdnd_selection,
+			dragSource->topLevelWidget()->winId(),
+			qt_xdnd_source_current_time );
+    oldstate = ButtonState(-1); // #### Should use state that caused the drag
+    drag_mode = mode;
+    global_accepted_action = QDropEvent::Copy;
+    updateMode(ButtonState(0));
+    qt_xdnd_source_sameanswer = QRect();
+    move(QCursor::pos());
+    heartbeat = startTimer(200);
+    need_modifiers_check = FALSE;
+
+#ifndef QT_NO_CURSOR
+    qApp->setOverrideCursor( arrowCursor );
+    restoreCursor = TRUE;
+    updateCursor();
+#endif
+
+    dndCancelled = FALSE;
+    qt_xdnd_dragging = TRUE;
+
+    if (!QWidget::mouseGrabber())
+	qt_xdnd_deco->grabMouse();
+
+    qApp->enter_loop(); // Do the DND.
+
+#ifndef QT_NO_CURSOR
+    qApp->restoreOverrideCursor();
+#endif
+
+    delete qt_xdnd_deco;
+    qt_xdnd_deco = 0;
+    killTimer( heartbeat );
+    heartbeat = -1;
+    qt_xdnd_current_screen = -1;
+    qt_xdnd_dragging = FALSE;
+
+    return ((! dndCancelled) && // source del?
+	    (global_accepted_action == QDropEvent::Copy &&
+	     global_requested_action == QDropEvent::Move));
+
+    // qt_xdnd_source_object persists until we get an xdnd_finish message
+}
+
+void QDragManager::updatePixmap( const QPoint& cursorPos )
+{
+    if ( qt_xdnd_deco ) {
+	QPixmap pm;
+	QPoint pm_hot(default_pm_hotx,default_pm_hoty);
+	if ( object ) {
+	    pm = object->pixmap();
+	    if ( !pm.isNull() )
+		pm_hot = object->pixmapHotSpot();
+	}
+	if ( pm.isNull() ) {
+	    if ( !defaultPm )
+		defaultPm = new QPixmap(default_pm);
+	    pm = *defaultPm;
+	}
+	qt_xdnd_deco->setPixmap(pm, pm_hot);
+	qt_xdnd_deco->move(cursorPos-pm_hot);
+	    //if ( willDrop ) {
+	    qt_xdnd_deco->show();
+	    //} else {
+	    //    qt_xdnd_deco->hide();
+	    //}
+    }
+}
+
+void QDragManager::updatePixmap()
+{
+    updatePixmap( QCursor::pos());
+}
+
+#endif // QT_NO_DRAGANDDROP
diff -Nru qt-x11-free-3.3.3.orig/src/kernel/qdragobject.cpp qt-x11-free-3.3.3/src/kernel/qdragobject.cpp
--- qt-x11-free-3.3.3.orig/src/kernel/qdragobject.cpp	2004-08-22 13:20:57.200998107 +0200
+++ qt-x11-free-3.3.3/src/kernel/qdragobject.cpp	2004-08-22 13:23:47.192850582 +0200
@@ -891,6 +891,16 @@
     if(!e)
 	return FALSE;
 
+    // when subtype is not specified, try text/plain first, otherwise this may read
+    // things like text/x-moz-url even though better targets are available
+    if( subtype.isNull()) {
+        QCString subtmp = "plain";
+        if( decode( e, str, subtmp )) {
+            subtype = subtmp;
+            return true;
+        }
+    }
+
     if ( e->cacheType == QMimeSource::Text ) {
 	str = *e->cache.txt.str;
 	subtype = *e->cache.txt.subtype;
diff -Nru qt-x11-free-3.3.3.orig/src/kernel/qdragobject.cpp~ qt-x11-free-3.3.3/src/kernel/qdragobject.cpp~
--- qt-x11-free-3.3.3.orig/src/kernel/qdragobject.cpp~	1970-01-01 01:00:00.000000000 +0100
+++ qt-x11-free-3.3.3/src/kernel/qdragobject.cpp~	2004-08-05 16:42:05.000000000 +0200
@@ -0,0 +1,1798 @@
+/****************************************************************************
+** $Id: qt/qdragobject.cpp   3.3.3   edited Jul 26 10:07 $
+**
+** Implementation of Drag and Drop support
+**
+** Copyright (C) 1992-2003 Trolltech AS.  All rights reserved.
+**
+** This file is part of the kernel module of the Qt GUI Toolkit.
+**
+** This file may be distributed under the terms of the Q Public License
+** as defined by Trolltech AS of Norway and appearing in the file
+** LICENSE.QPL included in the packaging of this file.
+**
+** This file may be distributed and/or modified under the terms of the
+** GNU General Public License version 2 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.
+**
+** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
+** licenses may use this file in accordance with the Qt Commercial License
+** Agreement provided with the Software.
+**
+** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+**
+** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
+**   information about Qt Commercial License Agreements.
+** See http://www.trolltech.com/qpl/ for QPL licensing information.
+** See http://www.trolltech.com/gpl/ for GPL licensing information.
+**
+** Contact info@trolltech.com if any conditions of this licensing are
+** not clear to you.
+**
+**********************************************************************/
+
+#include "qplatformdefs.h"
+
+// POSIX Large File Support redefines open -> open64
+#if defined(open)
+# undef open
+#endif
+
+#ifndef QT_NO_MIME
+
+#include "qdragobject.h"
+#include "qtextcodec.h"
+#include "qapplication.h"
+#include "qpoint.h"
+#include "qwidget.h"
+#include "qbuffer.h"
+#include "qgif.h"
+#include "qregexp.h"
+#include "qdir.h"
+#include <ctype.h>
+
+// both a struct for storing stuff in and a wrapper to avoid polluting
+// the name space
+
+class QDragObjectData
+{
+public:
+    QDragObjectData(): hot(0,0) {}
+    QPixmap pixmap;
+    QPoint hot;
+    // store default cursors
+    QPixmap *pm_cursor;
+};
+
+static QWidget* last_target;
+
+/*!
+    After the drag completes, this function will return the QWidget
+    which received the drop, or 0 if the data was dropped on another
+    application.
+
+    This can be useful for detecting the case where drag and drop is
+    to and from the same widget.
+*/
+QWidget * QDragObject::target()
+{
+    return last_target;
+}
+
+/*!
+    \internal
+    Sets the target.
+*/
+void QDragObject::setTarget(QWidget* t)
+{
+    last_target = t;
+}
+
+class QStoredDragData
+{
+public:
+    QStoredDragData() {}
+    const char* fmt;
+    QByteArray enc;
+};
+
+
+// These pixmaps approximate the images in the Windows User Interface Guidelines.
+
+// XPM
+
+static const char * const move_xpm[] = {
+"11 20 3 1",
+".	c None",
+#if defined(Q_WS_WIN)
+"a	c #000000",
+"X	c #FFFFFF", // Windows cursor is traditionally white
+#else
+"a	c #FFFFFF",
+"X	c #000000", // X11 cursor is traditionally black
+#endif
+"aa.........",
+"aXa........",
+"aXXa.......",
+"aXXXa......",
+"aXXXXa.....",
+"aXXXXXa....",
+"aXXXXXXa...",
+"aXXXXXXXa..",
+"aXXXXXXXXa.",
+"aXXXXXXXXXa",
+"aXXXXXXaaaa",
+"aXXXaXXa...",
+"aXXaaXXa...",
+"aXa..aXXa..",
+"aa...aXXa..",
+"a.....aXXa.",
+"......aXXa.",
+".......aXXa",
+".......aXXa",
+"........aa."};
+
+/* XPM */
+static const char * const copy_xpm[] = {
+"24 30 3 1",
+".	c None",
+"a	c #000000",
+"X	c #FFFFFF",
+#if defined(Q_WS_WIN) // Windows cursor is traditionally white
+"aa......................",
+"aXa.....................",
+"aXXa....................",
+"aXXXa...................",
+"aXXXXa..................",
+"aXXXXXa.................",
+"aXXXXXXa................",
+"aXXXXXXXa...............",
+"aXXXXXXXXa..............",
+"aXXXXXXXXXa.............",
+"aXXXXXXaaaa.............",
+"aXXXaXXa................",
+"aXXaaXXa................",
+"aXa..aXXa...............",
+"aa...aXXa...............",
+"a.....aXXa..............",
+"......aXXa..............",
+".......aXXa.............",
+".......aXXa.............",
+"........aa...aaaaaaaaaaa",
+#else
+"XX......................",
+"XaX.....................",
+"XaaX....................",
+"XaaaX...................",
+"XaaaaX..................",
+"XaaaaaX.................",
+"XaaaaaaX................",
+"XaaaaaaaX...............",
+"XaaaaaaaaX..............",
+"XaaaaaaaaaX.............",
+"XaaaaaaXXXX.............",
+"XaaaXaaX................",
+"XaaXXaaX................",
+"XaX..XaaX...............",
+"XX...XaaX...............",
+"X.....XaaX..............",
+"......XaaX..............",
+".......XaaX.............",
+".......XaaX.............",
+"........XX...aaaaaaaaaaa",
+#endif
+".............aXXXXXXXXXa",
+".............aXXXXXXXXXa",
+".............aXXXXaXXXXa",
+".............aXXXXaXXXXa",
+".............aXXaaaaaXXa",
+".............aXXXXaXXXXa",
+".............aXXXXaXXXXa",
+".............aXXXXXXXXXa",
+".............aXXXXXXXXXa",
+".............aaaaaaaaaaa"};
+
+/* XPM */
+static const char * const link_xpm[] = {
+"24 30 3 1",
+".	c None",
+"a	c #000000",
+"X	c #FFFFFF",
+#if defined(Q_WS_WIN) // Windows cursor is traditionally white
+"aa......................",
+"aXa.....................",
+"aXXa....................",
+"aXXXa...................",
+"aXXXXa..................",
+"aXXXXXa.................",
+"aXXXXXXa................",
+"aXXXXXXXa...............",
+"aXXXXXXXXa..............",
+"aXXXXXXXXXa.............",
+"aXXXXXXaaaa.............",
+"aXXXaXXa................",
+"aXXaaXXa................",
+"aXa..aXXa...............",
+"aa...aXXa...............",
+"a.....aXXa..............",
+"......aXXa..............",
+".......aXXa.............",
+".......aXXa.............",
+"........aa...aaaaaaaaaaa",
+#else
+"XX......................",
+"XaX.....................",
+"XaaX....................",
+"XaaaX...................",
+"XaaaaX..................",
+"XaaaaaX.................",
+"XaaaaaaX................",
+"XaaaaaaaX...............",
+"XaaaaaaaaX..............",
+"XaaaaaaaaaX.............",
+"XaaaaaaXXXX.............",
+"XaaaXaaX................",
+"XaaXXaaX................",
+"XaX..XaaX...............",
+"XX...XaaX...............",
+"X.....XaaX..............",
+"......XaaX..............",
+".......XaaX.............",
+".......XaaX.............",
+"........XX...aaaaaaaaaaa",
+#endif
+".............aXXXXXXXXXa",
+".............aXXXaaaaXXa",
+".............aXXXXaaaXXa",
+".............aXXXaaaaXXa",
+".............aXXaaaXaXXa",
+".............aXXaaXXXXXa",
+".............aXXaXXXXXXa",
+".............aXXXaXXXXXa",
+".............aXXXXXXXXXa",
+".............aaaaaaaaaaa"};
+
+#ifndef QT_NO_DRAGANDDROP
+
+// the universe's only drag manager
+QDragManager * qt_dnd_manager = 0;
+
+
+QDragManager::QDragManager()
+    : QObject( qApp, "global drag manager" )
+{
+    n_cursor = 3;
+    pm_cursor = new QPixmap[n_cursor];
+    pm_cursor[0] = QPixmap((const char **)move_xpm);
+    pm_cursor[1] = QPixmap((const char **)copy_xpm);
+    pm_cursor[2] = QPixmap((const char **)link_xpm);
+    object = 0;
+    dragSource = 0;
+    dropWidget = 0;
+    if ( !qt_dnd_manager )
+	qt_dnd_manager = this;
+    beingCancelled = FALSE;
+    restoreCursor = FALSE;
+    willDrop = FALSE;
+}
+
+
+QDragManager::~QDragManager()
+{
+#ifndef QT_NO_CURSOR
+    if ( restoreCursor )
+	QApplication::restoreOverrideCursor();
+#endif
+    qt_dnd_manager = 0;
+    delete [] pm_cursor;
+}
+
+#endif
+
+
+/*!
+    Constructs a drag object called \a name, which is a child of \a
+    dragSource.
+
+    Note that the drag object will be deleted when \a dragSource is
+    deleted.
+*/
+
+QDragObject::QDragObject( QWidget * dragSource, const char * name )
+    : QObject( dragSource, name )
+{
+    d = new QDragObjectData();
+    d->pm_cursor = 0;
+#ifndef QT_NO_DRAGANDDROP
+    if ( !qt_dnd_manager && qApp )
+	(void)new QDragManager();
+#endif
+}
+
+
+/*!
+    Destroys the drag object, canceling any drag and drop operation in
+    which it is involved, and frees up the storage used.
+*/
+
+QDragObject::~QDragObject()
+{
+#ifndef QT_NO_DRAGANDDROP
+    if ( qt_dnd_manager && qt_dnd_manager->object == this )
+	qt_dnd_manager->cancel( FALSE );
+    if ( d->pm_cursor ) {
+	for ( int i = 0; i < qt_dnd_manager->n_cursor; i++ )
+	    qt_dnd_manager->pm_cursor[i] = d->pm_cursor[i];
+	delete [] d->pm_cursor;
+    }
+#endif
+    delete d;
+}
+
+#ifndef QT_NO_DRAGANDDROP
+/*!
+    Set the pixmap \a pm to display while dragging the object. The
+    platform-specific implementation will use this where it can - so
+    provide a small masked pixmap, and do not assume that the user
+    will actually see it. For example, cursors on Windows 95 are of
+    limited size.
+
+    The \a hotspot is the point on (or off) the pixmap that should be
+    under the cursor as it is dragged. It is relative to the top-left
+    pixel of the pixmap.
+
+    \warning We have seen problems with drag cursors on different
+    graphics hardware and driver software on Windows. Setting the
+    graphics acceleration in the display settings down one tick solved
+    the problems in all cases.
+*/
+void QDragObject::setPixmap(QPixmap pm, const QPoint& hotspot)
+{
+    d->pixmap = pm;
+    d->hot = hotspot;
+    if ( qt_dnd_manager && qt_dnd_manager->object == this )
+	qt_dnd_manager->updatePixmap();
+}
+
+/*!
+    \overload
+    Uses a hotspot that positions the pixmap below and to the right of
+    the mouse pointer. This allows the user to clearly see the point
+    on the window which they are dragging the data onto.
+*/
+void QDragObject::setPixmap(QPixmap pm)
+{
+    setPixmap(pm,QPoint(-10, -10));
+}
+
+/*!
+    Returns the currently set pixmap (which \link QPixmap::isNull()
+    isNull()\endlink if none is set).
+*/
+QPixmap QDragObject::pixmap() const
+{
+    return d->pixmap;
+}
+
+/*!
+    Returns the currently set pixmap hotspot.
+*/
+QPoint QDragObject::pixmapHotSpot() const
+{
+    return d->hot;
+}
+
+#if 0
+
+// ## reevaluate for Qt 4
+/*!
+    Set the \a cursor used when dragging in mode \a m.
+    Note: X11 only allow bitmaps for cursors.
+*/
+void QDragObject::setCursor( DragMode m, const QPixmap &cursor )
+{
+    if ( d->pm_cursor == 0 ) {
+	// safe default cursors
+	d->pm_cursor = new QPixmap[qt_dnd_manager->n_cursor];
+	for ( int i = 0; i < qt_dnd_manager->n_cursor; i++ )
+	    d->pm_cursor[i] = qt_dnd_manager->pm_cursor[i];
+    }
+
+    int index;
+    switch ( m ) {
+    case DragCopy:
+	index = 1;
+	break;
+    case DragLink:
+	index = 2;
+	break;
+    default:
+	index = 0;
+	break;
+    }
+
+    // override default cursor
+    for ( index = 0; index < qt_dnd_manager->n_cursor; index++ )
+	qt_dnd_manager->pm_cursor[index] = cursor;
+}
+
+/*!
+    Returns the cursor used when dragging in mode \a m, or null if no cursor
+    has been set for that mode.
+*/
+QPixmap *QDragObject::cursor( DragMode m ) const
+{
+    if ( !d->pm_cursor )
+	return 0;
+
+    int index;
+    switch ( m ) {
+    case DragCopy:
+	index = 1;
+	break;
+    case DragLink:
+	index = 2;
+	break;
+    default:
+	index = 0;
+	break;
+    }
+
+    return qt_dnd_manager->pm_cursor+index;
+}
+
+#endif // 0
+
+/*!
+    Starts a drag operation using the contents of this object, using
+    DragDefault mode.
+
+    The function returns TRUE if the caller should delete the original
+    copy of the dragged data (but see target()); otherwise returns
+    FALSE.
+
+    If the drag contains \e references to information (e.g. file names
+    in a QUriDrag are references) then the return value should always
+    be ignored, as the target is expected to manipulate the
+    referred-to content directly. On X11 the return value should
+    always be correct anyway, but on Windows this is not necessarily
+    the case (e.g. the file manager starts a background process to
+    move files, so the source \e{must not} delete the files!)
+
+    Note that on Windows the drag operation will spin a blocking modal
+    event loop that will not dispatch any QTimers.
+*/
+bool QDragObject::drag()
+{
+    return drag( DragDefault );
+}
+
+
+/*!
+    Starts a drag operation using the contents of this object, using
+    \c DragMove mode. Be sure to read the constraints described in
+    drag().
+
+    \sa drag() dragCopy() dragLink()
+*/
+bool QDragObject::dragMove()
+{
+    return drag( DragMove );
+}
+
+
+/*!
+    Starts a drag operation using the contents of this object, using
+    \c DragCopy mode. Be sure to read the constraints described in
+    drag().
+
+    \sa drag() dragMove() dragLink()
+*/
+void QDragObject::dragCopy()
+{
+    (void)drag( DragCopy );
+}
+
+/*!
+    Starts a drag operation using the contents of this object, using
+    \c DragLink mode. Be sure to read the constraints described in
+    drag().
+
+    \sa drag() dragCopy() dragMove()
+*/
+void QDragObject::dragLink()
+{
+    (void)drag( DragLink );
+}
+
+
+/*!
+    \enum QDragObject::DragMode
+
+    This enum describes the possible drag modes.
+
+    \value DragDefault  The mode is determined heuristically.
+    \value DragCopy  The data is copied, never moved.
+    \value DragMove  The data is moved, if dragged at all.
+    \value DragLink  The data is linked, if dragged at all.
+    \value DragCopyOrMove  The user chooses the mode by using a
+			   control key to switch from the default.
+*/
+
+
+/*!
+    \overload
+    Starts a drag operation using the contents of this object.
+
+    At this point, the object becomes owned by Qt, not the
+    application. You should not delete the drag object or anything it
+    references. The actual transfer of data to the target application
+    will be done during future event processing - after that time the
+    drag object will be deleted.
+
+    Returns TRUE if the dragged data was dragged as a \e move,
+    indicating that the caller should remove the original source of
+    the data (the drag object must continue to have a copy); otherwise
+    returns FALSE.
+
+    The \a mode specifies the drag mode (see
+    \l{QDragObject::DragMode}.) Normally one of the simpler drag(),
+    dragMove(), or dragCopy() functions would be used instead.
+*/
+bool QDragObject::drag( DragMode mode )
+{
+    if ( qt_dnd_manager )
+	return qt_dnd_manager->drag( this, mode );
+    else
+	return FALSE;
+}
+
+#endif
+
+
+/*!
+    Returns a pointer to the drag source where this object originated.
+*/
+
+QWidget * QDragObject::source()
+{
+    if ( parent() && parent()->isWidgetType() )
+	return (QWidget *)parent();
+    else
+	return 0;
+}
+
+
+/*!
+    \class QDragObject qdragobject.h
+
+    \brief The QDragObject class encapsulates MIME-based data
+    transfer.
+
+    \ingroup draganddrop
+
+    QDragObject is the base class for all data that needs to be
+    transferred between and within applications, both for drag and
+    drop and for the \link qclipboard.html clipboard\endlink.
+
+    See the \link dnd.html Drag-and-drop documentation\endlink for an
+    overview of how to provide drag and drop in your application.
+
+    See the QClipboard documentation for an overview of how to provide
+    cut-and-paste in your application.
+
+    The drag() function is used to start a drag operation. You can
+    specify the \l DragMode in the call or use one of the convenience
+    functions dragCopy(), dragMove() or dragLink(). The drag source
+    where the data originated is retrieved with source(). If the data
+    was dropped on a widget within the application, target() will
+    return a pointer to that widget. Specify the pixmap to display
+    during the drag with setPixmap().
+*/
+
+static
+void stripws(QCString& s)
+{
+    int f;
+    while ( (f=s.find(' ')) >= 0 )
+	s.remove(f,1);
+}
+
+static
+const char * staticCharset(int i)
+{
+    static QCString localcharset;
+
+    switch ( i ) {
+      case 0:
+	return "UTF-8";
+      case 1:
+	return "ISO-10646-UCS-2";
+      case 2:
+	return ""; // in the 3rd place - some Xdnd targets might only look at 3
+      case 3:
+	if ( localcharset.isNull() ) {
+	    QTextCodec *localCodec = QTextCodec::codecForLocale();
+	    if ( localCodec ) {
+		localcharset = localCodec->name();
+		localcharset = localcharset.lower();
+		stripws(localcharset);
+	    } else {
+		localcharset = "";
+	    }
+	}
+	return localcharset;
+    }
+    return 0;
+}
+
+
+class QTextDragPrivate {
+public:
+    QTextDragPrivate();
+
+    enum { nfmt=4 };
+
+    QString txt;
+    QCString fmt[nfmt];
+    QCString subtype;
+
+    void setSubType(const QCString & st)
+    {
+	subtype = st.lower();
+	for ( int i=0; i<nfmt; i++ ) {
+	    fmt[i] = "text/";
+	    fmt[i].append(subtype);
+	    QCString cs = staticCharset(i);
+	    if ( !cs.isEmpty() ) {
+		fmt[i].append(";charset=");
+		fmt[i].append(cs);
+	    }
+	}
+    }
+};
+
+inline QTextDragPrivate::QTextDragPrivate()
+{
+    setSubType("plain");
+}
+
+/*!
+    Sets the MIME subtype of the text being dragged to \a st. The
+    default subtype is "plain", so the default MIME type of the text
+    is "text/plain". You might use this to declare that the text is
+    "text/html" by calling setSubtype("html").
+*/
+void QTextDrag::setSubtype( const QCString & st)
+{
+    d->setSubType(st);
+}
+
+/*!
+    \class QTextDrag qdragobject.h
+
+    \brief The QTextDrag class is a drag and drop object for
+    transferring plain and Unicode text.
+
+    \ingroup draganddrop
+
+    Plain text is passed in a QString which may contain multiple lines
+    (i.e. may contain newline characters). The drag target will receive
+    the newlines according to the runtime environment, e.g. LF on Unix,
+    and CRLF on Windows.
+
+    Qt provides no built-in mechanism for delivering only a single-line.
+
+    For more information about drag and drop, see the QDragObject class
+    and the \link dnd.html drag and drop documentation\endlink.
+*/
+
+
+/*!
+    Constructs a text drag object and sets its data to \a text. \a
+    dragSource must be the drag source; \a name is the object name.
+*/
+
+QTextDrag::QTextDrag( const QString &text,
+		      QWidget * dragSource, const char * name )
+    : QDragObject( dragSource, name )
+{
+    d = new QTextDragPrivate;
+    setText( text );
+}
+
+
+/*!
+    Constructs a default text drag object. \a dragSource must be the
+    drag source; \a name is the object name.
+*/
+
+QTextDrag::QTextDrag( QWidget * dragSource, const char * name )
+    : QDragObject( dragSource, name )
+{
+    d = new QTextDragPrivate;
+}
+
+
+/*!
+    Destroys the text drag object and frees up all allocated
+    resources.
+*/
+QTextDrag::~QTextDrag()
+{
+    delete d;
+}
+
+
+/*!
+    Sets the text to be dragged to \a text. You will need to call this
+    if you did not pass the text during construction.
+*/
+void QTextDrag::setText( const QString &text )
+{
+    d->txt = text;
+}
+
+
+/*!
+    \reimp
+*/
+const char * QTextDrag::format(int i) const
+{
+    if ( i >= d->nfmt )
+	return 0;
+    return d->fmt[i];
+}
+
+QTextCodec* qt_findcharset(const QCString& mimetype)
+{
+    int i=mimetype.find("charset=");
+    if ( i >= 0 ) {
+	QCString cs = mimetype.mid(i+8);
+	stripws(cs);
+	i = cs.find(';');
+	if ( i >= 0 )
+	    cs = cs.left(i);
+	// win98 often has charset=utf16, and we need to get the correct codec for
+	// it to be able to get Unicode text drops.
+	if ( cs == "utf16" )
+	    cs = "ISO-10646-UCS-2";
+	// May return 0 if unknown charset
+	return QTextCodec::codecForName(cs);
+    }
+    // no charset=, use locale
+    return QTextCodec::codecForLocale();
+}
+
+static QTextCodec *codecForHTML(const QCString &ba)
+{
+    // determine charset
+    int mib = 0;
+    int pos;
+    QTextCodec *c = 0;
+
+    if (ba.size() > 1 && (((uchar)ba[0] == 0xfe && (uchar)ba[1] == 0xff)
+			  || ((uchar)ba[0] == 0xff && (uchar)ba[1] == 0xfe))) {
+	mib = 1000; // utf16
+    } else if (ba.size() > 2
+	       && (uchar)ba[0] == 0xef
+	       && (uchar)ba[1] == 0xbb
+	       && (uchar)ba[2] == 0xbf) {
+	mib = 106; // utf-8
+    } else {
+	pos = 0;
+	while ((pos = ba.find("<meta http-equiv=", pos, FALSE)) != -1) {
+	    int end = ba.find('>', pos+1);
+	    if (end == -1)
+		break;
+	    pos = ba.find("charset=", pos, FALSE) + strlen("charset=");
+	    if (pos != -1 && pos < end) {
+		int pos2 = ba.find('\"', pos+1);
+		QCString cs = ba.mid(pos, pos2-pos);
+		c = QTextCodec::codecForName(cs);
+		if (c)
+		    return c;
+	    }
+	    pos = end;
+	}
+    }
+    if (mib)
+	c = QTextCodec::codecForMib(mib);
+
+    return c;
+}
+
+static
+QTextCodec* findcodec(const QMimeSource* e)
+{
+    QTextCodec* r = 0;
+    const char* f;
+    int i;
+    for ( i=0; (f=e->format(i)); i++ ) {
+	bool html = !qstrnicmp(f, "text/html", 9);
+	if (html)
+	    r = codecForHTML(QCString(e->encodedData(f)));
+	if (!r)
+	    r = qt_findcharset(QCString(f).lower());
+	if (r)
+	    return r;
+    }
+    return 0;
+}
+
+
+
+/*!
+    \reimp
+*/
+QByteArray QTextDrag::encodedData(const char* mime) const
+{
+    QCString r;
+    if ( 0==qstrnicmp(mime,"text/",5) ) {
+	QCString m(mime);
+	m = m.lower();
+	QTextCodec *codec = qt_findcharset(m);
+	if ( !codec )
+	    return r;
+	QString text( d->txt );
+#if defined(Q_WS_WIN)
+	int index = text.find( QString::fromLatin1("\r\n"), 0 );
+	while ( index != -1 ) {
+	    text.replace( index, 2, QChar('\n') );
+	    index = text.find( "\r\n", index );
+	}
+#endif
+	r = codec->fromUnicode(text);
+	if (!codec || codec->mibEnum() != 1000) {
+	    // Don't include NUL in size (QCString::resize() adds NUL)
+#if defined(Q_WS_WIN)
+	    // This is needed to ensure the \0 isn't lost on Windows 95
+	    if ( qWinVersion() & Qt::WV_DOS_based )
+		((QByteArray&)r).resize(r.length()+1);
+	    else
+#endif
+		((QByteArray&)r).resize(r.length());
+	}
+    }
+    return r;
+}
+
+/*!
+    Returns TRUE if the information in \a e can be decoded into a
+    QString; otherwise returns FALSE.
+
+    \sa decode()
+*/
+bool QTextDrag::canDecode( const QMimeSource* e )
+{
+    const char* f;
+    for (int i=0; (f=e->format(i)); i++) {
+	if ( 0==qstrnicmp(f,"text/",5) ) {
+	    return findcodec(e) != 0;
+	}
+    }
+    return 0;
+}
+
+/*!
+    \overload
+
+    Attempts to decode the dropped information in \a e into \a str.
+    Returns TRUE if successful; otherwise returns FALSE. If \a subtype
+    is null, any text subtype is accepted; otherwise only the
+    specified \a subtype is accepted.
+
+    \sa canDecode()
+*/
+bool QTextDrag::decode( const QMimeSource* e, QString& str, QCString& subtype )
+{
+    if(!e)
+	return FALSE;
+
+    if ( e->cacheType == QMimeSource::Text ) {
+	str = *e->cache.txt.str;
+	subtype = *e->cache.txt.subtype;
+	return TRUE;
+    }
+
+    const char* mime;
+    for (int i=0; (mime = e->format(i)); i++) {
+	if ( 0==qstrnicmp(mime,"text/",5) ) {
+	    QCString m(mime);
+	    m = m.lower();
+	    int semi = m.find(';');
+	    if ( semi < 0 )
+		semi = m.length();
+	    QCString foundst = m.mid(5,semi-5);
+	    if ( subtype.isNull() || foundst == subtype ) {
+		bool html = !qstrnicmp(mime, "text/html", 9);
+		QTextCodec* codec = 0;
+                if (html) {
+                    QByteArray bytes = e->encodedData(mime);
+		    // search for the charset tag in the HTML
+		    codec = codecForHTML(QCString(bytes.data(), bytes.size()));
+                }
+		if (!codec)
+		    codec = qt_findcharset(m);
+		if ( codec ) {
+		    QByteArray payload;
+
+		    payload = e->encodedData(mime);
+		    if ( payload.size() ) {
+			int l;
+			if ( codec->mibEnum() != 1000) {
+			    // length is at NUL or payload.size()
+			    l = 0;
+			    while ( l < (int)payload.size() && payload[l] )
+				l++;
+			} else {
+			    l = payload.size();
+			}
+
+			str = codec->toUnicode(payload,l);
+
+			if ( subtype.isNull() )
+			    subtype = foundst;
+
+			QMimeSource *m = (QMimeSource*)e;
+			m->clearCache();
+			m->cacheType = QMimeSource::Text;
+			m->cache.txt.str = new QString( str );
+			m->cache.txt.subtype = new QCString( subtype );
+
+			return TRUE;
+		    }
+		}
+	    }
+	}
+    }
+    return FALSE;
+}
+
+/*!
+    Attempts to decode the dropped information in \a e into \a str.
+    Returns TRUE if successful; otherwise returns FALSE.
+
+    \sa canDecode()
+*/
+bool QTextDrag::decode( const QMimeSource* e, QString& str )
+{
+    QCString st;
+    return decode(e,str,st);
+}
+
+
+/*
+  QImageDrag could use an internal MIME type for communicating QPixmaps
+  and QImages rather than always converting to raw data. This is available
+  for that purpose and others. It is not currently used.
+*/
+class QImageDragData
+{
+public:
+};
+
+
+/*!
+    \class QImageDrag qdragobject.h
+
+    \brief The QImageDrag class provides a drag and drop object for
+    transferring images.
+
+    \ingroup draganddrop
+
+    Images are offered to the receiving application in multiple
+    formats, determined by Qt's \link QImage::outputFormats() output
+    formats\endlink.
+
+    For more information about drag and drop, see the QDragObject
+    class and the \link dnd.html drag and drop documentation\endlink.
+*/
+
+/*!
+    Constructs an image drag object and sets its data to \a image. \a
+    dragSource must be the drag source; \a name is the object name.
+*/
+
+QImageDrag::QImageDrag( QImage image,
+			QWidget * dragSource, const char * name )
+    : QDragObject( dragSource, name ),
+	d(0)
+{
+    setImage( image );
+}
+
+/*!
+    Constructs a default image drag object. \a dragSource must be the
+    drag source; \a name is the object name.
+*/
+
+QImageDrag::QImageDrag( QWidget * dragSource, const char * name )
+    : QDragObject( dragSource, name ),
+	d(0)
+{
+}
+
+
+/*!
+    Destroys the image drag object and frees up all allocated
+    resources.
+*/
+
+QImageDrag::~QImageDrag()
+{
+    // nothing
+}
+
+
+/*!
+    Sets the image to be dragged to \a image. You will need to call
+    this if you did not pass the image during construction.
+*/
+void QImageDrag::setImage( QImage image )
+{
+    img = image; // ### detach?
+    ofmts = QImage::outputFormats();
+    ofmts.remove("PBM"); // remove non-raw PPM
+    if ( image.depth()!=32 ) {
+	// BMP better than PPM for paletted images
+	if ( ofmts.remove("BMP") ) // move to front
+	    ofmts.insert(0,"BMP");
+    }
+    // PNG is best of all
+    if ( ofmts.remove("PNG") ) // move to front
+	ofmts.insert(0,"PNG");
+
+    if(cacheType == QMimeSource::NoCache) { //cache it
+	cacheType = QMimeSource::Graphics;
+	cache.gfx.img = new QImage( img );
+	cache.gfx.pix = 0;
+    }
+}
+
+/*!
+    \reimp
+*/
+const char * QImageDrag::format(int i) const
+{
+    if ( i < (int)ofmts.count() ) {
+	static QCString str;
+	str.sprintf("image/%s",(((QImageDrag*)this)->ofmts).at(i));
+	str = str.lower();
+	if ( str == "image/pbmraw" )
+	    str = "image/ppm";
+	return str;
+    } else {
+	return 0;
+    }
+}
+
+/*!
+    \reimp
+*/
+QByteArray QImageDrag::encodedData(const char* fmt) const
+{
+    if ( qstrnicmp( fmt, "image/", 6 )==0 ) {
+	QCString f = fmt+6;
+	QByteArray data;
+	QBuffer w( data );
+	w.open( IO_WriteOnly );
+	QImageIO io( &w, f.upper() );
+	io.setImage( img );
+	if  ( !io.write() )
+	    return QByteArray();
+	w.close();
+	return data;
+    } else {
+	return QByteArray();
+    }
+}
+
+/*!
+    Returns TRUE if the information in mime source \a e can be decoded
+    into an image; otherwise returns FALSE.
+
+    \sa decode()
+*/
+bool QImageDrag::canDecode( const QMimeSource* e ) {
+    QStrList fileFormats = QImageIO::inputFormats();
+
+    fileFormats.first();
+    while ( fileFormats.current()) {
+	QCString format = fileFormats.current();
+	QCString type = "image/" + format.lower();
+	if ( e->provides(type.data()))
+	    return TRUE;
+	fileFormats.next();
+    }
+
+    return FALSE;
+}
+
+/*!
+    Attempts to decode the dropped information in mime source \a e
+    into \a img. Returns TRUE if successful; otherwise returns FALSE.
+
+    \sa canDecode()
+*/
+bool QImageDrag::decode( const QMimeSource* e, QImage& img )
+{
+    if ( !e )
+	return FALSE;
+    if ( e->cacheType == QMimeSource::Graphics ) {
+	img = *e->cache.gfx.img;
+	return TRUE;
+    }
+
+    QByteArray payload;
+    QStrList fileFormats = QImageIO::inputFormats();
+    // PNG is best of all
+    if ( fileFormats.remove("PNG") ) // move to front
+	fileFormats.insert(0,"PNG");
+    fileFormats.first();
+    while ( fileFormats.current() ) {
+	QCString format = fileFormats.current();
+	fileFormats.next();
+
+       	QCString type = "image/" + format.lower();
+	if ( ! e->provides( type.data() ) ) continue;
+	payload = e->encodedData( type.data() );
+	if ( !payload.isEmpty() )
+	    break;
+    }
+
+    if ( payload.isEmpty() )
+	return FALSE;
+
+    img.loadFromData(payload);
+    if ( img.isNull() )
+	return FALSE;
+    QMimeSource *m = (QMimeSource*)e;
+    m->clearCache();
+    m->cacheType = QMimeSource::Graphics;
+    m->cache.gfx.img = new QImage( img );
+    m->cache.gfx.pix = 0;
+    return TRUE;
+}
+
+/*!
+    \overload
+
+    Attempts to decode the dropped information in mime source \a e
+    into pixmap \a pm. Returns TRUE if successful; otherwise returns
+    FALSE.
+
+    This is a convenience function that converts to a QPixmap via a
+    QImage.
+
+    \sa canDecode()
+*/
+bool QImageDrag::decode( const QMimeSource* e, QPixmap& pm )
+{
+    if ( !e )
+	return FALSE;
+
+    if ( e->cacheType == QMimeSource::Graphics && e->cache.gfx.pix) {
+	pm = *e->cache.gfx.pix;
+	return TRUE;
+    }
+
+    QImage img;
+    // We avoid dither, since the image probably came from this display
+    if ( decode( e, img ) ) {
+	if ( !pm.convertFromImage( img, AvoidDither ) )
+	    return FALSE;
+	// decode initialized the cache for us
+
+	QMimeSource *m = (QMimeSource*)e;
+	m->cache.gfx.pix = new QPixmap( pm );
+	return TRUE;
+    }
+    return FALSE;
+}
+
+
+
+
+/*!
+    \class QStoredDrag qdragobject.h
+    \brief The QStoredDrag class provides a simple stored-value drag object for arbitrary MIME data.
+
+    \ingroup draganddrop
+
+    When a block of data has only one representation, you can use a
+    QStoredDrag to hold it.
+
+    For more information about drag and drop, see the QDragObject
+    class and the \link dnd.html drag and drop documentation\endlink.
+*/
+
+/*!
+    Constructs a QStoredDrag. The \a dragSource and \a name are passed
+    to the QDragObject constructor, and the format is set to \a
+    mimeType.
+
+    The data will be unset. Use setEncodedData() to set it.
+*/
+QStoredDrag::QStoredDrag( const char* mimeType, QWidget * dragSource, const char * name ) :
+    QDragObject(dragSource,name)
+{
+    d = new QStoredDragData();
+    d->fmt = qstrdup(mimeType);
+}
+
+/*!
+    Destroys the drag object and frees up all allocated resources.
+*/
+QStoredDrag::~QStoredDrag()
+{
+    delete [] (char*)d->fmt;
+    delete d;
+}
+
+/*!
+    \reimp
+*/
+const char * QStoredDrag::format(int i) const
+{
+    if ( i==0 )
+	return d->fmt;
+    else
+	return 0;
+}
+
+
+/*!
+    Sets the encoded data of this drag object to \a encodedData. The
+    encoded data is what's delivered to the drop sites. It must be in
+    a strictly defined and portable format.
+
+    The drag object can't be dropped (by the user) until this function
+    has been called.
+*/
+
+void QStoredDrag::setEncodedData( const QByteArray & encodedData )
+{
+    d->enc = encodedData.copy();
+}
+
+/*!
+    Returns the stored data. \a m contains the data's format.
+
+    \sa setEncodedData()
+*/
+QByteArray QStoredDrag::encodedData(const char* m) const
+{
+    if ( !qstricmp(m,d->fmt) )
+	return d->enc;
+    else
+	return QByteArray();
+}
+
+
+/*!
+    \class QUriDrag qdragobject.h
+    \brief The QUriDrag class provides a drag object for a list of URI references.
+
+    \ingroup draganddrop
+
+    URIs are a useful way to refer to files that may be distributed
+    across multiple machines. A URI will often refer to a file on a
+    machine local to both the drag source and the drop target, so the
+    URI can be equivalent to passing a file name but is more
+    extensible.
+
+    Use URIs in Unicode form so that the user can comfortably edit and
+    view them. For use in HTTP or other protocols, use the correctly
+    escaped ASCII form.
+
+    You can convert a list of file names to file URIs using
+    setFileNames(), or into human-readble form with setUnicodeUris().
+
+    Static functions are provided to convert between filenames and
+    URIs, e.g. uriToLocalFile() and localFileToUri(), and to and from
+    human-readable form, e.g. uriToUnicodeUri(), unicodeUriToUri().
+    You can also decode URIs from a mimesource into a list with
+    decodeLocalFiles() and decodeToUnicodeUris().
+*/
+
+/*!
+    Constructs an object to drag the list of URIs in \a uris. The \a
+    dragSource and \a name arguments are passed on to QStoredDrag.
+    Note that URIs are always in escaped UTF8 encoding.
+*/
+QUriDrag::QUriDrag( QStrList uris,
+	    QWidget * dragSource, const char * name ) :
+    QStoredDrag( "text/uri-list", dragSource, name )
+{
+    setUris(uris);
+}
+
+/*!
+    Constructs an object to drag. You must call setUris() before you
+    start the drag(). Passes \a dragSource and \a name to the
+    QStoredDrag constructor.
+*/
+QUriDrag::QUriDrag( QWidget * dragSource, const char * name ) :
+    QStoredDrag( "text/uri-list", dragSource, name )
+{
+}
+
+/*!
+    Destroys the object.
+*/
+QUriDrag::~QUriDrag()
+{
+}
+
+/*!
+    Changes the list of \a uris to be dragged.
+
+    Note that URIs are always in escaped UTF8 encoding.
+*/
+void QUriDrag::setUris( QStrList uris )
+{
+    QByteArray a;
+    int c=0;
+    for ( const char* s = uris.first(); s; s = uris.next() ) {
+	int l = qstrlen(s);
+	a.resize(c+l+2);
+	memcpy(a.data()+c,s,l);
+	memcpy(a.data()+c+l,"\r\n",2);
+	c+=l+2;
+    }
+    a.resize(c+1);
+    a[c] = 0;
+    setEncodedData(a);
+}
+
+
+/*!
+    Returns TRUE if decode() would be able to decode \a e; otherwise
+    returns FALSE.
+*/
+bool QUriDrag::canDecode( const QMimeSource* e )
+{
+    return e->provides( "text/uri-list" );
+}
+
+/*!
+    Decodes URIs from \a e, placing the result in \a l (which is first
+    cleared).
+
+    Returns TRUE if \a e contained a valid list of URIs; otherwise
+    returns FALSE.
+*/
+bool QUriDrag::decode( const QMimeSource* e, QStrList& l )
+{
+    QByteArray payload = e->encodedData( "text/uri-list" );
+    if ( payload.size() ) {
+	l.clear();
+	l.setAutoDelete(TRUE);
+	uint c=0;
+	const char* d = payload.data();
+	while (c < payload.size() && d[c]) {
+	    uint f = c;
+	    // Find line end
+	    while (c < payload.size() && d[c] && d[c]!='\r'
+		    && d[c] != '\n')
+		c++;
+	    QCString s(d+f,c-f+1);
+	    if ( s[0] != '#' ) // non-comment?
+		l.append( s );
+	    // Skip junk
+	    while (c < payload.size() && d[c] &&
+		    (d[c]=='\n' || d[c]=='\r'))
+		c++;
+	}
+	return TRUE;
+    }
+    return FALSE;
+}
+
+static uint htod( int h )
+{
+    if ( isdigit(h) )
+	return h - '0';
+    return tolower( h ) - 'a' + 10;
+}
+
+/*!
+  \fn QUriDrag::setFilenames( const QStringList & )
+  \obsolete
+
+  Use setFileNames() instead (notice the N).
+*/
+
+/*!
+    Sets the URIs to be the local-file URIs equivalent to \a fnames.
+
+    \sa localFileToUri(), setUris()
+*/
+void QUriDrag::setFileNames( const QStringList & fnames )
+{
+    QStrList uris;
+    for ( QStringList::ConstIterator i = fnames.begin();
+    i != fnames.end(); ++i ) {
+	QCString fileUri = localFileToUri(*i);
+	if (!fileUri.isEmpty())
+	    uris.append(fileUri);
+    }
+    setUris( uris );
+}
+
+/*!
+    Sets the URIs in \a uuris to be the Unicode URIs (only useful for
+    displaying to humans).
+
+    \sa localFileToUri(), setUris()
+*/
+void QUriDrag::setUnicodeUris( const QStringList & uuris )
+{
+    QStrList uris;
+    for ( QStringList::ConstIterator i = uuris.begin();
+	    i != uuris.end(); ++i )
+	uris.append( unicodeUriToUri(*i) );
+    setUris( uris );
+}
+
+/*!
+    Returns the URI equivalent of the Unicode URI given in \a uuri
+    (only useful for displaying to humans).
+
+    \sa uriToLocalFile()
+*/
+QCString QUriDrag::unicodeUriToUri(const QString& uuri)
+{
+    QCString utf8 = uuri.utf8();
+    QCString escutf8;
+    int n = utf8.length();
+    bool isFile = uuri.startsWith("file://");
+    for (int i=0; i<n; i++) {
+	if ( utf8[i] >= 'a' && utf8[i] <= 'z'
+	  || utf8[i] == '/'
+	  || utf8[i] >= '0' && utf8[i] <= '9'
+	  || utf8[i] >= 'A' && utf8[i] <= 'Z'
+
+	  || utf8[i] == '-' || utf8[i] == '_'
+	  || utf8[i] == '.' || utf8[i] == '!'
+	  || utf8[i] == '~' || utf8[i] == '*'
+	  || utf8[i] == '(' || utf8[i] == ')'
+	  || utf8[i] == '\''
+
+	  // Allow this through, so that all URI-references work.
+          || (!isFile && utf8[i] == '#')
+
+	  || utf8[i] == ';'
+	  || utf8[i] == '?' || utf8[i] == ':'
+	  || utf8[i] == '@' || utf8[i] == '&'
+	  || utf8[i] == '=' || utf8[i] == '+'
+	  || utf8[i] == '$' || utf8[i] == ',' )
+	{
+	    escutf8 += utf8[i];
+	} else {
+	    // Everything else is escaped as %HH
+	    QCString s(4);
+	    s.sprintf("%%%02x",(uchar)utf8[i]);
+	    escutf8 += s;
+	}
+    }
+    return escutf8;
+}
+
+/*!
+    Returns the URI equivalent to the absolute local file \a filename.
+
+    \sa uriToLocalFile()
+*/
+QCString QUriDrag::localFileToUri(const QString& filename)
+{
+    QString r = filename;
+
+    //check that it is an absolute file
+    if (QDir::isRelativePath(r))
+	return QCString();
+
+#ifdef Q_WS_WIN
+
+
+    bool hasHost = false;
+    // convert form network path
+    if (r.left(2) == "\\\\" || r.left(2) == "//") {
+	r.remove(0, 2);
+	hasHost = true;
+    }
+
+    // Slosh -> Slash
+    int slosh;
+    while ( (slosh=r.find('\\')) >= 0 ) {
+	r[slosh] = '/';
+    }
+
+    // Drive
+    if ( r[0] != '/' && !hasHost)
+	r.insert(0,'/');
+
+#endif
+#if defined ( Q_WS_X11 ) && 0
+    // URL without the hostname is considered to be errorneous by XDnD.
+    // See: http://www.newplanetsoftware.com/xdnd/dragging_files.html
+    // This feature is not active because this would break dnd between old and new qt apps.
+    char hostname[257];
+    if ( gethostname( hostname, 255 ) == 0 ) {
+	hostname[256] = '\0';
+	r.prepend( QString::fromLatin1( hostname ) );
+    }
+#endif
+    return unicodeUriToUri(QString("file://" + r));
+}
+
+/*!
+    Returns the Unicode URI (only useful for displaying to humans)
+    equivalent of \a uri.
+
+    Note that URIs are always in escaped UTF8 encoding.
+
+    \sa localFileToUri()
+*/
+QString QUriDrag::uriToUnicodeUri(const char* uri)
+{
+    QCString utf8;
+
+    while (*uri) {
+	switch (*uri) {
+	  case '%': {
+		uint ch = (uchar) uri[1];
+		if ( ch && uri[2] ) {
+		    ch = htod( ch ) * 16 + htod( (uchar) uri[2] );
+		    utf8 += (char) ch;
+		    uri += 2;
+		}
+	    }
+	    break;
+	  default:
+	    utf8 += *uri;
+	}
+	++uri;
+    }
+
+    return QString::fromUtf8(utf8);
+}
+
+/*!
+    Returns the name of a local file equivalent to \a uri or a null
+    string if \a uri is not a local file.
+
+    Note that URIs are always in escaped UTF8 encoding.
+
+    \sa localFileToUri()
+*/
+QString QUriDrag::uriToLocalFile(const char* uri)
+{
+    QString file;
+
+    if (!uri)
+	return file;
+    if (0==qstrnicmp(uri,"file:/",6)) // It is a local file uri
+	uri += 6;
+    else if (QString(uri).find(":/") != -1) // It is a different scheme uri
+	return file;
+
+    bool local = uri[0] != '/' || ( uri[0] != '\0' && uri[1] == '/' );
+#ifdef Q_WS_X11
+    // do we have a hostname?
+    if ( !local && uri[0] == '/' && uri[2] != '/' ) {
+	// then move the pointer to after the 'hostname/' part of the uri
+	const char* hostname_end = strchr( uri+1, '/' );
+	if ( hostname_end != NULL ) {
+	    char hostname[ 257 ];
+	    if ( gethostname( hostname, 255 ) == 0 ) {
+		hostname[ 256 ] = '\0';
+		if ( qstrncmp( uri+1, hostname, hostname_end - ( uri+1 )) == 0 ) {
+		    uri = hostname_end + 1; // point after the slash
+		    local = TRUE;
+		}
+	    }
+	}
+    }
+#endif
+    if ( local ) {
+	file = uriToUnicodeUri(uri);
+	if ( uri[1] == '/' ) {
+	    file.remove((uint)0,1);
+	} else {
+		file.insert(0,'/');
+	}
+#ifdef Q_WS_WIN
+	if ( file.length() > 2 && file[0] == '/' && file[2] == '|' ) {
+	    file[2] = ':';
+	    file.remove(0,1);
+	} else if (file.length() > 2 && file[0] == '/' && file[1].isLetter() && file[2] == ':') {
+	    file.remove(0, 1);
+	}
+	// Leave slash as slashes.
+#endif
+    }
+#ifdef Q_WS_WIN
+    else {
+	file = uriToUnicodeUri(uri);
+	// convert to network path
+	file.insert(1, '/'); // leave as forward slashes
+    }
+#endif
+
+    return file;
+}
+
+/*!
+    Decodes URIs from the mime source event \a e, converts them to
+    local files if they refer to local files, and places them in \a l
+    (which is first cleared).
+
+    Returns TRUE if \e contained a valid list of URIs; otherwise
+    returns FALSE. The list will be empty if no URIs were local files.
+*/
+bool QUriDrag::decodeLocalFiles( const QMimeSource* e, QStringList& l )
+{
+    QStrList u;
+    if ( !decode( e, u ) )
+	return FALSE;
+
+    l.clear();
+    for (const char* s=u.first(); s; s=u.next()) {
+	QString lf = uriToLocalFile(s);
+	if ( !lf.isNull() )
+	    l.append( lf );
+    }
+    return TRUE;
+}
+
+/*!
+    Decodes URIs from the mime source event \a e, converts them to
+    Unicode URIs (only useful for displaying to humans), placing them
+    in \a l (which is first cleared).
+
+    Returns TRUE if \e contained a valid list of URIs; otherwise
+    returns FALSE.
+*/
+bool QUriDrag::decodeToUnicodeUris( const QMimeSource* e, QStringList& l )
+{
+    QStrList u;
+    if ( !decode( e, u ) )
+	return FALSE;
+
+    l.clear();
+    for (const char* s=u.first(); s; s=u.next())
+	l.append( uriToUnicodeUri(s) );
+
+    return TRUE;
+}
+
+
+#ifndef QT_NO_DRAGANDDROP
+/*!
+    If the source of the drag operation is a widget in this
+    application, this function returns that source, otherwise it
+    returns 0. The source of the operation is the first parameter to
+    drag object subclasses.
+
+    This is useful if your widget needs special behavior when dragging
+    to itself, etc.
+
+    See QDragObject::QDragObject() and subclasses.
+*/
+QWidget* QDropEvent::source() const
+{
+    return qt_dnd_manager ? qt_dnd_manager->dragSource : 0;
+}
+#endif
+
+/*!
+    \class QColorDrag qdragobject.h
+
+    \brief The QColorDrag class provides a drag and drop object for
+    transferring colors.
+
+    \ingroup draganddrop
+
+    This class provides a drag object which can be used to transfer data
+    about colors for drag and drop and in the clipboard. For example, it
+    is used in QColorDialog.
+
+    The color is set in the constructor but can be changed with
+    setColor().
+
+    For more information about drag and drop, see the QDragObject class
+    and the \link dnd.html drag and drop documentation\endlink.
+*/
+
+/*!
+    Constructs a color drag object with the color \a col. Passes \a
+    dragsource and \a name to the QStoredDrag constructor.
+*/
+
+QColorDrag::QColorDrag( const QColor &col, QWidget *dragsource, const char *name )
+    : QStoredDrag( "application/x-color", dragsource, name )
+{
+    setColor( col );
+}
+
+/*!
+    Constructs a color drag object with a white color. Passes \a
+    dragsource and \a name to the QStoredDrag constructor.
+*/
+
+QColorDrag::QColorDrag( QWidget *dragsource, const char *name )
+    : QStoredDrag( "application/x-color", dragsource, name )
+{
+    setColor( Qt::white );
+}
+
+/*!
+    Sets the color of the color drag to \a col.
+*/
+
+void QColorDrag::setColor( const QColor &col )
+{
+    short r = (col.red()   << 8) | col.red();
+    short g = (col.green() << 8) | col.green();
+    short b = (col.blue()  << 8) | col.blue();
+
+    // make sure we transmit data in network order
+    r = htons(r);
+    g = htons(g);
+    b = htons(b);
+
+    ushort rgba[4] = {
+	r, g, b,
+	0xffff // Alpha not supported yet.
+    };
+    QByteArray data(sizeof(rgba));
+    memcpy(data.data(), rgba, sizeof(rgba));
+    setEncodedData(data);
+}
+
+/*!
+    Returns TRUE if the color drag object can decode the mime source
+    \a e; otherwise returns FALSE.
+*/
+
+bool QColorDrag::canDecode( QMimeSource *e )
+{
+    return e->provides( "application/x-color" );
+}
+
+/*!
+    Decodes the mime source \a e and sets the decoded values to \a
+    col.
+*/
+
+bool QColorDrag::decode( QMimeSource *e, QColor &col )
+{
+    QByteArray data = e->encodedData("application/x-color");
+    ushort rgba[4];
+    if (data.size() != sizeof(rgba))
+	return FALSE;
+
+    memcpy(rgba, data.data(), sizeof(rgba));
+
+    short r = rgba[0];
+    short g = rgba[1];
+    short b = rgba[2];
+
+    // data is in network order
+    r = ntohs(r);
+    g = ntohs(g);
+    b = ntohs(b);
+
+    r = (r >> 8) & 0xff;
+    g = (g >> 8) & 0xff;
+    b = (b >> 8) & 0xff;
+
+    col.setRgb(r, g, b);
+    return TRUE;
+}
+
+#endif // QT_NO_MIME
diff -Nru qt-x11-free-3.3.3.orig/src/kernel/qdragobject.h qt-x11-free-3.3.3/src/kernel/qdragobject.h
--- qt-x11-free-3.3.3.orig/src/kernel/qdragobject.h	2004-08-22 13:20:57.260986749 +0200
+++ qt-x11-free-3.3.3/src/kernel/qdragobject.h	2004-08-22 13:22:29.657504419 +0200
@@ -245,10 +245,11 @@
     void move( const QPoint & );
     void drop();
     void updatePixmap();
+    void updatePixmap( const QPoint& cursorPos );
 
 private:
     QDragObject * object;
-    void updateMode( ButtonState newstate );
+    bool updateMode( ButtonState newstate );
     void updateCursor();
 
     QWidget * dragSource;
diff -Nru qt-x11-free-3.3.3.orig/src/kernel/qdragobject.h~ qt-x11-free-3.3.3/src/kernel/qdragobject.h~
--- qt-x11-free-3.3.3.orig/src/kernel/qdragobject.h~	1970-01-01 01:00:00.000000000 +0100
+++ qt-x11-free-3.3.3/src/kernel/qdragobject.h~	2004-08-22 13:22:14.643343737 +0200
@@ -0,0 +1,273 @@
+/****************************************************************************
+** $Id: qt/qdragobject.h   3.3.3   edited May 27 2003 $
+**
+** Definition of QDragObject
+**
+** Copyright (C) 1992-2002 Trolltech AS.  All rights reserved.
+**
+** This file is part of the kernel module of the Qt GUI Toolkit.
+**
+** This file may be distributed under the terms of the Q Public License
+** as defined by Trolltech AS of Norway and appearing in the file
+** LICENSE.QPL included in the packaging of this file.
+**
+** This file may be distributed and/or modified under the terms of the
+** GNU General Public License version 2 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.
+**
+** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
+** licenses may use this file in accordance with the Qt Commercial License
+** Agreement provided with the Software.
+**
+** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+**
+** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
+**   information about Qt Commercial License Agreements.
+** See http://www.trolltech.com/qpl/ for QPL licensing information.
+** See http://www.trolltech.com/gpl/ for GPL licensing information.
+**
+** Contact info@trolltech.com if any conditions of this licensing are
+** not clear to you.
+**
+**********************************************************************/
+
+#ifndef QDRAGOBJECT_H
+#define QDRAGOBJECT_H
+
+class QWidget;
+class QTextDragPrivate;
+class QDragObjectData;
+class QStoredDragData;
+class QImageDragData;
+
+#ifndef QT_H
+#include "qobject.h"
+#include "qimage.h"
+#include "qstrlist.h"
+#include "qcolor.h"
+#endif // QT_H
+
+#ifndef QT_NO_MIME
+
+class Q_EXPORT QDragObject: public QObject, public QMimeSource {
+    Q_OBJECT
+public:
+    QDragObject( QWidget * dragSource = 0, const char * name = 0 );
+    virtual ~QDragObject();
+
+#ifndef QT_NO_DRAGANDDROP
+    bool drag();
+    bool dragMove();
+    void dragCopy();
+    void dragLink();
+
+    virtual void setPixmap(QPixmap);
+    virtual void setPixmap(QPixmap, const QPoint& hotspot);
+    QPixmap pixmap() const;
+    QPoint pixmapHotSpot() const;
+#endif
+
+    QWidget * source();
+    static QWidget * target();
+
+    static void setTarget(QWidget*);
+
+#ifndef QT_NO_DRAGANDDROP
+    enum DragMode { DragDefault, DragCopy, DragMove, DragLink, DragCopyOrMove };
+
+protected:
+    virtual bool drag(DragMode);
+#endif
+
+private:
+    QDragObjectData * d;
+#if defined(Q_DISABLE_COPY) // Disabled copy constructor and operator=
+    QDragObject( const QDragObject & );
+    QDragObject &operator=( const QDragObject & );
+#endif
+};
+
+class Q_EXPORT QStoredDrag: public QDragObject {
+    Q_OBJECT
+    QStoredDragData * d;
+
+public:
+    QStoredDrag( const char * mimeType,
+		 QWidget * dragSource = 0, const char * name = 0 );
+    ~QStoredDrag();
+
+    virtual void setEncodedData( const QByteArray & );
+
+    const char * format(int i) const;
+    virtual QByteArray encodedData(const char*) const;
+
+private:
+#if defined(Q_DISABLE_COPY) // Disabled copy constructor and operator=
+    QStoredDrag( const QStoredDrag & );
+    QStoredDrag &operator=( const QStoredDrag & );
+#endif
+};
+
+class Q_EXPORT QTextDrag: public QDragObject {
+    Q_OBJECT
+    QTextDragPrivate* d;
+public:
+    QTextDrag( const QString &,
+	       QWidget * dragSource = 0, const char * name = 0 );
+    QTextDrag( QWidget * dragSource = 0, const char * name = 0 );
+    ~QTextDrag();
+
+    virtual void setText( const QString &);
+    virtual void setSubtype( const QCString &);
+
+    const char * format(int i) const;
+    virtual QByteArray encodedData(const char*) const;
+
+    static bool canDecode( const QMimeSource* e );
+    static bool decode( const QMimeSource* e, QString& s );
+    static bool decode( const QMimeSource* e, QString& s, QCString& subtype );
+
+private:
+#if defined(Q_DISABLE_COPY) // Disabled copy constructor and operator=
+    QTextDrag( const QTextDrag & );
+    QTextDrag &operator=( const QTextDrag & );
+#endif
+};
+
+class Q_EXPORT QImageDrag: public QDragObject {
+    Q_OBJECT
+    QImage img;
+    QStrList ofmts;
+    QImageDragData* d;
+
+public:
+    QImageDrag( QImage image, QWidget * dragSource = 0, const char * name = 0 );
+    QImageDrag( QWidget * dragSource = 0, const char * name = 0 );
+    ~QImageDrag();
+
+    virtual void setImage( QImage image );
+
+    const char * format(int i) const;
+    virtual QByteArray encodedData(const char*) const;
+
+    static bool canDecode( const QMimeSource* e );
+    static bool decode( const QMimeSource* e, QImage& i );
+    static bool decode( const QMimeSource* e, QPixmap& i );
+
+private:
+#if defined(Q_DISABLE_COPY) // Disabled copy constructor and operator=
+    QImageDrag( const QImageDrag & );
+    QImageDrag &operator=( const QImageDrag & );
+#endif
+};
+
+
+class Q_EXPORT QUriDrag: public QStoredDrag {
+    Q_OBJECT
+
+public:
+    QUriDrag( QStrList uris, QWidget * dragSource = 0, const char * name = 0 );
+    QUriDrag( QWidget * dragSource = 0, const char * name = 0 );
+    ~QUriDrag();
+
+    void setFilenames( const QStringList & fnames ) { setFileNames( fnames ); }
+    void setFileNames( const QStringList & fnames );
+    void setUnicodeUris( const QStringList & uuris );
+    virtual void setUris( QStrList uris );
+
+    static QString uriToLocalFile(const char*);
+    static QCString localFileToUri(const QString&);
+    static QString uriToUnicodeUri(const char*);
+    static QCString unicodeUriToUri(const QString&);
+    static bool canDecode( const QMimeSource* e );
+    static bool decode( const QMimeSource* e, QStrList& i );
+    static bool decodeToUnicodeUris( const QMimeSource* e, QStringList& i );
+    static bool decodeLocalFiles( const QMimeSource* e, QStringList& i );
+
+private:
+#if defined(Q_DISABLE_COPY) // Disabled copy constructor and operator=
+    QUriDrag( const QUriDrag & );
+    QUriDrag &operator=( const QUriDrag & );
+#endif
+};
+
+class Q_EXPORT QColorDrag : public QStoredDrag
+{
+    Q_OBJECT
+    QColor color;
+
+public:
+    QColorDrag( const QColor &col, QWidget *dragsource = 0, const char *name = 0 );
+    QColorDrag( QWidget * dragSource = 0, const char * name = 0 );
+    void setColor( const QColor &col );
+
+    static bool canDecode( QMimeSource * );
+    static bool decode( QMimeSource *, QColor &col );
+
+private:
+#if defined(Q_DISABLE_COPY) // Disabled copy constructor and operator=
+    QColorDrag( const QColorDrag & );
+    QColorDrag &operator=( const QColorDrag & );
+#endif
+};
+
+#ifndef QT_NO_COMPAT
+typedef QUriDrag QUrlDrag;
+#endif
+
+#ifndef QT_NO_DRAGANDDROP
+
+// QDragManager is not part of the public API.  It is defined in a
+// header file simply so different .cpp files can implement different
+// member functions.
+//
+
+class Q_EXPORT QDragManager: public QObject {
+    Q_OBJECT
+
+private:
+    QDragManager();
+    ~QDragManager();
+    // only friend classes can use QDragManager.
+    friend class QDragObject;
+    friend class QDragMoveEvent;
+    friend class QDropEvent;
+    friend class QApplication;
+
+    bool eventFilter( QObject *, QEvent * );
+    void timerEvent( QTimerEvent* );
+
+    bool drag( QDragObject *, QDragObject::DragMode );
+
+    void cancel( bool deleteSource = TRUE );
+    void move( const QPoint & );
+    void drop();
+    void updatePixmap();
+    void updatePixmap( const QPoint& cursorPos );
+
+private:
+    QDragObject * object;
+    void updateMode( ButtonState newstate );
+    void updateCursor();
+
+    QWidget * dragSource;
+    QWidget * dropWidget;
+    bool beingCancelled;
+    bool restoreCursor;
+    bool willDrop;
+
+    QPixmap *pm_cursor;
+    int n_cursor;
+#if defined(Q_DISABLE_COPY) // Disabled copy constructor and operator=
+    QDragManager( const QDragManager & );
+    QDragManager &operator=( const QDragManager & );
+#endif
+};
+
+#endif
+
+#endif // QT_NO_MIME
+
+#endif // QDRAGOBJECT_H
diff -Nru qt-x11-free-3.3.3.orig/src/kernel/qfontdatabase_x11.cpp qt-x11-free-3.3.3/src/kernel/qfontdatabase_x11.cpp
--- qt-x11-free-3.3.3.orig/src/kernel/qfontdatabase_x11.cpp	2004-08-22 13:20:57.205997160 +0200
+++ qt-x11-free-3.3.3/src/kernel/qfontdatabase_x11.cpp	2004-08-22 13:24:34.259961994 +0200
@@ -1002,8 +1002,7 @@
 	    style->smoothScalable = TRUE;
 	    QtFontSize *size = style->pixelSize( SMOOTH_SCALABLE, TRUE );
 	    QtFontEncoding *enc = size->encodingID( -1, 0, 0, 0, 0, TRUE );
-	    enc->pitch = ( spacing_value >= XFT_CHARCELL ? 'c' :
-			   ( spacing_value >= XFT_MONO ? 'm' : 'p' ) );
+	    enc->pitch = (f->fixed ? 'm' : 'p');
 	}
 	++f;
     }
diff -Nru qt-x11-free-3.3.3.orig/src/kernel/qpixmap_x11.cpp qt-x11-free-3.3.3/src/kernel/qpixmap_x11.cpp
--- qt-x11-free-3.3.3.orig/src/kernel/qpixmap_x11.cpp	2004-08-22 13:20:57.194999242 +0200
+++ qt-x11-free-3.3.3/src/kernel/qpixmap_x11.cpp	2004-08-22 13:22:44.708658672 +0200
@@ -37,7 +37,19 @@
 
 // NOT REVISED
 
+#include "qplatformdefs.h"
+
+#if defined(Q_OS_WIN32) && defined(QT_MITSHM)
+#undef QT_MITSHM
+#endif
+
+#ifdef QT_MITSHM
+
+// Use the MIT Shared Memory extension for pixmap<->image conversions
+#define QT_MITSHM_CONVERSIONS
+
 // Uncomment the next line to enable the MIT Shared Memory extension
+// for QPixmap::xForm()
 //
 // WARNING:  This has some problems:
 //
@@ -45,14 +57,13 @@
 //    2. Qt does not handle the ShmCompletion message, so you will
 //        get strange effects if you xForm() repeatedly.
 //
-// #define QT_MITSHM
+// #define QT_MITSHM_XFORM
 
-#if defined(Q_OS_WIN32) && defined(QT_MITSHM)
-#undef QT_MITSHM
+#else
+#undef QT_MITSHM_CONVERSIONS
+#undef QT_MITSHM_XFORM
 #endif
 
-#include "qplatformdefs.h"
-
 #include "qbitmap.h"
 #include "qpaintdevicemetrics.h"
 #include "qimage.h"
@@ -91,7 +102,7 @@
   MIT Shared Memory Extension support: makes xForm noticeably (~20%) faster.
  *****************************************************************************/
 
-#if defined(QT_MITSHM)
+#if defined(QT_MITSHM_XFORM)
 
 static bool	       xshminit = FALSE;
 static XShmSegmentInfo xshminfo;
@@ -173,8 +184,100 @@
 //     return FALSE;
 // }
 
-#endif // QT_MITSHM
+#endif // QT_MITSHM_XFORM
 
+#ifdef QT_MITSHM_CONVERSIONS
+
+static bool qt_mitshm_error = false;
+static int qt_mitshm_errorhandler( Display*, XErrorEvent* )
+{
+    qt_mitshm_error = true;
+    return 0;
+}
+
+static XImage* qt_XShmCreateImage( Display* dpy, Visual* visual, unsigned int depth,
+    int format, int /*offset*/, char* /*data*/, unsigned int width, unsigned int height,
+    int /*bitmap_pad*/, int /*bytes_per_line*/, XShmSegmentInfo* shminfo )
+{
+    if( width * height * depth < 100*100*32 )
+        return NULL;
+    static int shm_inited = -1;
+    if( shm_inited == -1 ) {
+        if( XShmQueryExtension( dpy ))
+            shm_inited = 1;
+        else
+            shm_inited = 0;
+    }
+    if( shm_inited == 0 )
+        return NULL;
+    XImage* xi = XShmCreateImage( dpy, visual, depth, format, NULL, shminfo, width,
+        height );
+    if( xi == NULL )
+        return NULL;
+    shminfo->shmid = shmget( IPC_PRIVATE, xi->bytes_per_line * xi->height,
+        IPC_CREAT|0777);
+    if( shminfo->shmid < 0 ) {
+        XDestroyImage( xi );
+        return NULL;
+    }
+    shminfo->readOnly = False;
+    shminfo->shmaddr = (char*)shmat( shminfo->shmid, 0, 0 );
+    if( shminfo->shmaddr == (char*)-1 ) {
+        XDestroyImage( xi );
+        shmctl( shminfo->shmid, IPC_RMID, 0 );
+        return NULL;
+    }
+    xi->data = shminfo->shmaddr;
+#ifndef QT_MITSHM_RMID_IGNORES_REFCOUNT
+    // mark as deleted to automatically free the memory in case
+    // of a crash (but this doesn't work e.g. on Solaris)
+    shmctl( shminfo->shmid, IPC_RMID, 0 );
+#endif
+    if( shm_inited == 1 ) { // first time
+        XErrorHandler old_h = XSetErrorHandler( qt_mitshm_errorhandler );
+        XShmAttach( dpy, shminfo );
+        shm_inited = 2;
+        XSync( dpy, False );
+        XSetErrorHandler( old_h );
+        if( qt_mitshm_error ) { // oops ... perhaps we are remote?
+            shm_inited = 0;
+            XDestroyImage( xi );
+            shmdt( shminfo->shmaddr );
+#ifdef QT_MITSHM_RMID_IGNORES_REFCOUNT
+            shmctl( shminfo->shmid, IPC_RMID, 0 );
+#endif
+            return NULL;
+        }
+    } else
+        XShmAttach( dpy, shminfo );
+    return xi;
+}
+
+static void qt_XShmDestroyImage( XImage* xi, XShmSegmentInfo* shminfo )
+{
+    XShmDetach( QPaintDevice::x11AppDisplay(), shminfo );
+    XDestroyImage( xi );
+    shmdt( shminfo->shmaddr );
+#ifdef QT_MITSHM_RMID_IGNORES_REFCOUNT
+    shmctl( shminfo->shmid, IPC_RMID, 0 );
+#endif
+}
+
+static XImage* qt_XShmGetImage( const QPixmap* pix, int format,
+    XShmSegmentInfo* shminfo )
+{
+    XImage* xi = qt_XShmCreateImage( pix->x11Display(), (Visual*)pix->x11Visual(),
+        pix->depth(), format, 0, 0, pix->width(), pix->height(), 32, 0, shminfo );
+    if( xi == NULL )
+        return NULL;
+    if( XShmGetImage( pix->x11Display(), pix->handle(), xi, 0, 0, AllPlanes ) == False ) {
+        qt_XShmDestroyImage( xi, shminfo );
+        return NULL;
+    }
+    return xi;
+}
+
+#endif // QT_MITSHM_CONVERSIONS
 
 /*****************************************************************************
   Internal functions
@@ -625,9 +728,20 @@
 	d = 32;					//   > 8  ==> 32
 
     XImage *xi = (XImage *)data->ximage;	// any cached ximage?
-    if ( !xi )					// fetch data from X server
-	xi = XGetImage( x11Display(), hd, 0, 0, w, h, AllPlanes,
+#ifdef QT_MITSHM_CONVERSIONS
+    bool mitshm_ximage = false;
+    XShmSegmentInfo shminfo;
+#endif
+    if ( !xi ) {				// fetch data from X server
+#ifdef QT_MITSHM_CONVERSIONS
+        xi = qt_XShmGetImage( this, mono ? XYPixmap : ZPixmap, &shminfo );
+        if( xi ) {
+            mitshm_ximage = true;
+        } else
+#endif
+	    xi = XGetImage( x11Display(), hd, 0, 0, w, h, AllPlanes,
 			mono ? XYPixmap : ZPixmap );
+    }
     Q_CHECK_PTR( xi );
 
     QImage::Endian bitOrder = QImage::IgnoreEndian;
@@ -636,15 +750,31 @@
 		   QImage::LittleEndian : QImage::BigEndian;
     }
     image.create( w, h, d, 0, bitOrder );
-    if ( image.isNull() )			// could not create image
+    if ( image.isNull() ) {			// could not create image
+#ifdef QT_MITSHM_CONVERSIONS
+        if( mitshm_ximage )
+            qt_XShmDestroyImage( xi, &shminfo );
+        else
+#endif
+        qSafeXDestroyImage( xi );
 	return image;
+    }
 
     const QPixmap* msk = mask();
     const QPixmap *alf = data->alphapm;
 
     QImage alpha;
     if (alf) {
-	XImage *axi = XGetImage(x11Display(), alf->hd, 0, 0, w, h, AllPlanes, ZPixmap);
+        XImage* axi;
+#ifdef QT_MITSHM_CONVERSIONS
+        bool mitshm_aximage = false;
+        XShmSegmentInfo ashminfo;
+        axi = qt_XShmGetImage( alf, ZPixmap, &ashminfo );
+        if( axi ) {
+            mitshm_aximage = true;
+        } else
+#endif
+            axi = XGetImage(x11Display(), alf->hd, 0, 0, w, h, AllPlanes, ZPixmap);
 
 	if (axi) {
 	    image.setAlphaBuffer( TRUE );
@@ -658,7 +788,12 @@
 		src += axi->bytes_per_line;
 	    }
 
-	    qSafeXDestroyImage( axi );
+#ifdef QT_MITSHM_CONVERSIONS
+            if( mitshm_aximage )
+                qt_XShmDestroyImage( axi, &ashminfo );
+            else
+#endif
+    	        qSafeXDestroyImage( axi );
 	}
     } else if (msk) {
 	image.setAlphaBuffer( TRUE );
@@ -800,6 +935,12 @@
 		  xi->bits_per_pixel );
 #endif
 	image.reset();
+#ifdef QT_MITSHM_CONVERSIONS
+        if( mitshm_ximage )
+            qt_XShmDestroyImage( xi, &shminfo );
+        else
+#endif
+            qSafeXDestroyImage( xi );
 	return image;
     }
 
@@ -905,10 +1046,22 @@
 	delete [] carr;
     }
     if ( data->optim != BestOptim ) {		// throw away image data
-	qSafeXDestroyImage( xi );
+#ifdef QT_MITSHM_CONVERSIONS
+        if( mitshm_ximage )
+            qt_XShmDestroyImage( xi, &shminfo );
+        else
+#endif
+            qSafeXDestroyImage( xi );
 	((QPixmap*)this)->data->ximage = 0;
-    } else					// keep ximage data
+    } else {					// keep ximage data
+#ifdef QT_MITSHM_CONVERSIONS
+        if( mitshm_ximage ) { // copy the XImage?
+            qt_XShmDestroyImage( xi, &shminfo );
+            xi = 0;
+        }
+#endif
 	((QPixmap*)this)->data->ximage = xi;
+    }
 
     return image;
 }
@@ -1078,6 +1231,11 @@
     bool    trucol = (visual->c_class == TrueColor);
     int	    nbytes = image.numBytes();
     uchar  *newbits= 0;
+    int newbits_size = 0;
+#ifdef QT_MITSHM_CONVERSIONS
+    bool mitshm_ximage = false;
+    XShmSegmentInfo shminfo;
+#endif
 
     if ( trucol ) {				// truecolor display
 	QRgb  pix[256];				// pixel translation table
@@ -1106,17 +1264,23 @@
 	    }
 	}
 
-	xi = XCreateImage( dpy, visual, dd, ZPixmap, 0, 0, w, h, 32, 0 );
+#ifdef QT_MITSHM_CONVERSIONS
+        xi = qt_XShmCreateImage( dpy, visual, dd, ZPixmap, 0, 0, w, h, 32, 0, &shminfo );
+        if( xi != NULL ) {
+            mitshm_ximage = true;
+            newbits = (uchar*)xi->data;
+        }
+        else
+#endif
+	    xi = XCreateImage( dpy, visual, dd, ZPixmap, 0, 0, w, h, 32, 0 );
 	Q_CHECK_PTR( xi );
-	newbits = (uchar *)malloc( xi->bytes_per_line*h );
+        if( newbits == NULL )
+    	    newbits = (uchar *)malloc( xi->bytes_per_line*h );
 	Q_CHECK_PTR( newbits );
 	if ( !newbits )				// no memory
 	    return FALSE;
 	int    bppc = xi->bits_per_pixel;
 
-	if ( bppc > 8 && xi->byte_order == LSBFirst )
-	    bppc++;
-
 	bool contig_bits = n_bits(red_mask) == rbits &&
                            n_bits(green_mask) == gbits &&
                            n_bits(blue_mask) == bbits;
@@ -1166,31 +1330,69 @@
 	    init=TRUE;
 	}
 
-	for ( uint y=0; y<h; y++ ) {
-	    uchar* src = image.scanLine( y );
-	    uchar* dst = newbits + xi->bytes_per_line*y;
-	    QRgb* p = (QRgb *)src;
+        enum { BPP8,
+               BPP16_8_3_M3, BPP16_7_2_M3, BPP16_MSB, BPP16_LSB,
+               BPP24_MSB, BPP24_LSB,
+               BPP32_16_8_0, BPP32_MSB, BPP32_LSB
+        } mode = BPP8;
 
-#define GET_RGB \
-		int r = qRed  ( *p ); \
-		int g = qGreen( *p ); \
-		int b = qBlue ( *p++ ); \
-		r = red_shift   > 0 \
-		    ? r << red_shift   : r >> -red_shift; \
-		g = green_shift > 0 \
-		    ? g << green_shift : g >> -green_shift; \
-		b = blue_shift  > 0 \
-		    ? b << blue_shift  : b >> -blue_shift;
+	if ( bppc > 8 && xi->byte_order == LSBFirst )
+	    bppc++;
+
+        int wordsize;
+        bool bigendian;
+        qSysInfo( &wordsize, &bigendian );
+        bool same_msb_lsb = ( xi->byte_order == MSBFirst ) == ( bigendian );
+
+        if( bppc == 8 ) // 8 bit
+            mode = BPP8;
+        else if( bppc == 16 || bppc == 17 ) { // 16 bit MSB/LSB
+            if( red_shift == 8 && green_shift == 3 && blue_shift == -3
+                && !d8 && same_msb_lsb )
+                mode = BPP16_8_3_M3;
+            else if( red_shift == 7 && green_shift == 2 && blue_shift == -3
+                && !d8 && same_msb_lsb )
+                mode = BPP16_7_2_M3;
+            else
+                mode = bppc == 17 ? BPP16_LSB : BPP16_MSB;
+        } else if( bppc == 24 || bppc == 25 ) { // 24 bit MSB/LSB
+            mode = bppc == 25 ? BPP24_LSB : BPP24_MSB;
+        } else if( bppc == 32 || bppc == 33 ) { // 32 bit MSB/LSB
+            if( red_shift == 16 && green_shift == 8 && blue_shift == 0
+                && !d8 && same_msb_lsb )
+                mode = BPP32_16_8_0;
+            else
+                mode = bppc == 33 ? BPP32_LSB : BPP32_MSB;
+        } else
+	    qFatal("Logic error 3");
 
 #define GET_PIXEL \
                 int pixel; \
 		if ( d8 ) pixel = pix[*src++]; \
 		else { \
-		    GET_RGB \
-		    pixel = (b & blue_mask)|(g & green_mask) | (r & red_mask) \
+		    int r = qRed  ( *p ); \
+		    int g = qGreen( *p ); \
+		    int b = qBlue ( *p++ ); \
+		    r = red_shift   > 0 \
+		        ? r << red_shift   : r >> -red_shift; \
+		    g = green_shift > 0 \
+		        ? g << green_shift : g >> -green_shift; \
+		    b = blue_shift  > 0 \
+		        ? b << blue_shift  : b >> -blue_shift; \
+		    pixel = (r & red_mask)|(g & green_mask) | (b & blue_mask) \
 			    | ~(blue_mask | green_mask | red_mask); \
 		}
 
+// optimized case - no d8 case, shift only once instead of twice, mask only once instead of twice,
+// use direct values instead of variables, and use only one statement
+// (*p >> 16), (*p >> 8 ) and (*p) are qRed(),qGreen() and qBlue() without masking
+// shifts have to be passed including the shift operator (e.g. '>>3'), because of the direction
+#define GET_PIXEL_OPT(red_shift,green_shift,blue_shift,red_mask,green_mask,blue_mask) \
+                int pixel = ((( *p >> 16 ) red_shift ) & red_mask ) \
+                    | ((( *p >> 8 ) green_shift ) & green_mask ) \
+                    | ((( *p ) blue_shift ) & blue_mask ); \
+                ++p;
+
 #define GET_PIXEL_DITHER_TC \
 		int r = qRed  ( *p ); \
 		int g = qGreen( *p ); \
@@ -1211,91 +1413,177 @@
 		    ? g << green_shift : g >> -green_shift; \
 		b = blue_shift  > 0 \
 		    ? b << blue_shift  : b >> -blue_shift; \
-		int pixel = (b & blue_mask)|(g & green_mask) | (r & red_mask);
+		int pixel = (r & red_mask)|(g & green_mask) | (b & blue_mask);
 
-	    if ( dither_tc ) {
-		uint x;
-		switch ( bppc ) {
-		case 16:			// 16 bit MSB
-		    for ( x=0; x<w; x++ ) {
-			GET_PIXEL_DITHER_TC
-			*dst++ = (pixel >> 8);
-			*dst++ = pixel;
-		    }
+// again, optimized case
+// can't be optimized that much :(
+#define GET_PIXEL_DITHER_TC_OPT(red_shift,green_shift,blue_shift,red_mask,green_mask,blue_mask, \
+                                rbits,gbits,bbits) \
+		const int thres = D[x%16][y%16]; \
+		int r = qRed  ( *p ); \
+		if ( r <= (255-(1<<(8-rbits))) && ((r<<rbits) & 255) \
+			> thres) \
+		    r += (1<<(8-rbits)); \
+		int g = qGreen( *p ); \
+		if ( g <= (255-(1<<(8-gbits))) && ((g<<gbits) & 255) \
+			> thres) \
+		    g += (1<<(8-gbits)); \
+		int b = qBlue ( *p++ ); \
+		if ( b <= (255-(1<<(8-bbits))) && ((b<<bbits) & 255) \
+			> thres) \
+		    b += (1<<(8-bbits)); \
+                int pixel = (( r red_shift ) & red_mask ) \
+                    | (( g green_shift ) & green_mask ) \
+                    | (( b blue_shift ) & blue_mask );
+
+#define CYCLE(body) \
+	for ( uint y=0; y<h; y++ ) { \
+	    uchar* src = image.scanLine( y ); \
+	    uchar* dst = newbits + xi->bytes_per_line*y; \
+	    QRgb* p = (QRgb *)src; \
+            body \
+        }
+
+        if ( dither_tc ) {
+	    switch ( mode ) {
+                case BPP16_8_3_M3:
+                    CYCLE(
+                        Q_INT16* dst16 = (Q_INT16*)dst;
+		        for ( uint x=0; x<w; x++ ) {
+			    GET_PIXEL_DITHER_TC_OPT(<<8,<<3,>>3,0xf800,0x7e0,0x1f,5,6,5)
+                            *dst16++ = pixel;
+		        }
+                    )
 		    break;
-		case 17:			// 16 bit LSB
-		    for ( x=0; x<w; x++ ) {
-			GET_PIXEL_DITHER_TC
-			*dst++ = pixel;
-			*dst++ = pixel >> 8;
-		    }
+                case BPP16_7_2_M3:
+                    CYCLE(
+                        Q_INT16* dst16 = (Q_INT16*)dst;
+		        for ( uint x=0; x<w; x++ ) {
+			    GET_PIXEL_DITHER_TC_OPT(<<7,<<2,>>3,0x7c00,0x3e0,0x1f,5,5,5)
+                            *dst16++ = pixel;
+		        }
+                    )
+		    break;
+		case BPP16_MSB:			// 16 bit MSB
+                    CYCLE(
+		        for ( uint x=0; x<w; x++ ) {
+			    GET_PIXEL_DITHER_TC
+			    *dst++ = (pixel >> 8);
+			    *dst++ = pixel;
+		        }
+                    )
+		    break;
+		case BPP16_LSB:			// 16 bit LSB
+                    CYCLE(
+    		        for ( uint x=0; x<w; x++ ) {
+			    GET_PIXEL_DITHER_TC
+			    *dst++ = pixel;
+			    *dst++ = pixel >> 8;
+		        }
+                    )
 		    break;
 		default:
 		    qFatal("Logic error");
 		}
-	    } else {
-		uint x;
-		switch ( bppc ) {
-		case 8:			// 8 bit
-		    for ( x=0; x<w; x++ ) {
-			int pixel = pix[*src++];
-			*dst++ = pixel;
-		    }
+	} else {
+	    switch ( mode ) {
+		case BPP8:			// 8 bit
+                    CYCLE(
+                    Q_UNUSED(p);
+		        for ( uint x=0; x<w; x++ ) {
+			    int pixel = pix[*src++];
+			    *dst++ = pixel;
+		        }
+                    )
 		    break;
-		case 16:			// 16 bit MSB
-		    for ( x=0; x<w; x++ ) {
-			GET_PIXEL
-			*dst++ = (pixel >> 8);
-			*dst++ = pixel;
-		    }
+                case BPP16_8_3_M3:
+                    CYCLE(
+                        Q_INT16* dst16 = (Q_INT16*)dst;
+		        for ( uint x=0; x<w; x++ ) {
+			    GET_PIXEL_OPT(<<8,<<3,>>3,0xf800,0x7e0,0x1f)
+                            *dst16++ = pixel;
+		        }
+                    )
 		    break;
-		case 17:			// 16 bit LSB
-		    for ( x=0; x<w; x++ ) {
-			GET_PIXEL
-			*dst++ = pixel;
-			*dst++ = pixel >> 8;
-		    }
+                case BPP16_7_2_M3:
+                    CYCLE(
+                        Q_INT16* dst16 = (Q_INT16*)dst;
+		        for ( uint x=0; x<w; x++ ) {
+			    GET_PIXEL_OPT(<<7,<<2,>>3,0x7c00,0x3e0,0x1f)
+                            *dst16++ = pixel;
+		        }
+                    )
 		    break;
-		case 24:			// 24 bit MSB
-		    for ( x=0; x<w; x++ ) {
-			GET_PIXEL
-			*dst++ = pixel >> 16;
-			*dst++ = pixel >> 8;
-			*dst++ = pixel;
-		    }
+		case BPP16_MSB:			// 16 bit MSB
+                    CYCLE(
+		        for ( uint x=0; x<w; x++ ) {
+			    GET_PIXEL
+			    *dst++ = (pixel >> 8);
+			    *dst++ = pixel;
+		        }
+                    )
 		    break;
-		case 25:			// 24 bit LSB
-		    for ( x=0; x<w; x++ ) {
-			GET_PIXEL
-			*dst++ = pixel;
-			*dst++ = pixel >> 8;
-			*dst++ = pixel >> 16;
-		    }
+		case BPP16_LSB:			// 16 bit LSB
+                    CYCLE(
+		        for ( uint x=0; x<w; x++ ) {
+			    GET_PIXEL
+			    *dst++ = pixel;
+			    *dst++ = pixel >> 8;
+		        }
+                    )
 		    break;
-		case 32:			// 32 bit MSB
-		    for ( x=0; x<w; x++ ) {
-			GET_PIXEL
-			*dst++ = pixel >> 24;
-			*dst++ = pixel >> 16;
-			*dst++ = pixel >> 8;
-			*dst++ = pixel;
-		    }
+		case BPP24_MSB:			// 24 bit MSB
+                    CYCLE(
+		        for ( uint x=0; x<w; x++ ) {
+			    GET_PIXEL
+			    *dst++ = pixel >> 16;
+			    *dst++ = pixel >> 8;
+			    *dst++ = pixel;
+		        }
+                    )
 		    break;
-		case 33:			// 32 bit LSB
-		    for ( x=0; x<w; x++ ) {
-			GET_PIXEL
-			*dst++ = pixel;
-			*dst++ = pixel >> 8;
-			*dst++ = pixel >> 16;
-			*dst++ = pixel >> 24;
-		    }
+		case BPP24_LSB:			// 24 bit LSB
+                    CYCLE(
+		        for ( uint x=0; x<w; x++ ) {
+			    GET_PIXEL
+			    *dst++ = pixel;
+			    *dst++ = pixel >> 8;
+			    *dst++ = pixel >> 16;
+		        }
+                    )
 		    break;
-		default:
-		    qFatal("Logic error 2");
-		}
-	    }
-	}
-	xi->data = (char *)newbits;
+                case BPP32_16_8_0:
+                    CYCLE(
+                        memcpy( dst, p, w * 4 );
+                    )
+                    break;
+		case BPP32_MSB:			// 32 bit MSB
+                    CYCLE(
+		        for ( uint x=0; x<w; x++ ) {
+			    GET_PIXEL
+			    *dst++ = pixel >> 24;
+			    *dst++ = pixel >> 16;
+			    *dst++ = pixel >> 8;
+			    *dst++ = pixel;
+		        }
+                    )
+		    break;
+		case BPP32_LSB:			// 32 bit LSB
+                    CYCLE(
+		        for ( uint x=0; x<w; x++ ) {
+			    GET_PIXEL
+			    *dst++ = pixel;
+			    *dst++ = pixel >> 8;
+			    *dst++ = pixel >> 16;
+			    *dst++ = pixel >> 24;
+		        }
+                    )
+  		    break;
+  		default:
+  		    qFatal("Logic error 2");
+  	    }
+  	}
+  	xi->data = (char *)newbits;
     }
 
     if ( d == 8 && !trucol ) {			// 8 bit pixmap
@@ -1314,6 +1602,7 @@
 	}
 
 	newbits = (uchar *)malloc( nbytes );	// copy image into newbits
+        newbits_size = nbytes;
 	Q_CHECK_PTR( newbits );
 	if ( !newbits )				// no memory
 	    return FALSE;
@@ -1431,11 +1720,18 @@
     }
 
     if ( !xi ) {				// X image not created
-	xi = XCreateImage( dpy, visual, dd, ZPixmap, 0, 0, w, h, 32, 0 );
+#ifdef QT_MITSHM_CONVERSIONS
+        xi = qt_XShmCreateImage( dpy, visual, dd, ZPixmap, 0, 0, w, h, 32, 0, &shminfo );
+        if( xi != NULL )
+            mitshm_ximage = true;
+        else
+#endif
+	    xi = XCreateImage( dpy, visual, dd, ZPixmap, 0, 0, w, h, 32, 0 );
 	if ( xi->bits_per_pixel == 16 ) {	// convert 8 bpp ==> 16 bpp
 	    ushort *p2;
 	    int	    p2inc = xi->bytes_per_line/sizeof(ushort);
 	    ushort *newerbits = (ushort *)malloc( xi->bytes_per_line * h );
+            newbits_size = xi->bytes_per_line * h;
 	    Q_CHECK_PTR( newerbits );
 	    if ( !newerbits )				// no memory
 		return FALSE;
@@ -1453,7 +1749,15 @@
 		      "(bpp=%d)", xi->bits_per_pixel );
 #endif
 	}
-	xi->data = (char *)newbits;
+#ifdef QT_MITSHM_CONVERSIONS
+        if( newbits_size > 0 && mitshm_ximage ) { // need to copy to shared memory
+            memcpy( xi->data, newbits, newbits_size );
+            free( newbits );
+            newbits = (uchar*)xi->data;
+        }
+        else
+#endif
+            xi->data = (char *)newbits;
     }
 
     if ( hd && (width() != (int)w || height() != (int)h || this->depth() != dd) ) {
@@ -1486,19 +1790,24 @@
 
     }
 
-    XPutImage( dpy, hd, qt_xget_readonly_gc( x11Screen(), FALSE  ),
-	       xi, 0, 0, 0, 0, w, h );
+#ifdef QT_MITSHM_CONVERSIONS
+    if( mitshm_ximage )
+        XShmPutImage( dpy, hd, qt_xget_readonly_gc( x11Screen(), FALSE ),
+                      xi, 0, 0, 0, 0, w, h, False );
+    else
+#endif
+        XPutImage( dpy, hd, qt_xget_readonly_gc( x11Screen(), FALSE  ),
+                   xi, 0, 0, 0, 0, w, h );
 
-    if ( data->optim != BestOptim ) {		// throw away image
-	qSafeXDestroyImage( xi );
-	data->ximage = 0;
-    } else {					// keep ximage that we created
-	data->ximage = xi;
-    }
     data->w = w;
     data->h = h;
     data->d = dd;
 
+    XImage* axi = NULL;
+#ifdef QT_MITSHM_CONVERSIONS
+    bool mitshm_aximage = false;
+    XShmSegmentInfo ashminfo;
+#endif
     if ( image.hasAlphaBuffer() ) {
 	QBitmap m;
 	m = image.createAlphaMask( conversion_flags );
@@ -1534,38 +1843,90 @@
 	    data->alphapm->rendhd =
 		(HANDLE) XftDrawCreateAlpha( x11Display(), data->alphapm->hd, 8 );
 
-	    XImage *axi = XCreateImage(x11Display(), (Visual *) x11Visual(),
-				       8, ZPixmap, 0, 0, w, h, 8, 0);
+#ifdef QT_MITSHM_CONVERSIONS
+            axi = qt_XShmCreateImage( x11Display(), (Visual*)x11Visual(),
+                                      8, ZPixmap, 0, 0, w, h, 8, 0, &ashminfo );
+            if( axi != NULL )
+                mitshm_aximage = true;
+            else
+#endif
+	        axi = XCreateImage(x11Display(), (Visual *) x11Visual(),
+				   8, ZPixmap, 0, 0, w, h, 8, 0);
 
 	    if (axi) {
-		// the data is deleted by qSafeXDestroyImage
-		axi->data = (char *) malloc(h * axi->bytes_per_line);
-		Q_CHECK_PTR( axi->data );
+                if( axi->data==NULL ) {
+		    // the data is deleted by qSafeXDestroyImage
+		    axi->data = (char *) malloc(h * axi->bytes_per_line);
+		    Q_CHECK_PTR( axi->data );
+                }
 		char *aptr = axi->data;
 
 		if (image.depth() == 32) {
 		    const int *iptr = (const int *) image.bits();
-		    int max = w * h;
-		    while (max--)
-			*aptr++ = *iptr++ >> 24; // squirt
+                    if( axi->bytes_per_line == (int)w ) {
+		        int max = w * h;
+		        while (max--)
+			    *aptr++ = *iptr++ >> 24; // squirt
+                    } else {
+                        for (uint i = 0; i < h; ++i ) {
+                            for (uint j = 0; j < w; ++j )
+                                *aptr++ = *iptr++ >> 24; // squirt
+                            aptr += ( axi->bytes_per_line - w );
+                        }
+                    }
 		} else if (image.depth() == 8) {
 		    const QRgb * const rgb = image.colorTable();
 		    for (uint y = 0; y < h; ++y) {
 			const uchar *iptr = image.scanLine(y);
 			for (uint x = 0; x < w; ++x)
 			    *aptr++ = qAlpha(rgb[*iptr++]);
+                        aptr += ( axi->bytes_per_line - w );
 		    }
 		}
 
 		GC gc = XCreateGC(x11Display(), data->alphapm->hd, 0, 0);
-		XPutImage(dpy, data->alphapm->hd, gc, axi, 0, 0, 0, 0, w, h);
+#ifdef QT_MITSHM_CONVERSIONS
+                if( mitshm_aximage )
+                    XShmPutImage( dpy, data->alphapm->hd, gc, axi, 0, 0, 0, 0, w, h, False );
+                else
+#endif
+		    XPutImage(dpy, data->alphapm->hd, gc, axi, 0, 0, 0, 0, w, h);
 		XFreeGC(x11Display(), gc);
-		qSafeXDestroyImage(axi);
 	    }
 	}
 #endif // QT_NO_XFTFREETYPE
     }
 
+#ifdef QT_MITSHM_CONVERSIONS
+    if( mitshm_ximage || mitshm_aximage )
+        XSync( x11Display(), False ); // wait until processed
+#endif
+
+    if ( data->optim != BestOptim ) {		// throw away image
+#ifdef QT_MITSHM_CONVERSIONS
+        if( mitshm_ximage )
+            qt_XShmDestroyImage( xi, &shminfo );
+        else
+#endif
+	qSafeXDestroyImage( xi );
+	data->ximage = 0;
+    } else {					// keep ximage that we created
+#ifdef QT_MITSHM_CONVERSIONS
+        if( mitshm_ximage ) { // copy the XImage?
+            qt_XShmDestroyImage( xi, &shminfo );
+            xi = 0;
+        }
+#endif
+	data->ximage = xi;
+    }
+    if( axi ) {
+#ifdef QT_MITSHM_CONVERSIONS
+        if( mitshm_aximage )
+            qt_XShmDestroyImage( axi, &ashminfo );
+        else
+#endif
+        qSafeXDestroyImage(axi);
+    }
     return TRUE;
 }
 
@@ -1722,7 +2083,7 @@
 	return pm;
     }
 
-#if defined(QT_MITSHM)
+#if defined(QT_MITSHM_XFORM)
     static bool try_once = TRUE;
     if (try_once) {
 	try_once = FALSE;
@@ -1755,7 +2116,7 @@
 	dbpl = ((w*bpp+31)/32)*4;
     dbytes = dbpl*h;
 
-#if defined(QT_MITSHM)
+#if defined(QT_MITSHM_XFORM)
     if ( use_mitshm ) {
 	dptr = (uchar *)xshmimg->data;
 	uchar fillbyte = bpp == 8 ? white.pixel() : 0xff;
@@ -1771,7 +2132,7 @@
 	    memset( dptr, Qt::white.pixel( x11Screen() ), dbytes );
 	else
 	    memset( dptr, 0xff, dbytes );
-#if defined(QT_MITSHM)
+#if defined(QT_MITSHM_XFORM)
     }
 #endif
 
@@ -1802,7 +2163,7 @@
     } else {
 	xbpl  = (w*bpp)/8;
 	p_inc = dbpl - xbpl;
-#if defined(QT_MITSHM)
+#if defined(QT_MITSHM_XFORM)
 	if ( use_mitshm )
 	    p_inc = xshmimg->bytes_per_line - xbpl;
 #endif
@@ -1839,7 +2200,7 @@
 	QPixmap pm( w, h );
 	pm.data->uninit = FALSE;
 	pm.x11SetScreen( x11Screen() );
-#if defined(QT_MITSHM)
+#if defined(QT_MITSHM_XFORM)
 	if ( use_mitshm ) {
 	    XCopyArea( dpy, xshmpm, pm.handle(), gc, 0, 0, w, h, 0, 0 );
 	} else {
@@ -1848,7 +2209,7 @@
 			       ZPixmap, 0, (char *)dptr, w, h, 32, 0 );
 	    XPutImage( dpy, pm.handle(), gc, xi, 0, 0, 0, 0, w, h);
 	    qSafeXDestroyImage( xi );
-#if defined(QT_MITSHM)
+#if defined(QT_MITSHM_XFORM)
 	}
 #endif
 
diff -Nru qt-x11-free-3.3.3.orig/src/kernel/qpixmap_x11.cpp~ qt-x11-free-3.3.3/src/kernel/qpixmap_x11.cpp~
--- qt-x11-free-3.3.3.orig/src/kernel/qpixmap_x11.cpp~	1970-01-01 01:00:00.000000000 +0100
+++ qt-x11-free-3.3.3/src/kernel/qpixmap_x11.cpp~	2004-08-22 13:22:38.977742159 +0200
@@ -0,0 +1,2329 @@
+/****************************************************************************
+** $Id: qt/qpixmap_x11.cpp   3.3.3   edited Jan 13 2004 $
+**
+** Implementation of QPixmap class for X11
+**
+** Created : 940501
+**
+** Copyright (C) 1992-2003 Trolltech AS.  All rights reserved.
+**
+** This file is part of the kernel module of the Qt GUI Toolkit.
+**
+** This file may be distributed under the terms of the Q Public License
+** as defined by Trolltech AS of Norway and appearing in the file
+** LICENSE.QPL included in the packaging of this file.
+**
+** This file may be distributed and/or modified under the terms of the
+** GNU General Public License version 2 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.
+**
+** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
+** licenses for Unix/X11 may use this file in accordance with the Qt Commercial
+** License Agreement provided with the Software.
+**
+** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+**
+** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
+**   information about Qt Commercial License Agreements.
+** See http://www.trolltech.com/qpl/ for QPL licensing information.
+** See http://www.trolltech.com/gpl/ for GPL licensing information.
+**
+** Contact info@trolltech.com if any conditions of this licensing are
+** not clear to you.
+**
+**********************************************************************/
+
+// NOT REVISED
+
+#include "qplatformdefs.h"
+
+#if defined(Q_OS_WIN32) && defined(QT_MITSHM)
+#undef QT_MITSHM
+#endif
+
+#ifdef QT_MITSHM
+
+// Use the MIT Shared Memory extension for pixmap<->image conversions
+#define QT_MITSHM_CONVERSIONS
+
+// Uncomment the next line to enable the MIT Shared Memory extension
+// for QPixmap::xForm()
+//
+// WARNING:  This has some problems:
+//
+//    1. Consumes a 800x600 pixmap
+//    2. Qt does not handle the ShmCompletion message, so you will
+//        get strange effects if you xForm() repeatedly.
+//
+// #define QT_MITSHM_XFORM
+
+#else
+#undef QT_MITSHM_CONVERSIONS
+#undef QT_MITSHM_XFORM
+#endif
+
+#include "qbitmap.h"
+#include "qpaintdevicemetrics.h"
+#include "qimage.h"
+#include "qwmatrix.h"
+#include "qapplication.h"
+#include "qt_x11_p.h"
+
+#include <stdlib.h>
+
+#if defined(Q_CC_MIPS)
+#  define for if(0){}else for
+#endif
+
+
+/*!
+  \class QPixmap::QPixmapData
+  \brief The QPixmap::QPixmapData class is an internal class.
+  \internal
+*/
+
+
+// For thread-safety:
+//   image->data does not belong to X11, so we must free it ourselves.
+
+inline static void qSafeXDestroyImage( XImage *x )
+{
+    if ( x->data ) {
+	free( x->data );
+	x->data = 0;
+    }
+    XDestroyImage( x );
+}
+
+
+/*****************************************************************************
+  MIT Shared Memory Extension support: makes xForm noticeably (~20%) faster.
+ *****************************************************************************/
+
+#if defined(QT_MITSHM_XFORM)
+
+static bool	       xshminit = FALSE;
+static XShmSegmentInfo xshminfo;
+static XImage	      *xshmimg = 0;
+static Pixmap	       xshmpm  = 0;
+
+static void qt_cleanup_mitshm()
+{
+    if ( xshmimg == 0 )
+	return;
+    Display *dpy = QPaintDevice::x11AppDisplay();
+    if ( xshmpm ) {
+	XFreePixmap( dpy, xshmpm );
+	xshmpm = 0;
+    }
+    XShmDetach( dpy, &xshminfo ); xshmimg->data = 0;
+    qSafeXDestroyImage( xshmimg ); xshmimg = 0;
+    shmdt( xshminfo.shmaddr );
+    shmctl( xshminfo.shmid, IPC_RMID, 0 );
+}
+
+
+static bool qt_create_mitshm_buffer( const QPaintDevice* dev, int w, int h )
+{
+    static int major, minor;
+    static Bool pixmaps_ok;
+    Display *dpy = dev->x11Display();
+    int dd	 = dev->x11Depth();
+    Visual *vis	 = (Visual*)dev->x11Visual();
+
+    if ( xshminit ) {
+	qt_cleanup_mitshm();
+    } else {
+	if ( !XShmQueryVersion(dpy, &major, &minor, &pixmaps_ok) )
+	    return FALSE;			// MIT Shm not supported
+	qAddPostRoutine( qt_cleanup_mitshm );
+	xshminit = TRUE;
+    }
+
+    xshmimg = XShmCreateImage( dpy, vis, dd, ZPixmap, 0, &xshminfo, w, h );
+    if ( !xshmimg )
+	return FALSE;
+
+    bool ok;
+    xshminfo.shmid = shmget( IPC_PRIVATE,
+			     xshmimg->bytes_per_line * xshmimg->height,
+			     IPC_CREAT | 0777 );
+    ok = xshminfo.shmid != -1;
+    if ( ok ) {
+	xshmimg->data = (char*)shmat( xshminfo.shmid, 0, 0 );
+	xshminfo.shmaddr = xshmimg->data;
+	ok = ( xshminfo.shmaddr != (char*)-1 );
+    }
+    xshminfo.readOnly = FALSE;
+    if ( ok )
+	ok = XShmAttach( dpy, &xshminfo );
+    if ( !ok ) {
+	qSafeXDestroyImage( xshmimg );
+	xshmimg = 0;
+	if ( xshminfo.shmaddr )
+	    shmdt( xshminfo.shmaddr );
+	if ( xshminfo.shmid != -1 )
+	    shmctl( xshminfo.shmid, IPC_RMID, 0 );
+	return FALSE;
+    }
+    if ( pixmaps_ok )
+	xshmpm = XShmCreatePixmap( dpy, DefaultRootWindow(dpy), xshmimg->data,
+				   &xshminfo, w, h, dd );
+
+    return TRUE;
+}
+
+#else
+
+// If extern, need a dummy.
+//
+// static bool qt_create_mitshm_buffer( QPaintDevice*, int, int )
+// {
+//     return FALSE;
+// }
+
+#endif // QT_MITSHM_XFORM
+
+#ifdef QT_MITSHM_CONVERSIONS
+
+static bool qt_mitshm_error = false;
+static int qt_mitshm_errorhandler( Display*, XErrorEvent* )
+{
+    qt_mitshm_error = true;
+    return 0;
+}
+
+static XImage* qt_XShmCreateImage( Display* dpy, Visual* visual, unsigned int depth,
+    int format, int /*offset*/, char* /*data*/, unsigned int width, unsigned int height,
+    int /*bitmap_pad*/, int /*bytes_per_line*/, XShmSegmentInfo* shminfo )
+{
+    if( width * height * depth < 100*100*32 )
+        return NULL;
+    static int shm_inited = -1;
+    if( shm_inited == -1 ) {
+        if( XShmQueryExtension( dpy ))
+            shm_inited = 1;
+        else
+            shm_inited = 0;
+    }
+    if( shm_inited == 0 )
+        return NULL;
+    XImage* xi = XShmCreateImage( dpy, visual, depth, format, NULL, shminfo, width,
+        height );
+    if( xi == NULL )
+        return NULL;
+    shminfo->shmid = shmget( IPC_PRIVATE, xi->bytes_per_line * xi->height,
+        IPC_CREAT|0777);
+    if( shminfo->shmid < 0 ) {
+        XDestroyImage( xi );
+        return NULL;
+    }
+    shminfo->readOnly = False;
+    shminfo->shmaddr = (char*)shmat( shminfo->shmid, 0, 0 );
+    if( shminfo->shmaddr == (char*)-1 ) {
+        XDestroyImage( xi );
+        shmctl( shminfo->shmid, IPC_RMID, 0 );
+        return NULL;
+    }
+    xi->data = shminfo->shmaddr;
+#ifndef QT_MITSHM_RMID_IGNORES_REFCOUNT
+    // mark as deleted to automatically free the memory in case
+    // of a crash (but this doesn't work e.g. on Solaris)
+    shmctl( shminfo->shmid, IPC_RMID, 0 );
+#endif
+    if( shm_inited == 1 ) { // first time
+        XErrorHandler old_h = XSetErrorHandler( qt_mitshm_errorhandler );
+        XShmAttach( dpy, shminfo );
+        shm_inited = 2;
+        XSync( dpy, False );
+        XSetErrorHandler( old_h );
+        if( qt_mitshm_error ) { // oops ... perhaps we are remote?
+            shm_inited = 0;
+            XDestroyImage( xi );
+            shmdt( shminfo->shmaddr );
+#ifdef QT_MITSHM_RMID_IGNORES_REFCOUNT
+            shmctl( shminfo->shmid, IPC_RMID, 0 );
+#endif
+            return NULL;
+        }
+    } else
+        XShmAttach( dpy, shminfo );
+    return xi;
+}
+
+static void qt_XShmDestroyImage( XImage* xi, XShmSegmentInfo* shminfo )
+{
+    XShmDetach( QPaintDevice::x11AppDisplay(), shminfo );
+    XDestroyImage( xi );
+    shmdt( shminfo->shmaddr );
+#ifdef QT_MITSHM_RMID_IGNORES_REFCOUNT
+    shmctl( shminfo->shmid, IPC_RMID, 0 );
+#endif
+}
+
+static XImage* qt_XShmGetImage( const QPixmap* pix, int format,
+    XShmSegmentInfo* shminfo )
+{
+    XImage* xi = qt_XShmCreateImage( pix->x11Display(), (Visual*)pix->x11Visual(),
+        pix->depth(), format, 0, 0, pix->width(), pix->height(), 32, 0, shminfo );
+    if( xi == NULL )
+        return NULL;
+    if( XShmGetImage( pix->x11Display(), pix->handle(), xi, 0, 0, AllPlanes ) == False ) {
+        qt_XShmDestroyImage( xi, shminfo );
+        return NULL;
+    }
+    return xi;
+}
+
+#endif // QT_MITSHM_CONVERSIONS
+
+/*****************************************************************************
+  Internal functions
+ *****************************************************************************/
+
+extern const uchar *qt_get_bitflip_array();		// defined in qimage.cpp
+
+static uchar *flip_bits( const uchar *bits, int len )
+{
+    register const uchar *p = bits;
+    const uchar *end = p + len;
+    uchar *newdata = new uchar[len];
+    uchar *b = newdata;
+    const uchar *f = qt_get_bitflip_array();
+    while ( p < end )
+	*b++ = f[*p++];
+    return newdata;
+}
+
+// Returns position of highest bit set or -1 if none
+static int highest_bit( uint v )
+{
+    int i;
+    uint b = (uint)1 << 31;
+    for ( i=31; ((b & v) == 0) && i>=0;	 i-- )
+	b >>= 1;
+    return i;
+}
+
+// Returns position of lowest set bit in 'v' as an integer (0-31), or -1
+static int lowest_bit( uint v )
+{
+    int i;
+    ulong lb;
+    lb = 1;
+    for (i=0; ((v & lb) == 0) && i<32;  i++, lb<<=1);
+    return i==32 ? -1 : i;
+}
+
+// Counts the number of bits set in 'v'
+static uint n_bits( uint v )
+{
+    int i = 0;
+    while ( v ) {
+	v = v & (v - 1);
+	i++;
+    }
+    return i;
+}
+
+static uint *red_scale_table   = 0;
+static uint *green_scale_table = 0;
+static uint *blue_scale_table  = 0;
+
+static void cleanup_scale_tables()
+{
+    delete[] red_scale_table;
+    delete[] green_scale_table;
+    delete[] blue_scale_table;
+}
+
+/*
+  Could do smart bitshifting, but the "obvious" algorithm only works for
+  nBits >= 4. This is more robust.
+*/
+static void build_scale_table( uint **table, uint nBits )
+{
+    if ( nBits > 7 ) {
+#if defined(QT_CHECK_RANGE)
+	qWarning( "build_scale_table: internal error, nBits = %i", nBits );
+#endif
+	return;
+    }
+    if (!*table) {
+	static bool firstTable = TRUE;
+	if ( firstTable ) {
+	    qAddPostRoutine( cleanup_scale_tables );
+	    firstTable = FALSE;
+	}
+	*table = new uint[256];
+    }
+    int   maxVal   = (1 << nBits) - 1;
+    int   valShift = 8 - nBits;
+    int i;
+    for( i = 0 ; i < maxVal + 1 ; i++ )
+	(*table)[i << valShift] = i*255/maxVal;
+}
+
+static int defaultScreen = -1;
+
+extern bool qt_use_xrender; // defined in qapplication_x11.cpp
+extern bool qt_has_xft;     // defined in qfont_x11.cpp
+
+#ifndef QT_NO_XFTFREETYPE
+#ifndef QT_XFT2
+// Xft1 doesn't have XftDrawCreateAlpha, so we fake it in qtaddons_x11.cpp
+extern "C" XftDraw *XftDrawCreateAlpha( Display *, Qt::HANDLE, int );
+#endif // QT_XFT2
+#endif // QT_NO_XFTFREETYPE
+
+/*****************************************************************************
+  QPixmap member functions
+ *****************************************************************************/
+
+/*!
+  \internal
+  Initializes the pixmap data.
+*/
+
+void QPixmap::init( int w, int h, int d, bool bitmap, Optimization optim )
+{
+#if defined(QT_CHECK_STATE)
+    if ( qApp->type() == QApplication::Tty ) {
+	qWarning( "QPixmap: Cannot create a QPixmap when no GUI "
+		  "is being used" );
+    }
+#endif
+
+    static int serial = 0;
+
+    if ( defaultScreen >= 0 && defaultScreen != x11Screen() ) {
+	QPaintDeviceX11Data* xd = getX11Data( TRUE );
+	xd->x_screen = defaultScreen;
+	xd->x_depth = QPaintDevice::x11AppDepth( xd->x_screen );
+	xd->x_cells = QPaintDevice::x11AppCells( xd->x_screen );
+	xd->x_colormap = QPaintDevice::x11AppColormap( xd->x_screen );
+	xd->x_defcolormap = QPaintDevice::x11AppDefaultColormap( xd->x_screen );
+	xd->x_visual = QPaintDevice::x11AppVisual( xd->x_screen );
+	xd->x_defvisual = QPaintDevice::x11AppDefaultVisual( xd->x_screen );
+	setX11Data( xd );
+    }
+
+    int dd = x11Depth();
+
+    if ( optim == DefaultOptim )		// use default optimization
+	optim = defOptim;
+
+    data = new QPixmapData;
+    Q_CHECK_PTR( data );
+
+    memset( data, 0, sizeof(QPixmapData) );
+    data->count  = 1;
+    data->uninit = TRUE;
+    data->bitmap = bitmap;
+    data->ser_no = ++serial;
+    data->optim	 = optim;
+
+    bool make_null = w == 0 || h == 0;		// create null pixmap
+    if ( d == 1 )				// monocrome pixmap
+	data->d = 1;
+    else if ( d < 0 || d == dd )		// def depth pixmap
+	data->d = dd;
+    if ( make_null || w < 0 || h < 0 || data->d == 0 ) {
+	hd = 0;
+	rendhd = 0;
+#if defined(QT_CHECK_RANGE)
+	if ( !make_null )
+	    qWarning( "QPixmap: Invalid pixmap parameters" );
+#endif
+	return;
+    }
+    data->w = w;
+    data->h = h;
+    hd = (HANDLE)XCreatePixmap( x11Display(), RootWindow(x11Display(), x11Screen() ),
+				w, h, data->d );
+
+#ifndef QT_NO_XFTFREETYPE
+    if ( qt_has_xft ) {
+	if ( data->d == 1 ) {
+	    rendhd = (HANDLE) XftDrawCreateBitmap( x11Display(), hd );
+	} else {
+	    rendhd = (HANDLE) XftDrawCreate( x11Display(), hd,
+					     (Visual *) x11Visual(),
+					     x11Colormap() );
+	}
+    }
+#endif // QT_NO_XFTFREETYPE
+
+}
+
+
+void QPixmap::deref()
+{
+    if ( data && data->deref() ) {			// last reference lost
+	delete data->mask;
+	delete data->alphapm;
+	if ( data->ximage )
+	    qSafeXDestroyImage( (XImage*)data->ximage );
+	if ( data->maskgc )
+	    XFreeGC( x11Display(), (GC)data->maskgc );
+	if ( qApp && hd) {
+
+#ifndef QT_NO_XFTFREETYPE
+	    if (rendhd) {
+		XftDrawDestroy( (XftDraw *) rendhd );
+		rendhd = 0;
+	    }
+#endif // QT_NO_XFTFREETYPE
+
+	    XFreePixmap( x11Display(), hd );
+	    hd = 0;
+	}
+	delete data;
+    }
+}
+
+
+/*!
+    Constructs a monochrome pixmap, with width \a w and height \a h,
+    that is initialized with the data in \a bits. The \a isXbitmap
+    indicates whether the data is an X bitmap and defaults to FALSE.
+    This constructor is protected and used by the QBitmap class.
+*/
+
+QPixmap::QPixmap( int w, int h, const uchar *bits, bool isXbitmap)
+    : QPaintDevice( QInternal::Pixmap )
+{						// for bitmaps only
+    init( 0, 0, 0, FALSE, defOptim );
+    if ( w <= 0 || h <= 0 )			// create null pixmap
+	return;
+
+    data->uninit = FALSE;
+    data->w = w;
+    data->h = h;
+    data->d = 1;
+    uchar *flipped_bits;
+    if ( isXbitmap ) {
+	flipped_bits = 0;
+    } else {					// not X bitmap -> flip bits
+	flipped_bits = flip_bits( bits, ((w+7)/8)*h );
+	bits = flipped_bits;
+    }
+    hd = (HANDLE)XCreateBitmapFromData( x11Display(),
+					RootWindow(x11Display(), x11Screen() ),
+					(char *)bits, w, h );
+
+#ifndef QT_NO_XFTFREETYPE
+    if ( qt_has_xft )
+	rendhd = (HANDLE) XftDrawCreateBitmap (x11Display (), hd);
+#endif // QT_NO_XFTFREETYPE
+
+    if ( flipped_bits )				// Avoid purify complaint
+	delete [] flipped_bits;
+}
+
+
+/*!
+    This is a special-purpose function that detaches the pixmap from
+    shared pixmap data.
+
+    A pixmap is automatically detached by Qt whenever its contents is
+    about to change. This is done in all QPixmap member functions
+    that modify the pixmap (fill(), resize(), convertFromImage(),
+    load(), etc.), in bitBlt() for the destination pixmap and in
+    QPainter::begin() on a pixmap.
+
+    It is possible to modify a pixmap without letting Qt know. You can
+    first obtain the system-dependent handle() and then call
+    system-specific functions (for instance, BitBlt under Windows)
+    that modify the pixmap contents. In such cases, you can call
+    detach() to cut the pixmap loose from other pixmaps that share
+    data with this one.
+
+    detach() returns immediately if there is just a single reference
+    or if the pixmap has not been initialized yet.
+*/
+
+void QPixmap::detach()
+{
+    if ( data->uninit || data->count == 1 )
+	data->uninit = FALSE;
+    else
+	*this = copy();
+
+    // reset the cache data
+    if ( data->ximage ) {
+	qSafeXDestroyImage( (XImage*)data->ximage );
+	data->ximage = 0;
+    }
+    if ( data->maskgc ) {
+	XFreeGC( x11Display(), (GC)data->maskgc );
+	data->maskgc = 0;
+    }
+}
+
+
+/*!
+    Returns the default pixmap depth, i.e. the depth a pixmap gets if
+    -1 is specified.
+
+    \sa depth()
+*/
+
+int QPixmap::defaultDepth()
+{
+    return x11AppDepth();
+}
+
+
+/*!
+    \fn QPixmap::Optimization QPixmap::optimization() const
+
+    Returns the optimization setting for this pixmap.
+
+    The default optimization setting is \c QPixmap::NormalOptim. You
+    can change this setting in two ways:
+    \list
+    \i Call setDefaultOptimization() to set the default optimization
+    for all new pixmaps.
+    \i Call setOptimization() to set the optimization for individual
+    pixmaps.
+    \endlist
+
+    \sa setOptimization(), setDefaultOptimization(), defaultOptimization()
+*/
+
+/*!
+    Sets pixmap drawing optimization for this pixmap.
+
+    The \a optimization setting affects pixmap operations, in
+    particular drawing of transparent pixmaps (bitBlt() a pixmap with
+    a mask set) and pixmap transformations (the xForm() function).
+
+    Pixmap optimization involves keeping intermediate results in a
+    cache buffer and using the cache to speed up bitBlt() and xForm().
+    The cost is more memory consumption, up to twice as much as an
+    unoptimized pixmap.
+
+    Use the setDefaultOptimization() to change the default
+    optimization for all new pixmaps.
+
+    \sa optimization(), setDefaultOptimization(), defaultOptimization()
+*/
+
+void QPixmap::setOptimization( Optimization optimization )
+{
+    if ( optimization == data->optim )
+	return;
+    detach();
+    data->optim = optimization == DefaultOptim ?
+	    defOptim : optimization;
+    if ( data->optim == MemoryOptim && data->ximage ) {
+	qSafeXDestroyImage( (XImage*)data->ximage );
+	data->ximage = 0;
+    }
+}
+
+
+/*!
+    Fills the pixmap with the color \a fillColor.
+*/
+
+void QPixmap::fill( const QColor &fillColor )
+{
+    if ( isNull() )
+	return;
+    detach();					// detach other references
+    GC gc = qt_xget_temp_gc( x11Screen(), depth()==1 );
+    XSetForeground( x11Display(), gc, fillColor.pixel(x11Screen()) );
+    XFillRectangle( x11Display(), hd, gc, 0, 0, width(), height() );
+}
+
+
+/*!
+  Internal implementation of the virtual QPaintDevice::metric() function.
+
+  Use the QPaintDeviceMetrics class instead.
+
+  \a m is the metric to get.
+*/
+
+int QPixmap::metric( int m ) const
+{
+    int val;
+    if ( m == QPaintDeviceMetrics::PdmWidth )
+	val = width();
+    else if ( m == QPaintDeviceMetrics::PdmHeight ) {
+	val = height();
+    } else {
+	Display *dpy = x11Display();
+	int scr = x11Screen();
+	switch ( m ) {
+	    case QPaintDeviceMetrics::PdmDpiX:
+	    case QPaintDeviceMetrics::PdmPhysicalDpiX:
+		val = QPaintDevice::x11AppDpiX( scr );
+		break;
+	    case QPaintDeviceMetrics::PdmDpiY:
+	    case QPaintDeviceMetrics::PdmPhysicalDpiY:
+		val = QPaintDevice::x11AppDpiY( scr );
+		break;
+	    case QPaintDeviceMetrics::PdmWidthMM:
+		val = (DisplayWidthMM(dpy,scr)*width())/
+		      DisplayWidth(dpy,scr);
+		break;
+	    case QPaintDeviceMetrics::PdmHeightMM:
+		val = (DisplayHeightMM(dpy,scr)*height())/
+		      DisplayHeight(dpy,scr);
+		break;
+	    case QPaintDeviceMetrics::PdmNumColors:
+		val = 1 << depth();
+		break;
+	    case QPaintDeviceMetrics::PdmDepth:
+		val = depth();
+		break;
+	    default:
+		val = 0;
+#if defined(QT_CHECK_RANGE)
+		qWarning( "QPixmap::metric: Invalid metric command" );
+#endif
+	}
+    }
+    return val;
+}
+
+/*!
+    Converts the pixmap to a QImage. Returns a null image if it fails.
+
+    If the pixmap has 1-bit depth, the returned image will also be 1
+    bit deep. If the pixmap has 2- to 8-bit depth, the returned image
+    has 8-bit depth. If the pixmap has greater than 8-bit depth, the
+    returned image has 32-bit depth.
+
+    Note that for the moment, alpha masks on monochrome images are
+    ignored.
+
+    \sa convertFromImage()
+*/
+
+QImage QPixmap::convertToImage() const
+{
+    QImage image;
+    if ( isNull() )
+	return image; // null image
+
+    int	    w  = width();
+    int	    h  = height();
+    int	    d  = depth();
+    bool    mono = d == 1;
+    Visual *visual = (Visual *)x11Visual();
+    bool    trucol = (visual->c_class == TrueColor) && !mono && d > 8;
+
+    if ( d > 1 && d <= 8 )			// set to nearest valid depth
+	d = 8;					//   2..8 ==> 8
+    // we could run into the situation where d == 8 AND trucol is true, which can
+    // cause problems when converting to and from images.  in this case, always treat
+    // the depth as 32... from Klaus Schmidinger and qt-bugs/arc-15/31333.
+    if ( d > 8 || trucol )
+	d = 32;					//   > 8  ==> 32
+
+    XImage *xi = (XImage *)data->ximage;	// any cached ximage?
+#ifdef QT_MITSHM_CONVERSIONS
+    bool mitshm_ximage = false;
+    XShmSegmentInfo shminfo;
+#endif
+    if ( !xi ) {				// fetch data from X server
+#ifdef QT_MITSHM_CONVERSIONS
+        xi = qt_XShmGetImage( this, mono ? XYPixmap : ZPixmap, &shminfo );
+        if( xi ) {
+            mitshm_ximage = true;
+        } else
+#endif
+	    xi = XGetImage( x11Display(), hd, 0, 0, w, h, AllPlanes,
+			mono ? XYPixmap : ZPixmap );
+    }
+    Q_CHECK_PTR( xi );
+
+    QImage::Endian bitOrder = QImage::IgnoreEndian;
+    if ( mono ) {
+	bitOrder = xi->bitmap_bit_order == LSBFirst ?
+		   QImage::LittleEndian : QImage::BigEndian;
+    }
+    image.create( w, h, d, 0, bitOrder );
+    if ( image.isNull() ) {			// could not create image
+#ifdef QT_MITSHM_CONVERSIONS
+        if( mitshm_ximage )
+            qt_XShmDestroyImage( xi, &shminfo );
+        else
+#endif
+        qSafeXDestroyImage( xi );
+	return image;
+    }
+
+    const QPixmap* msk = mask();
+    const QPixmap *alf = data->alphapm;
+
+    QImage alpha;
+    if (alf) {
+        XImage* axi;
+#ifdef QT_MITSHM_CONVERSIONS
+        bool mitshm_aximage = false;
+        XShmSegmentInfo ashminfo;
+        axi = qt_XShmGetImage( alf, ZPixmap, &ashminfo );
+        if( axi ) {
+            mitshm_aximage = true;
+        } else
+#endif
+            axi = XGetImage(x11Display(), alf->hd, 0, 0, w, h, AllPlanes, ZPixmap);
+
+	if (axi) {
+	    image.setAlphaBuffer( TRUE );
+	    alpha.create(w, h, 8);
+
+	    // copy each scanline
+	    char *src = axi->data;
+	    int bpl = QMIN(alpha.bytesPerLine(), axi->bytes_per_line);
+	    for (int y = 0; y < h; y++ ) {
+		memcpy( alpha.scanLine(y), src, bpl );
+		src += axi->bytes_per_line;
+	    }
+
+#ifdef QT_MITSHM_CONVERSIONS
+            if( mitshm_aximage )
+                qt_XShmDestroyImage( axi, &ashminfo );
+            else
+#endif
+    	        qSafeXDestroyImage( axi );
+	}
+    } else if (msk) {
+	image.setAlphaBuffer( TRUE );
+	alpha = msk->convertToImage();
+    }
+    bool ale = alpha.bitOrder() == QImage::LittleEndian;
+
+    if ( trucol ) {				// truecolor
+	const uint red_mask	 = (uint)visual->red_mask;
+	const uint green_mask	 = (uint)visual->green_mask;
+	const uint blue_mask	 = (uint)visual->blue_mask;
+	const int  red_shift	 = highest_bit( red_mask )   - 7;
+	const int  green_shift = highest_bit( green_mask ) - 7;
+	const int  blue_shift	 = highest_bit( blue_mask )  - 7;
+
+	const uint red_bits    = n_bits( red_mask );
+	const uint green_bits  = n_bits( green_mask );
+	const uint blue_bits   = n_bits( blue_mask );
+
+	static uint red_table_bits   = 0;
+	static uint green_table_bits = 0;
+	static uint blue_table_bits  = 0;
+
+	if ( red_bits < 8 && red_table_bits != red_bits) {
+	    build_scale_table( &red_scale_table, red_bits );
+	    red_table_bits = red_bits;
+	}
+	if ( blue_bits < 8 && blue_table_bits != blue_bits) {
+	    build_scale_table( &blue_scale_table, blue_bits );
+	    blue_table_bits = blue_bits;
+	}
+	if ( green_bits < 8 && green_table_bits != green_bits) {
+	    build_scale_table( &green_scale_table, green_bits );
+	    green_table_bits = green_bits;
+	}
+
+	int  r, g, b;
+
+	QRgb  *dst;
+	uchar *src;
+	uint   pixel;
+	int    bppc = xi->bits_per_pixel;
+
+	if ( bppc > 8 && xi->byte_order == LSBFirst )
+	    bppc++;
+
+	for ( int y=0; y<h; y++ ) {
+	    uchar* asrc = alf || msk ? alpha.scanLine( y ) : 0;
+	    dst = (QRgb *)image.scanLine( y );
+	    src = (uchar *)xi->data + xi->bytes_per_line*y;
+	    for ( int x=0; x<w; x++ ) {
+		switch ( bppc ) {
+		case 8:
+		    pixel = *src++;
+		    break;
+		case 16:			// 16 bit MSB
+		    pixel = src[1] | (ushort)src[0] << 8;
+		    src += 2;
+		    break;
+		case 17:			// 16 bit LSB
+		    pixel = src[0] | (ushort)src[1] << 8;
+		    src += 2;
+		    break;
+		case 24:			// 24 bit MSB
+		    pixel = src[2] | (ushort)src[1] << 8 |
+			    (uint)src[0] << 16;
+		    src += 3;
+		    break;
+		case 25:			// 24 bit LSB
+		    pixel = src[0] | (ushort)src[1] << 8 |
+			    (uint)src[2] << 16;
+		    src += 3;
+		    break;
+		case 32:			// 32 bit MSB
+		    pixel = src[3] | (ushort)src[2] << 8 |
+			    (uint)src[1] << 16 | (uint)src[0] << 24;
+		    src += 4;
+		    break;
+		case 33:			// 32 bit LSB
+		    pixel = src[0] | (ushort)src[1] << 8 |
+			    (uint)src[2] << 16 | (uint)src[3] << 24;
+		    src += 4;
+		    break;
+		default:			// should not really happen
+		    x = w;			// leave loop
+		    y = h;
+		    pixel = 0;		// eliminate compiler warning
+#if defined(QT_CHECK_RANGE)
+		    qWarning( "QPixmap::convertToImage: Invalid depth %d",
+			      bppc );
+#endif
+		}
+		if ( red_shift > 0 )
+		    r = (pixel & red_mask) >> red_shift;
+		else
+		    r = (pixel & red_mask) << -red_shift;
+		if ( green_shift > 0 )
+		    g = (pixel & green_mask) >> green_shift;
+		else
+		    g = (pixel & green_mask) << -green_shift;
+		if ( blue_shift > 0 )
+		    b = (pixel & blue_mask) >> blue_shift;
+		else
+		    b = (pixel & blue_mask) << -blue_shift;
+
+		if ( red_bits < 8 )
+		    r = red_scale_table[r];
+		if ( green_bits < 8 )
+		    g = green_scale_table[g];
+		if ( blue_bits < 8 )
+		    b = blue_scale_table[b];
+
+		if (alf) {
+		    *dst++ = qRgba(r, g, b, asrc[x]);
+		} else if (msk) {
+		    if ( ale ) {
+			*dst++ = (asrc[x >> 3] & (1 << (x & 7)))
+				 ? qRgba(r, g, b, 0xff) : qRgba(r, g, b, 0x00);
+		    } else {
+			*dst++ = (asrc[x >> 3] & (1 << (7 -(x & 7))))
+				 ? qRgba(r, g, b, 0xff) : qRgba(r, g, b, 0x00);
+		    }
+		} else {
+		    *dst++ = qRgb(r, g, b);
+		}
+	    }
+	}
+    } else if ( xi->bits_per_pixel == d ) {	// compatible depth
+	char *xidata = xi->data;		// copy each scanline
+	int bpl = QMIN(image.bytesPerLine(),xi->bytes_per_line);
+	for ( int y=0; y<h; y++ ) {
+	    memcpy( image.scanLine(y), xidata, bpl );
+	    xidata += xi->bytes_per_line;
+	}
+    } else {
+	/* Typically 2 or 4 bits display depth */
+#if defined(QT_CHECK_RANGE)
+	qWarning( "QPixmap::convertToImage: Display not supported (bpp=%d)",
+		  xi->bits_per_pixel );
+#endif
+	image.reset();
+#ifdef QT_MITSHM_CONVERSIONS
+        if( mitshm_ximage )
+            qt_XShmDestroyImage( xi, &shminfo );
+        else
+#endif
+            qSafeXDestroyImage( xi );
+	return image;
+    }
+
+    if ( mono ) {				// bitmap
+	image.setNumColors( 2 );
+	image.setColor( 0, qRgb(255,255,255) );
+	image.setColor( 1, qRgb(0,0,0) );
+    } else if ( !trucol ) {			// pixmap with colormap
+	register uchar *p;
+	uchar *end;
+	uchar  use[256];			// pixel-in-use table
+	uchar  pix[256];			// pixel translation table
+	int    ncols, i, bpl;
+	memset( use, 0, 256 );
+	memset( pix, 0, 256 );
+	bpl = image.bytesPerLine();
+
+	if (msk) {				// which pixels are used?
+	    for ( i=0; i<h; i++ ) {
+		uchar* asrc = alpha.scanLine( i );
+		p = image.scanLine( i );
+		for ( int x = 0; x < w; x++ ) {
+		    if ( ale ) {
+			if (asrc[x >> 3] & (1 << (x & 7)))
+			    use[*p] = 1;
+		    } else {
+			if (asrc[x >> 3] & (1 << (7 -(x & 7))))
+			    use[*p] = 1;
+		    }
+		    ++p;
+		}
+	    }
+	} else {
+	    for ( i=0; i<h; i++ ) {
+		p = image.scanLine( i );
+		end = p + bpl;
+		while ( p < end )
+		    use[*p++] = 1;
+	    }
+	}
+	ncols = 0;
+	for ( i=0; i<256; i++ ) {		// build translation table
+	    if ( use[i] )
+		pix[i] = ncols++;
+	}
+	for ( i=0; i<h; i++ ) {			// translate pixels
+	    p = image.scanLine( i );
+	    end = p + bpl;
+	    while ( p < end ) {
+		*p = pix[*p];
+		p++;
+	    }
+	}
+
+	Colormap cmap	= x11Colormap();
+	int	 ncells = x11Cells();
+	XColor *carr = new XColor[ncells];
+	for ( i=0; i<ncells; i++ )
+	    carr[i].pixel = i;
+	// Get default colormap
+	XQueryColors( x11Display(), cmap, carr, ncells );
+
+	if (msk) {
+	    int trans;
+	    if (ncols < 256) {
+		trans = ncols++;
+		image.setNumColors( ncols );	// create color table
+		image.setColor( trans, 0x00000000 );
+	    } else {
+		image.setNumColors( ncols );	// create color table
+		// oh dear... no spare "transparent" pixel.
+		// use first pixel in image (as good as any).
+		trans = image.scanLine( i )[0];
+	    }
+	    for ( i=0; i<h; i++ ) {
+		uchar* asrc = alpha.scanLine( i );
+		p = image.scanLine( i );
+		for ( int x = 0; x < w; x++ ) {
+		    if ( ale ) {
+			if (!(asrc[x >> 3] & (1 << (x & 7))))
+			    *p = trans;
+		    } else {
+			if (!(asrc[x >> 3] & (1 << (7 -(x & 7)))))
+			    *p = trans;
+		    }
+		    ++p;
+		}
+	    }
+	} else {
+	    image.setNumColors( ncols );	// create color table
+	}
+	int j = 0;
+	for ( i=0; i<256; i++ ) {		// translate pixels
+	    if ( use[i] ) {
+		image.setColor( j++,
+				( msk ? 0xff000000 : 0 )
+				| qRgb( (carr[i].red   >> 8) & 255,
+					(carr[i].green >> 8) & 255,
+					(carr[i].blue  >> 8) & 255 ) );
+	    }
+	}
+
+	delete [] carr;
+    }
+    if ( data->optim != BestOptim ) {		// throw away image data
+#ifdef QT_MITSHM_CONVERSIONS
+        if( mitshm_ximage )
+            qt_XShmDestroyImage( xi, &shminfo );
+        else
+#endif
+            qSafeXDestroyImage( xi );
+	((QPixmap*)this)->data->ximage = 0;
+    } else {					// keep ximage data
+#ifdef QT_MITSHM_CONVERSIONS
+        if( mitshm_ximage ) { // copy the XImage?
+            qt_XShmDestroyImage( xi, &shminfo );
+            xi = 0;
+        }
+#endif
+	((QPixmap*)this)->data->ximage = xi;
+    }
+
+    return image;
+}
+
+
+/*!
+    Converts image \a img and sets this pixmap. Returns TRUE if
+    successful; otherwise returns FALSE.
+
+    The \a conversion_flags argument is a bitwise-OR of the
+    \l{Qt::ImageConversionFlags}. Passing 0 for \a conversion_flags
+    sets all the default options.
+
+    Note that even though a QPixmap with depth 1 behaves much like a
+    QBitmap, isQBitmap() returns FALSE.
+
+    If a pixmap with depth 1 is painted with color0 and color1 and
+    converted to an image, the pixels painted with color0 will produce
+    pixel index 0 in the image and those painted with color1 will
+    produce pixel index 1.
+
+    \sa convertToImage(), isQBitmap(), QImage::convertDepth(),
+    defaultDepth(), QImage::hasAlphaBuffer()
+*/
+
+bool QPixmap::convertFromImage( const QImage &img, int conversion_flags )
+{
+    if ( img.isNull() ) {
+#if defined(QT_CHECK_NULL)
+	qWarning( "QPixmap::convertFromImage: Cannot convert a null image" );
+#endif
+	return FALSE;
+    }
+    detach();					// detach other references
+    QImage  image = img;
+    const uint	 w   = image.width();
+    const uint	 h   = image.height();
+    int	 d   = image.depth();
+    const int	 dd  = x11Depth();
+    bool force_mono = (dd == 1 || isQBitmap() ||
+		       (conversion_flags & ColorMode_Mask)==MonoOnly );
+
+    // get rid of the mask
+    delete data->mask;
+    data->mask = 0;
+
+    // get rid of alpha pixmap
+    delete data->alphapm;
+    data->alphapm = 0;
+
+    // must be monochrome
+    if ( force_mono ) {
+	if ( d != 1 ) {
+	    // dither
+	    image = image.convertDepth( 1, conversion_flags );
+	    d = 1;
+	}
+    } else {					// can be both
+	bool conv8 = FALSE;
+	if ( d > 8 && dd <= 8 ) {		// convert to 8 bit
+	    if ( (conversion_flags & DitherMode_Mask) == AutoDither )
+		conversion_flags = (conversion_flags & ~DitherMode_Mask)
+				   | PreferDither;
+	    conv8 = TRUE;
+	} else if ( (conversion_flags & ColorMode_Mask) == ColorOnly ) {
+	    conv8 = d == 1;			// native depth wanted
+	} else if ( d == 1 ) {
+	    if ( image.numColors() == 2 ) {
+		QRgb c0 = image.color(0);	// Auto: convert to best
+		QRgb c1 = image.color(1);
+		conv8 = QMIN(c0,c1) != qRgb(0,0,0) || QMAX(c0,c1) != qRgb(255,255,255);
+	    } else {
+		// eg. 1-color monochrome images (they do exist).
+		conv8 = TRUE;
+	    }
+	}
+	if ( conv8 ) {
+	    image = image.convertDepth( 8, conversion_flags );
+	    d = 8;
+	}
+    }
+
+    if ( d == 1 ) {				// 1 bit pixmap (bitmap)
+	if ( hd ) {				// delete old X pixmap
+
+#ifndef QT_NO_XFTFREETYPE
+	    if (rendhd) {
+		XftDrawDestroy( (XftDraw *) rendhd );
+		rendhd = 0;
+	    }
+#endif // QT_NO_XFTFREETYPE
+
+	    XFreePixmap( x11Display(), hd );
+	}
+
+	// make sure image.color(0) == color0 (white) and image.color(1) == color1 (black)
+	if (image.color(0) == Qt::black.rgb() && image.color(1) == Qt::white.rgb()) {
+	    image.invertPixels();
+	    image.setColor(0, Qt::white.rgb());
+	    image.setColor(1, Qt::black.rgb());
+	}
+
+	char  *bits;
+	uchar *tmp_bits;
+	int    bpl = (w+7)/8;
+	int    ibpl = image.bytesPerLine();
+	if ( image.bitOrder() == QImage::BigEndian || bpl != ibpl ) {
+	    tmp_bits = new uchar[bpl*h];
+	    Q_CHECK_PTR( tmp_bits );
+	    bits = (char *)tmp_bits;
+	    uchar *p, *b, *end;
+	    uint y, count;
+	    if ( image.bitOrder() == QImage::BigEndian ) {
+		const uchar *f = qt_get_bitflip_array();
+		b = tmp_bits;
+		for ( y=0; y<h; y++ ) {
+		    p = image.scanLine( y );
+		    end = p + bpl;
+		    count = bpl;
+		    while ( count > 4 ) {
+			*b++ = f[*p++];
+			*b++ = f[*p++];
+			*b++ = f[*p++];
+			*b++ = f[*p++];
+			count -= 4;
+		    }
+		    while ( p < end )
+			*b++ = f[*p++];
+		}
+	    } else {				// just copy
+		b = tmp_bits;
+		p = image.scanLine( 0 );
+		for ( y=0; y<h; y++ ) {
+		    memcpy( b, p, bpl );
+		    b += bpl;
+		    p += ibpl;
+		}
+	    }
+	} else {
+	    bits = (char *)image.bits();
+	    tmp_bits = 0;
+	}
+	hd = (HANDLE)XCreateBitmapFromData( x11Display(),
+					    RootWindow(x11Display(), x11Screen() ),
+					    bits, w, h );
+
+#ifndef QT_NO_XFTFREETYPE
+	if ( qt_has_xft )
+	    rendhd = (HANDLE) XftDrawCreateBitmap( x11Display(), hd );
+#endif // QT_NO_XFTFREETYPE
+
+	if ( tmp_bits )				// Avoid purify complaint
+	    delete [] tmp_bits;
+	data->w = w;  data->h = h;  data->d = 1;
+
+	if ( image.hasAlphaBuffer() ) {
+	    QBitmap m;
+	    m = image.createAlphaMask( conversion_flags );
+	    setMask( m );
+	}
+	return TRUE;
+    }
+
+    Display *dpy   = x11Display();
+    Visual *visual = (Visual *)x11Visual();
+    XImage *xi	   = 0;
+    bool    trucol = (visual->c_class == TrueColor);
+    int	    nbytes = image.numBytes();
+    uchar  *newbits= 0;
+    int newbits_size = 0;
+#ifdef QT_MITSHM_CONVERSIONS
+    bool mitshm_ximage = false;
+    XShmSegmentInfo shminfo;
+#endif
+
+    if ( trucol ) {				// truecolor display
+	QRgb  pix[256];				// pixel translation table
+	const bool  d8 = d == 8;
+	const uint  red_mask	  = (uint)visual->red_mask;
+	const uint  green_mask  = (uint)visual->green_mask;
+	const uint  blue_mask	  = (uint)visual->blue_mask;
+	const int   red_shift	  = highest_bit( red_mask )   - 7;
+	const int   green_shift = highest_bit( green_mask ) - 7;
+	const int   blue_shift  = highest_bit( blue_mask )  - 7;
+	const uint  rbits = highest_bit(red_mask) - lowest_bit(red_mask) + 1;
+	const uint  gbits = highest_bit(green_mask) - lowest_bit(green_mask) + 1;
+	const uint  bbits = highest_bit(blue_mask) - lowest_bit(blue_mask) + 1;
+
+	if ( d8 ) {				// setup pixel translation
+	    QRgb *ctable = image.colorTable();
+	    for ( int i=0; i<image.numColors(); i++ ) {
+		int r = qRed  (ctable[i]);
+		int g = qGreen(ctable[i]);
+		int b = qBlue (ctable[i]);
+		r = red_shift	> 0 ? r << red_shift   : r >> -red_shift;
+		g = green_shift > 0 ? g << green_shift : g >> -green_shift;
+		b = blue_shift	> 0 ? b << blue_shift  : b >> -blue_shift;
+		pix[i] = (b & blue_mask) | (g & green_mask) | (r & red_mask)
+			 | ~(blue_mask | green_mask | red_mask);
+	    }
+	}
+
+#ifdef QT_MITSHM_CONVERSIONS
+        xi = qt_XShmCreateImage( dpy, visual, dd, ZPixmap, 0, 0, w, h, 32, 0, &shminfo );
+        if( xi != NULL ) {
+            mitshm_ximage = true;
+            newbits = (uchar*)xi->data;
+        }
+        else
+#endif
+	    xi = XCreateImage( dpy, visual, dd, ZPixmap, 0, 0, w, h, 32, 0 );
+	Q_CHECK_PTR( xi );
+        if( newbits == NULL )
+    	    newbits = (uchar *)malloc( xi->bytes_per_line*h );
+	Q_CHECK_PTR( newbits );
+	if ( !newbits )				// no memory
+	    return FALSE;
+	int    bppc = xi->bits_per_pixel;
+
+	if ( bppc > 8 && xi->byte_order == LSBFirst )
+	    bppc++;
+
+	bool contig_bits = n_bits(red_mask) == rbits &&
+                           n_bits(green_mask) == gbits &&
+                           n_bits(blue_mask) == bbits;
+	bool dither_tc =
+	    // Want it?
+	    (conversion_flags & Dither_Mask) != ThresholdDither &&
+	    (conversion_flags & DitherMode_Mask) != AvoidDither &&
+	    // Need it?
+	    bppc < 24 && !d8 &&
+	    // Can do it? (Contiguous bits?)
+	    contig_bits;
+
+	static bool init=FALSE;
+	static int D[16][16];
+	if ( dither_tc && !init ) {
+	    // I also contributed this code to XV - WWA.
+	    /*
+	      The dither matrix, D, is obtained with this formula:
+
+	      D2 = [ 0 2 ]
+	      [ 3 1 ]
+
+
+	      D2*n = [ 4*Dn       4*Dn+2*Un ]
+	      [ 4*Dn+3*Un  4*Dn+1*Un ]
+	    */
+	    int n,i,j;
+	    init=1;
+
+	    /* Set D2 */
+	    D[0][0]=0;
+	    D[1][0]=2;
+	    D[0][1]=3;
+	    D[1][1]=1;
+
+	    /* Expand using recursive definition given above */
+	    for (n=2; n<16; n*=2) {
+		for (i=0; i<n; i++) {
+		    for (j=0; j<n; j++) {
+			D[i][j]*=4;
+			D[i+n][j]=D[i][j]+2;
+			D[i][j+n]=D[i][j]+3;
+			D[i+n][j+n]=D[i][j]+1;
+		    }
+		}
+	    }
+	    init=TRUE;
+	}
+
+	for ( uint y=0; y<h; y++ ) {
+	    uchar* src = image.scanLine( y );
+	    uchar* dst = newbits + xi->bytes_per_line*y;
+	    QRgb* p = (QRgb *)src;
+
+#define GET_RGB \
+		int r = qRed  ( *p ); \
+		int g = qGreen( *p ); \
+		int b = qBlue ( *p++ ); \
+		r = red_shift   > 0 \
+		    ? r << red_shift   : r >> -red_shift; \
+		g = green_shift > 0 \
+		    ? g << green_shift : g >> -green_shift; \
+		b = blue_shift  > 0 \
+		    ? b << blue_shift  : b >> -blue_shift;
+
+#define GET_PIXEL \
+                int pixel; \
+		if ( d8 ) pixel = pix[*src++]; \
+		else { \
+		    GET_RGB \
+		    pixel = (b & blue_mask)|(g & green_mask) | (r & red_mask) \
+			    | ~(blue_mask | green_mask | red_mask); \
+		}
+
+#define GET_PIXEL_DITHER_TC \
+		int r = qRed  ( *p ); \
+		int g = qGreen( *p ); \
+		int b = qBlue ( *p++ ); \
+		const int thres = D[x%16][y%16]; \
+		if ( r <= (255-(1<<(8-rbits))) && ((r<<rbits) & 255) \
+			> thres) \
+		    r += (1<<(8-rbits)); \
+		if ( g <= (255-(1<<(8-gbits))) && ((g<<gbits) & 255) \
+			> thres) \
+		    g += (1<<(8-gbits)); \
+		if ( b <= (255-(1<<(8-bbits))) && ((b<<bbits) & 255) \
+			> thres) \
+		    b += (1<<(8-bbits)); \
+		r = red_shift   > 0 \
+		    ? r << red_shift   : r >> -red_shift; \
+		g = green_shift > 0 \
+		    ? g << green_shift : g >> -green_shift; \
+		b = blue_shift  > 0 \
+		    ? b << blue_shift  : b >> -blue_shift; \
+		int pixel = (b & blue_mask)|(g & green_mask) | (r & red_mask);
+
+	    if ( dither_tc ) {
+		uint x;
+		switch ( bppc ) {
+		case 16:			// 16 bit MSB
+		    for ( x=0; x<w; x++ ) {
+			GET_PIXEL_DITHER_TC
+			*dst++ = (pixel >> 8);
+			*dst++ = pixel;
+		    }
+		    break;
+		case 17:			// 16 bit LSB
+		    for ( x=0; x<w; x++ ) {
+			GET_PIXEL_DITHER_TC
+			*dst++ = pixel;
+			*dst++ = pixel >> 8;
+		    }
+		    break;
+		default:
+		    qFatal("Logic error");
+		}
+	    } else {
+		uint x;
+		switch ( bppc ) {
+		case 8:			// 8 bit
+		    for ( x=0; x<w; x++ ) {
+			int pixel = pix[*src++];
+			*dst++ = pixel;
+		    }
+		    break;
+		case 16:			// 16 bit MSB
+		    for ( x=0; x<w; x++ ) {
+			GET_PIXEL
+			*dst++ = (pixel >> 8);
+			*dst++ = pixel;
+		    }
+		    break;
+		case 17:			// 16 bit LSB
+		    for ( x=0; x<w; x++ ) {
+			GET_PIXEL
+			*dst++ = pixel;
+			*dst++ = pixel >> 8;
+		    }
+		    break;
+		case 24:			// 24 bit MSB
+		    for ( x=0; x<w; x++ ) {
+			GET_PIXEL
+			*dst++ = pixel >> 16;
+			*dst++ = pixel >> 8;
+			*dst++ = pixel;
+		    }
+		    break;
+		case 25:			// 24 bit LSB
+		    for ( x=0; x<w; x++ ) {
+			GET_PIXEL
+			*dst++ = pixel;
+			*dst++ = pixel >> 8;
+			*dst++ = pixel >> 16;
+		    }
+		    break;
+		case 32:			// 32 bit MSB
+		    for ( x=0; x<w; x++ ) {
+			GET_PIXEL
+			*dst++ = pixel >> 24;
+			*dst++ = pixel >> 16;
+			*dst++ = pixel >> 8;
+			*dst++ = pixel;
+		    }
+		    break;
+		case 33:			// 32 bit LSB
+		    for ( x=0; x<w; x++ ) {
+			GET_PIXEL
+			*dst++ = pixel;
+			*dst++ = pixel >> 8;
+			*dst++ = pixel >> 16;
+			*dst++ = pixel >> 24;
+		    }
+		    break;
+		default:
+		    qFatal("Logic error 2");
+		}
+	    }
+	}
+	xi->data = (char *)newbits;
+    }
+
+    if ( d == 8 && !trucol ) {			// 8 bit pixmap
+	int  pop[256];				// pixel popularity
+
+	if ( image.numColors() == 0 )
+	    image.setNumColors( 1 );
+
+	memset( pop, 0, sizeof(int)*256 );	// reset popularity array
+	uint i;
+	for ( i=0; i<h; i++ ) {			// for each scanline...
+	    uchar* p = image.scanLine( i );
+	    uchar *end = p + w;
+	    while ( p < end )			// compute popularity
+		pop[*p++]++;
+	}
+
+	newbits = (uchar *)malloc( nbytes );	// copy image into newbits
+        newbits_size = nbytes;
+	Q_CHECK_PTR( newbits );
+	if ( !newbits )				// no memory
+	    return FALSE;
+	uchar* p = newbits;
+	memcpy( p, image.bits(), nbytes );	// copy image data into newbits
+
+	/*
+	 * The code below picks the most important colors. It is based on the
+	 * diversity algorithm, implemented in XV 3.10. XV is (C) by John Bradley.
+	 */
+
+	struct PIX {				// pixel sort element
+	    uchar r,g,b,n;			// color + pad
+	    int	  use;				// popularity
+	    int	  index;			// index in colormap
+	    int	  mindist;
+	};
+	int ncols = 0;
+	for ( i=0; i< (uint) image.numColors(); i++ ) { // compute number of colors
+	    if ( pop[i] > 0 )
+		ncols++;
+	}
+	for ( i=image.numColors(); i<256; i++ ) // ignore out-of-range pixels
+	    pop[i] = 0;
+
+	// works since we make sure above to have at least
+	// one color in the image
+	if ( ncols == 0 )
+	    ncols = 1;
+
+	PIX pixarr[256];			// pixel array
+	PIX pixarr_sorted[256];			// pixel array (sorted)
+	memset( pixarr, 0, ncols*sizeof(PIX) );
+	PIX *px		   = &pixarr[0];
+	int  maxpop = 0;
+	int  maxpix = 0;
+	Q_CHECK_PTR( pixarr );
+	uint j = 0;
+	QRgb* ctable = image.colorTable();
+	for ( i=0; i<256; i++ ) {		// init pixel array
+	    if ( pop[i] > 0 ) {
+		px->r = qRed  ( ctable[i] );
+		px->g = qGreen( ctable[i] );
+		px->b = qBlue ( ctable[i] );
+		px->n = 0;
+		px->use = pop[i];
+		if ( pop[i] > maxpop ) {	// select most popular entry
+		    maxpop = pop[i];
+		    maxpix = j;
+		}
+		px->index = i;
+		px->mindist = 1000000;
+		px++;
+		j++;
+	    }
+	}
+	pixarr_sorted[0] = pixarr[maxpix];
+	pixarr[maxpix].use = 0;
+
+	for ( i=1; i< (uint) ncols; i++ ) {		// sort pixels
+	    int minpix = -1, mindist = -1;
+	    px = &pixarr_sorted[i-1];
+	    int r = px->r;
+	    int g = px->g;
+	    int b = px->b;
+	    int dist;
+	    if ( (i & 1) || i<10 ) {		// sort on max distance
+		for ( int j=0; j<ncols; j++ ) {
+		    px = &pixarr[j];
+		    if ( px->use ) {
+			dist = (px->r - r)*(px->r - r) +
+			       (px->g - g)*(px->g - g) +
+			       (px->b - b)*(px->b - b);
+			if ( px->mindist > dist )
+			    px->mindist = dist;
+			if ( px->mindist > mindist ) {
+			    mindist = px->mindist;
+			    minpix = j;
+			}
+		    }
+		}
+	    } else {				// sort on max popularity
+		for ( int j=0; j<ncols; j++ ) {
+		    px = &pixarr[j];
+		    if ( px->use ) {
+			dist = (px->r - r)*(px->r - r) +
+			       (px->g - g)*(px->g - g) +
+			       (px->b - b)*(px->b - b);
+			if ( px->mindist > dist )
+			    px->mindist = dist;
+			if ( px->use > mindist ) {
+			    mindist = px->use;
+			    minpix = j;
+			}
+		    }
+		}
+	    }
+	    pixarr_sorted[i] = pixarr[minpix];
+	    pixarr[minpix].use = 0;
+	}
+
+	uint pix[256];				// pixel translation table
+	px = &pixarr_sorted[0];
+	for ( i=0; i< (uint) ncols; i++ ) {		// allocate colors
+	    QColor c( px->r, px->g, px->b );
+	    pix[px->index] = c.pixel(x11Screen());
+	    px++;
+	}
+
+	p = newbits;
+	for ( i=0; i< (uint) nbytes; i++ ) {		// translate pixels
+	    *p = pix[*p];
+	    p++;
+	}
+    }
+
+    if ( !xi ) {				// X image not created
+#ifdef QT_MITSHM_CONVERSIONS
+        xi = qt_XShmCreateImage( dpy, visual, dd, ZPixmap, 0, 0, w, h, 32, 0, &shminfo );
+        if( xi != NULL )
+            mitshm_ximage = true;
+        else
+#endif
+	    xi = XCreateImage( dpy, visual, dd, ZPixmap, 0, 0, w, h, 32, 0 );
+	if ( xi->bits_per_pixel == 16 ) {	// convert 8 bpp ==> 16 bpp
+	    ushort *p2;
+	    int	    p2inc = xi->bytes_per_line/sizeof(ushort);
+	    ushort *newerbits = (ushort *)malloc( xi->bytes_per_line * h );
+            newbits_size = xi->bytes_per_line * h;
+	    Q_CHECK_PTR( newerbits );
+	    if ( !newerbits )				// no memory
+		return FALSE;
+	    uchar* p = newbits;
+	    for ( uint y=0; y<h; y++ ) {		// OOPS: Do right byte order!!
+		p2 = newerbits + p2inc*y;
+		for ( uint x=0; x<w; x++ )
+		    *p2++ = *p++;
+	    }
+	    free( newbits );
+	    newbits = (uchar *)newerbits;
+	} else if ( xi->bits_per_pixel != 8 ) {
+#if defined(QT_CHECK_RANGE)
+	    qWarning( "QPixmap::convertFromImage: Display not supported "
+		      "(bpp=%d)", xi->bits_per_pixel );
+#endif
+	}
+#ifdef QT_MITSHM_CONVERSIONS
+        if( newbits_size > 0 && mitshm_ximage ) { // need to copy to shared memory
+            memcpy( xi->data, newbits, newbits_size );
+            free( newbits );
+            newbits = (uchar*)xi->data;
+        }
+        else
+#endif
+            xi->data = (char *)newbits;
+    }
+
+    if ( hd && (width() != (int)w || height() != (int)h || this->depth() != dd) ) {
+
+#ifndef QT_NO_XFTFREETYPE
+	if (rendhd) {
+	    XftDrawDestroy( (XftDraw *) rendhd );
+	    rendhd = 0;
+	}
+#endif // QT_NO_XFTFREETYPE
+
+	XFreePixmap( dpy, hd );			// don't reuse old pixmap
+	hd = 0;
+    }
+    if ( !hd ) {					// create new pixmap
+	hd = (HANDLE)XCreatePixmap( x11Display(),
+				    RootWindow(x11Display(), x11Screen() ),
+				    w, h, dd );
+
+#ifndef QT_NO_XFTFREETYPE
+	if ( qt_has_xft ) {
+	    if ( data->d == 1 ) {
+		rendhd = (HANDLE) XftDrawCreateBitmap( x11Display (), hd );
+	    } else {
+		rendhd = (HANDLE) XftDrawCreate( x11Display (), hd,
+						 (Visual *) x11Visual(), x11Colormap() );
+	    }
+	}
+#endif // QT_NO_XFTFREETYPE
+
+    }
+
+#ifdef QT_MITSHM_CONVERSIONS
+    if( mitshm_ximage )
+        XShmPutImage( dpy, hd, qt_xget_readonly_gc( x11Screen(), FALSE ),
+                      xi, 0, 0, 0, 0, w, h, False );
+    else
+#endif
+        XPutImage( dpy, hd, qt_xget_readonly_gc( x11Screen(), FALSE  ),
+                   xi, 0, 0, 0, 0, w, h );
+
+    data->w = w;
+    data->h = h;
+    data->d = dd;
+
+    XImage* axi = NULL;
+#ifdef QT_MITSHM_CONVERSIONS
+    bool mitshm_aximage = false;
+    XShmSegmentInfo ashminfo;
+#endif
+    if ( image.hasAlphaBuffer() ) {
+	QBitmap m;
+	m = image.createAlphaMask( conversion_flags );
+	setMask( m );
+
+#ifndef QT_NO_XFTFREETYPE
+	// does this image have an alphamap (and not just a 1bpp mask)?
+	bool alphamap = image.depth() == 32;
+	if (image.depth() == 8) {
+	    const QRgb * const rgb = image.colorTable();
+	    for (int i = 0, count = image.numColors(); i < count; ++i) {
+		const int alpha = qAlpha(rgb[i]);
+		if (alpha != 0 && alpha != 0xff) {
+		    alphamap = true;
+		    break;
+		}
+	    }
+	}
+
+	if (qt_use_xrender && qt_has_xft && alphamap) {
+	    data->alphapm = new QPixmap; // create a null pixmap
+
+	    // setup pixmap data
+	    data->alphapm->data->w = w;
+	    data->alphapm->data->h = h;
+	    data->alphapm->data->d = 8;
+
+	    // create 8bpp pixmap and render picture
+	    data->alphapm->hd =
+		XCreatePixmap(x11Display(), RootWindow(x11Display(), x11Screen()),
+			      w, h, 8);
+
+	    data->alphapm->rendhd =
+		(HANDLE) XftDrawCreateAlpha( x11Display(), data->alphapm->hd, 8 );
+
+#ifdef QT_MITSHM_CONVERSIONS
+            axi = qt_XShmCreateImage( x11Display(), (Visual*)x11Visual(),
+                                      8, ZPixmap, 0, 0, w, h, 8, 0, &ashminfo );
+            if( axi != NULL )
+                mitshm_aximage = true;
+            else
+#endif
+	        axi = XCreateImage(x11Display(), (Visual *) x11Visual(),
+				   8, ZPixmap, 0, 0, w, h, 8, 0);
+
+	    if (axi) {
+                if( axi->data==NULL ) {
+		    // the data is deleted by qSafeXDestroyImage
+		    axi->data = (char *) malloc(h * axi->bytes_per_line);
+		    Q_CHECK_PTR( axi->data );
+                }
+		char *aptr = axi->data;
+
+		if (image.depth() == 32) {
+		    const int *iptr = (const int *) image.bits();
+		    int max = w * h;
+		    while (max--)
+			*aptr++ = *iptr++ >> 24; // squirt
+		} else if (image.depth() == 8) {
+		    const QRgb * const rgb = image.colorTable();
+		    for (uint y = 0; y < h; ++y) {
+			const uchar *iptr = image.scanLine(y);
+			for (uint x = 0; x < w; ++x)
+			    *aptr++ = qAlpha(rgb[*iptr++]);
+		    }
+		}
+
+		GC gc = XCreateGC(x11Display(), data->alphapm->hd, 0, 0);
+#ifdef QT_MITSHM_CONVERSIONS
+                if( mitshm_aximage )
+                    XShmPutImage( dpy, data->alphapm->hd, gc, axi, 0, 0, 0, 0, w, h, False );
+                else
+#endif
+		    XPutImage(dpy, data->alphapm->hd, gc, axi, 0, 0, 0, 0, w, h);
+		XFreeGC(x11Display(), gc);
+	    }
+	}
+#endif // QT_NO_XFTFREETYPE
+    }
+
+#ifdef QT_MITSHM_CONVERSIONS
+    if( mitshm_ximage || mitshm_aximage )
+        XSync( x11Display(), False ); // wait until processed
+#endif
+
+    if ( data->optim != BestOptim ) {		// throw away image
+#ifdef QT_MITSHM_CONVERSIONS
+        if( mitshm_ximage )
+            qt_XShmDestroyImage( xi, &shminfo );
+        else
+#endif
+	qSafeXDestroyImage( xi );
+	data->ximage = 0;
+    } else {					// keep ximage that we created
+#ifdef QT_MITSHM_CONVERSIONS
+        if( mitshm_ximage ) { // copy the XImage?
+            qt_XShmDestroyImage( xi, &shminfo );
+            xi = 0;
+        }
+#endif
+	data->ximage = xi;
+    }
+    if( axi ) {
+#ifdef QT_MITSHM_CONVERSIONS
+        if( mitshm_aximage )
+            qt_XShmDestroyImage( axi, &ashminfo );
+        else
+#endif
+        qSafeXDestroyImage(axi);
+    }
+    return TRUE;
+}
+
+
+/*!
+    Grabs the contents of the window \a window and makes a pixmap out
+    of it. Returns the pixmap.
+
+    The arguments \a (x, y) specify the offset in the window, whereas
+    \a (w, h) specify the width and height of the area to be copied.
+
+    If \a w is negative, the function copies everything to the right
+    border of the window. If \a h is negative, the function copies
+    everything to the bottom of the window.
+
+    Note that grabWindow() grabs pixels from the screen, not from the
+    window. If there is another window partially or entirely over the
+    one you grab, you get pixels from the overlying window, too.
+
+    Note also that the mouse cursor is generally not grabbed.
+
+    The reason we use a window identifier and not a QWidget is to
+    enable grabbing of windows that are not part of the application,
+    window system frames, and so on.
+
+    \warning Grabbing an area outside the screen is not safe in
+    general. This depends on the underlying window system.
+
+    \warning X11 only: If \a window is not the same depth as the root
+    window and another window partially or entirely obscures the one
+    you grab, you will \e not get pixels from the overlying window.
+    The contests of the obscured areas in the pixmap are undefined and
+    uninitialized.
+
+    \sa grabWidget()
+*/
+
+QPixmap QPixmap::grabWindow( WId window, int x, int y, int w, int h )
+{
+    if ( w == 0 || h == 0 )
+	return QPixmap();
+
+    Display *dpy = x11AppDisplay();
+    XWindowAttributes window_attr;
+    if ( ! XGetWindowAttributes( dpy, window, &window_attr ) )
+	return QPixmap();
+
+    if ( w < 0 )
+	w = window_attr.width - x;
+    if ( h < 0 )
+	h = window_attr.height - y;
+
+    // determine the screen
+    int scr;
+    for ( scr = 0; scr < ScreenCount( dpy ); ++scr ) {
+	if ( window_attr.root == RootWindow( dpy, scr ) )	// found it
+	    break;
+    }
+    if ( scr >= ScreenCount( dpy ) )		// sanity check
+	return QPixmap();
+
+
+    // get the depth of the root window
+    XWindowAttributes root_attr;
+    if ( ! XGetWindowAttributes( dpy, window_attr.root, &root_attr ) )
+        return QPixmap();
+
+    if ( window_attr.depth == root_attr.depth ) {
+        // if the depth of the specified window and the root window are the
+        // same, grab pixels from the root window (so that we get the any
+        // overlapping windows and window manager frames)
+
+        // map x and y to the root window
+        WId unused;
+        if ( ! XTranslateCoordinates( dpy, window, window_attr.root, x, y,
+                                      &x, &y, &unused ) )
+            return QPixmap();
+
+       window = window_attr.root;
+    }
+
+    QPixmap pm( w, h );
+    pm.data->uninit = FALSE;
+    pm.x11SetScreen( scr );
+
+    GC gc = qt_xget_temp_gc( scr, FALSE );
+    XSetSubwindowMode( dpy, gc, IncludeInferiors );
+    XCopyArea( dpy, window, pm.handle(), gc, x, y, w, h, 0, 0 );
+    XSetSubwindowMode( dpy, gc, ClipByChildren );
+
+    return pm;
+}
+
+/*!
+    Returns a copy of the pixmap that is transformed using \a matrix.
+    The original pixmap is not changed.
+
+    The transformation \a matrix is internally adjusted to compensate
+    for unwanted translation, i.e. xForm() returns the smallest image
+    that contains all the transformed points of the original image.
+
+    This function is slow because it involves transformation to a
+    QImage, non-trivial computations and a transformation back to a
+    QPixmap.
+
+    \sa trueMatrix(), QWMatrix, QPainter::setWorldMatrix() QImage::xForm()
+*/
+
+QPixmap QPixmap::xForm( const QWMatrix &matrix ) const
+{
+    int	   w = 0;
+    int	   h = 0;				// size of target pixmap
+    int	   ws, hs;				// size of source pixmap
+    uchar *dptr;				// data in target pixmap
+    int	   dbpl, dbytes;			// bytes per line/bytes total
+    uchar *sptr;				// data in original pixmap
+    int	   sbpl;				// bytes per line in original
+    int	   bpp;					// bits per pixel
+    bool   depth1 = depth() == 1;
+    Display *dpy = x11Display();
+
+    if ( isNull() )				// this is a null pixmap
+	return copy();
+
+    ws = width();
+    hs = height();
+
+    QWMatrix mat( matrix.m11(), matrix.m12(), matrix.m21(), matrix.m22(), 0., 0. );
+
+    if ( matrix.m12() == 0.0F && matrix.m21() == 0.0F ) {
+	if ( matrix.m11() == 1.0F && matrix.m22() == 1.0F )
+	    return *this;			// identity matrix
+	h = qRound( matrix.m22()*hs );
+	w = qRound( matrix.m11()*ws );
+	h = QABS( h );
+	w = QABS( w );
+    } else {					// rotation or shearing
+	QPointArray a( QRect(0,0,ws+1,hs+1) );
+	a = mat.map( a );
+	QRect r = a.boundingRect().normalize();
+	w = r.width()-1;
+	h = r.height()-1;
+    }
+
+    mat = trueMatrix( mat, ws, hs ); // true matrix
+
+
+    bool invertible;
+    mat = mat.invert( &invertible );		// invert matrix
+
+    if ( h == 0 || w == 0 || !invertible ) {	// error, return null pixmap
+	QPixmap pm;
+	pm.data->bitmap = data->bitmap;
+	return pm;
+    }
+
+#if defined(QT_MITSHM_XFORM)
+    static bool try_once = TRUE;
+    if (try_once) {
+	try_once = FALSE;
+	if ( !xshminit )
+	    qt_create_mitshm_buffer( this, 800, 600 );
+    }
+
+    bool use_mitshm = xshmimg && !depth1 &&
+    xshmimg->width >= w && xshmimg->height >= h;
+#endif
+    XImage *xi = (XImage*)data->ximage;		// any cached ximage?
+    if ( !xi )
+	xi = XGetImage( x11Display(), handle(), 0, 0, ws, hs, AllPlanes,
+			depth1 ? XYPixmap : ZPixmap );
+
+    if ( !xi ) {				// error, return null pixmap
+	QPixmap pm;
+	pm.data->bitmap = data->bitmap;
+	pm.data->alphapm = data->alphapm;
+	return pm;
+    }
+
+    sbpl = xi->bytes_per_line;
+    sptr = (uchar *)xi->data;
+    bpp	 = xi->bits_per_pixel;
+
+    if ( depth1 )
+	dbpl = (w+7)/8;
+    else
+	dbpl = ((w*bpp+31)/32)*4;
+    dbytes = dbpl*h;
+
+#if defined(QT_MITSHM_XFORM)
+    if ( use_mitshm ) {
+	dptr = (uchar *)xshmimg->data;
+	uchar fillbyte = bpp == 8 ? white.pixel() : 0xff;
+	for ( int y=0; y<h; y++ )
+	    memset( dptr + y*xshmimg->bytes_per_line, fillbyte, dbpl );
+    } else {
+#endif
+	dptr = (uchar *)malloc( dbytes );	// create buffer for bits
+	Q_CHECK_PTR( dptr );
+	if ( depth1 )				// fill with zeros
+	    memset( dptr, 0, dbytes );
+	else if ( bpp == 8 )			// fill with background color
+	    memset( dptr, Qt::white.pixel( x11Screen() ), dbytes );
+	else
+	    memset( dptr, 0xff, dbytes );
+#if defined(QT_MITSHM_XFORM)
+    }
+#endif
+
+    // #define QT_DEBUG_XIMAGE
+#if defined(QT_DEBUG_XIMAGE)
+    qDebug( "----IMAGE--INFO--------------" );
+    qDebug( "width............. %d", xi->width );
+    qDebug( "height............ %d", xi->height );
+    qDebug( "xoffset........... %d", xi->xoffset );
+    qDebug( "format............ %d", xi->format );
+    qDebug( "byte order........ %d", xi->byte_order );
+    qDebug( "bitmap unit....... %d", xi->bitmap_unit );
+    qDebug( "bitmap bit order.. %d", xi->bitmap_bit_order );
+    qDebug( "depth............. %d", xi->depth );
+    qDebug( "bytes per line.... %d", xi->bytes_per_line );
+    qDebug( "bits per pixel.... %d", xi->bits_per_pixel );
+#endif
+
+    int type;
+    if ( xi->bitmap_bit_order == MSBFirst )
+	type = QT_XFORM_TYPE_MSBFIRST;
+    else
+	type = QT_XFORM_TYPE_LSBFIRST;
+    int	xbpl, p_inc;
+    if ( depth1 ) {
+	xbpl  = (w+7)/8;
+	p_inc = dbpl - xbpl;
+    } else {
+	xbpl  = (w*bpp)/8;
+	p_inc = dbpl - xbpl;
+#if defined(QT_MITSHM_XFORM)
+	if ( use_mitshm )
+	    p_inc = xshmimg->bytes_per_line - xbpl;
+#endif
+    }
+
+    if ( !qt_xForm_helper( mat, xi->xoffset, type, bpp, dptr, xbpl, p_inc, h, sptr, sbpl, ws, hs ) ){
+#if defined(QT_CHECK_RANGE)
+	qWarning( "QPixmap::xForm: display not supported (bpp=%d)",bpp);
+#endif
+	QPixmap pm;
+	return pm;
+    }
+
+    if ( data->optim == NoOptim ) {		// throw away ximage
+	qSafeXDestroyImage( xi );
+	data->ximage = 0;
+    } else {					// keep ximage that we fetched
+	data->ximage = xi;
+    }
+
+    if ( depth1 ) {				// mono bitmap
+	QPixmap pm( w, h, dptr, QImage::systemBitOrder() != QImage::BigEndian );
+	pm.data->bitmap = data->bitmap;
+	free( dptr );
+	if ( data->mask ) {
+	    if ( data->selfmask )		// pixmap == mask
+		pm.setMask( *((QBitmap*)(&pm)) );
+	    else
+		pm.setMask( data->mask->xForm(matrix) );
+	}
+	return pm;
+    } else {					// color pixmap
+	GC gc = qt_xget_readonly_gc( x11Screen(), FALSE );
+	QPixmap pm( w, h );
+	pm.data->uninit = FALSE;
+	pm.x11SetScreen( x11Screen() );
+#if defined(QT_MITSHM_XFORM)
+	if ( use_mitshm ) {
+	    XCopyArea( dpy, xshmpm, pm.handle(), gc, 0, 0, w, h, 0, 0 );
+	} else {
+#endif
+	    xi = XCreateImage( dpy, (Visual *)x11Visual(), x11Depth(),
+			       ZPixmap, 0, (char *)dptr, w, h, 32, 0 );
+	    XPutImage( dpy, pm.handle(), gc, xi, 0, 0, 0, 0, w, h);
+	    qSafeXDestroyImage( xi );
+#if defined(QT_MITSHM_XFORM)
+	}
+#endif
+
+	if ( data->mask ) // xform mask, too
+	    pm.setMask( data->mask->xForm(matrix) );
+
+#ifndef QT_NO_XFTFREETYPE
+	if ( qt_use_xrender && qt_has_xft && data->alphapm ) { // xform the alpha channel
+	    XImage *axi = 0;
+	    if ((axi = XGetImage(x11Display(), data->alphapm->handle(),
+				 0, 0, ws, hs, AllPlanes, ZPixmap))) {
+		sbpl = axi->bytes_per_line;
+		sptr = (uchar *) axi->data;
+		bpp  = axi->bits_per_pixel;
+		dbytes = dbpl * h;
+		dptr = (uchar *) malloc(dbytes);
+		Q_CHECK_PTR( dptr );
+		memset(dptr, 0, dbytes);
+		if ( axi->bitmap_bit_order == MSBFirst )
+		    type = QT_XFORM_TYPE_MSBFIRST;
+		else
+		    type = QT_XFORM_TYPE_LSBFIRST;
+
+		if (qt_xForm_helper( mat, axi->xoffset, type, bpp, dptr, w,
+				     0, h, sptr, sbpl, ws, hs )) {
+		    delete pm.data->alphapm;
+		    pm.data->alphapm = new QPixmap; // create a null pixmap
+
+		    // setup pixmap data
+		    pm.data->alphapm->data->w = w;
+		    pm.data->alphapm->data->h = h;
+		    pm.data->alphapm->data->d = 8;
+
+		    // create 8bpp pixmap and render picture
+		    pm.data->alphapm->hd =
+			XCreatePixmap(x11Display(),
+				      RootWindow(x11Display(), x11Screen()),
+				      w, h, 8);
+
+		    pm.data->alphapm->rendhd =
+			(HANDLE) XftDrawCreateAlpha( x11Display(),
+						     pm.data->alphapm->hd, 8 );
+
+		    XImage *axi2 = XCreateImage(x11Display(), (Visual *) x11Visual(),
+						8, ZPixmap, 0, (char *)dptr, w, h, 8, 0);
+
+		    if (axi2) {
+			// the data is deleted by qSafeXDestroyImage
+			GC gc = XCreateGC(x11Display(), pm.data->alphapm->hd, 0, 0);
+			XPutImage(dpy, pm.data->alphapm->hd, gc, axi2, 0, 0, 0, 0, w, h);
+			XFreeGC(x11Display(), gc);
+			qSafeXDestroyImage(axi2);
+		    }
+		}
+		qSafeXDestroyImage(axi);
+	    }
+	}
+#endif // QT_NO_XFTFREETYPE
+
+	return pm;
+    }
+}
+
+
+/*!
+  \internal
+*/
+int QPixmap::x11SetDefaultScreen( int screen )
+{
+    int old = defaultScreen;
+    defaultScreen = screen;
+    return old;
+}
+
+/*!
+  \internal
+*/
+void QPixmap::x11SetScreen( int screen )
+{
+    if ( screen < 0 )
+	screen = x11AppScreen();
+
+    if ( screen == x11Screen() )
+	return; // nothing to do
+
+    if ( isNull() ) {
+	QPaintDeviceX11Data* xd = getX11Data( TRUE );
+	xd->x_screen = screen;
+	xd->x_depth = QPaintDevice::x11AppDepth( screen );
+	xd->x_cells = QPaintDevice::x11AppCells( screen );
+	xd->x_colormap = QPaintDevice::x11AppColormap( screen );
+	xd->x_defcolormap = QPaintDevice::x11AppDefaultColormap( screen );
+	xd->x_visual = QPaintDevice::x11AppVisual( screen );
+	xd->x_defvisual = QPaintDevice::x11AppDefaultVisual( screen );
+    	setX11Data( xd );
+	return;
+    }
+#if 0
+    qDebug("QPixmap::x11SetScreen for %p from %d to %d. Size is %d/%d", data, x11Screen(), screen, width(), height() );
+#endif
+
+    QImage img = convertToImage();
+    resize(0,0);
+    QPaintDeviceX11Data* xd = getX11Data( TRUE );
+    xd->x_screen = screen;
+    xd->x_depth = QPaintDevice::x11AppDepth( screen );
+    xd->x_cells = QPaintDevice::x11AppCells( screen );
+    xd->x_colormap = QPaintDevice::x11AppColormap( screen );
+    xd->x_defcolormap = QPaintDevice::x11AppDefaultColormap( screen );
+    xd->x_visual = QPaintDevice::x11AppVisual( screen );
+    xd->x_defvisual = QPaintDevice::x11AppDefaultVisual( screen );
+    setX11Data( xd );
+    convertFromImage( img );
+}
+
+/*!
+    Returns TRUE this pixmap has an alpha channel or a mask.
+
+    \sa hasAlphaChannel() mask()
+*/
+bool QPixmap::hasAlpha() const
+{
+    return data->alphapm || data->mask;
+}
+
+/*!
+    Returns TRUE if the pixmap has an alpha channel; otherwise it
+    returns FALSE.
+
+    NOTE: If the pixmap has a mask but not alpha channel, this
+    function returns FALSE.
+
+    \sa hasAlpha() mask()
+*/
+bool QPixmap::hasAlphaChannel() const
+{
+    return data->alphapm != 0;
+}
+
+/*!
+    \relates QPixmap
+
+    Copies a block of pixels from \a src to \a dst.  The alpha channel
+    and mask data (if any) is also copied from \a src.  NOTE: \a src
+    is \e not alpha blended or masked when copied to \a dst.  Use
+    bitBlt() or QPainter::drawPixmap() to perform alpha blending or
+    masked drawing.
+
+    \a sx, \a sy is the top-left pixel in \a src (0, 0 by default), \a
+    dx, \a dy is the top-left position in \a dst and \a sw, \sh is the
+    size of the copied block (all of \a src by default).
+
+    If \a src, \a dst, \a sw or \a sh is 0 (zero), copyBlt() does
+    nothing.  If \a sw or \a sh is negative, copyBlt() copies starting
+    at \a sx (and respectively, \a sy) and ending at the right edge
+    (and respectively, the bottom edge) of \a src.
+
+    copyBlt() does nothing if \a src and \a dst have different depths.
+*/
+Q_EXPORT void copyBlt( QPixmap *dst, int dx, int dy,
+		       const QPixmap *src, int sx, int sy, int sw, int sh )
+{
+    if ( ! dst || ! src || sw == 0 || sh == 0 || dst->depth() != src->depth() ) {
+#ifdef QT_CHECK_NULL
+	Q_ASSERT( dst != 0 );
+	Q_ASSERT( src != 0 );
+#endif
+	return;
+    }
+
+    // copy pixel data
+    bitBlt( dst, dx, dy, src, sx, sy, sw, sh, Qt::CopyROP, TRUE );
+
+    // copy mask data
+    if ( src->data->mask ) {
+	if ( ! dst->data->mask ) {
+	    dst->data->mask = new QBitmap( dst->width(), dst->height() );
+
+	    // new masks are fully opaque by default
+	    dst->data->mask->fill( Qt::color1 );
+	}
+
+	bitBlt( dst->data->mask, dx, dy,
+		src->data->mask, sx, sy, sw, sh, Qt::CopyROP, TRUE );
+    }
+
+#ifndef QT_NO_XFTFREETYPE
+    // copy alpha data
+    extern bool qt_use_xrender; // from qapplication_x11.cpp
+    if ( ! qt_use_xrender || ! src->data->alphapm )
+	return;
+
+    if ( sw < 0 )
+	sw = src->width() - sx;
+    else
+	sw = QMIN( src->width()-sx, sw );
+    sw = QMIN( dst->width()-dx, sw );
+
+    if ( sh < 0 )
+	sh = src->height() - sy ;
+    else
+	sh = QMIN( src->height()-sy, sh );
+    sh = QMIN( dst->height()-dy, sh );
+
+    if ( sw <= 0 || sh <= 0 )
+	return;
+
+    // create an alpha pixmap for dst if it doesn't exist
+    bool do_init = FALSE;
+    if ( ! dst->data->alphapm ) {
+	dst->data->alphapm = new QPixmap;
+
+	// setup pixmap d
+	dst->data->alphapm->data->w = dst->width();
+	dst->data->alphapm->data->h = dst->height();
+	dst->data->alphapm->data->d = 8;
+
+	// create 8bpp pixmap and render picture
+	dst->data->alphapm->hd =
+	    XCreatePixmap(dst->x11Display(),
+			  RootWindow(dst->x11Display(), dst->x11Screen()),
+			  dst->width(), dst->height(), 8);
+
+	// new alpha pixmaps should be fully opaque by default
+	do_init = TRUE;
+
+	dst->data->alphapm->rendhd =
+	    (Qt::HANDLE) XftDrawCreateAlpha( dst->x11Display(),
+					     dst->data->alphapm->hd, 8 );
+    }
+
+    GC gc = XCreateGC(dst->x11Display(), dst->data->alphapm->hd, 0, 0);
+
+    if ( do_init ) {
+	// the alphapm was just created, make it fully opaque
+	XSetForeground( dst->x11Display(), gc, 255 );
+	XSetBackground( dst->x11Display(), gc, 255 );
+	XFillRectangle( dst->x11Display(), dst->data->alphapm->hd, gc,
+			0, 0, dst->data->alphapm->data->w,
+			dst->data->alphapm->data->h );
+    }
+
+    XCopyArea(dst->x11Display(), src->data->alphapm->hd, dst->data->alphapm->hd, gc,
+	      sx, sy, sw, sh, dx, dy);
+    XFreeGC(dst->x11Display(), gc);
+#endif // QT_NO_XFTFREETYPE
+}
diff -Nru qt-x11-free-3.3.3.orig/src/tools/qvaluelist.h qt-x11-free-3.3.3/src/tools/qvaluelist.h
--- qt-x11-free-3.3.3.orig/src/tools/qvaluelist.h	2004-08-22 13:20:56.017222236 +0200
+++ qt-x11-free-3.3.3/src/tools/qvaluelist.h	2004-08-22 13:23:26.717718888 +0200
@@ -636,13 +636,11 @@
     l.clear();
     Q_UINT32 c;
     s >> c;
-    for( Q_UINT32 i = 0; i < c; ++i )
+    for( Q_UINT32 i = 0; i < c && !s.atEnd(); ++i )
     {
 	T t;
 	s >> t;
 	l.append( t );
-	if ( s.atEnd() )
-	    break;
     }
     return s;
 }
diff -Nru qt-x11-free-3.3.3.orig/src/widgets/qpopupmenu.cpp qt-x11-free-3.3.3/src/widgets/qpopupmenu.cpp
--- qt-x11-free-3.3.3.orig/src/widgets/qpopupmenu.cpp	2004-08-22 13:20:57.521937342 +0200
+++ qt-x11-free-3.3.3/src/widgets/qpopupmenu.cpp	2004-08-22 13:24:07.413031399 +0200
@@ -2529,7 +2529,7 @@
     constPolish();
     QPopupMenu* that = (QPopupMenu*) this;
     //We do not need a resize here, just the sizeHint..
-    return that->updateSize(FALSE, FALSE).expandedTo( QApplication::globalStrut() );
+    return that->updateSize(FALSE).expandedTo( QApplication::globalStrut() );
 }
 
 
diff -Nru qt-x11-free-3.3.3.orig/src/widgets/qpopupmenu.cpp~ qt-x11-free-3.3.3/src/widgets/qpopupmenu.cpp~
--- qt-x11-free-3.3.3.orig/src/widgets/qpopupmenu.cpp~	1970-01-01 01:00:00.000000000 +0100
+++ qt-x11-free-3.3.3/src/widgets/qpopupmenu.cpp~	2004-08-05 16:42:21.000000000 +0200
@@ -0,0 +1,2810 @@
+/****************************************************************************
+** $Id: qt/qpopupmenu.cpp   3.3.3   edited Jul 16 17:02 $
+**
+** Implementation of QPopupMenu class
+**
+** Created : 941128
+**
+** Copyright (C) 1992-2002 Trolltech AS.  All rights reserved.
+**
+** This file is part of the widgets module of the Qt GUI Toolkit.
+**
+** This file may be distributed under the terms of the Q Public License
+** as defined by Trolltech AS of Norway and appearing in the file
+** LICENSE.QPL included in the packaging of this file.
+**
+** This file may be distributed and/or modified under the terms of the
+** GNU General Public License version 2 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.
+**
+** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
+** licenses may use this file in accordance with the Qt Commercial License
+** Agreement provided with the Software.
+**
+** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+**
+** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
+**   information about Qt Commercial License Agreements.
+** See http://www.trolltech.com/qpl/ for QPL licensing information.
+** See http://www.trolltech.com/gpl/ for GPL licensing information.
+**
+** Contact info@trolltech.com if any conditions of this licensing are
+** not clear to you.
+**
+**********************************************************************/
+
+#include "qpopupmenu.h"
+#ifndef QT_NO_POPUPMENU
+#include "qmenubar.h"
+#include "qaccel.h"
+#include "qpainter.h"
+#include "qdrawutil.h"
+#include "qapplication.h"
+#include "qpixmap.h"
+#include "qpixmapcache.h"
+#include "qtimer.h"
+#include "qwhatsthis.h"
+#include "qobjectlist.h"
+#include "qguardedptr.h"
+#include "qeffects_p.h"
+#include "qcursor.h"
+#include "qstyle.h"
+#include "qtimer.h"
+#include "qdatetime.h"
+#if defined(QT_ACCESSIBILITY_SUPPORT)
+#include "qaccessible.h"
+#endif
+
+//#define ANIMATED_POPUP
+//#define BLEND_POPUP
+
+// Motif style parameters
+
+static const int motifArrowHMargin	= 6;	// arrow horizontal margin
+static const int motifArrowVMargin	= 2;	// arrow vertical margin
+
+
+/*
+
++-----------------------------
+|      PopupFrame
+|   +-------------------------
+|   |	   ItemFrame
+|   |	+---------------------
+|   |	|
+|   |	|			   \
+|   |	|   ^	T E X T	  ^	    | ItemVMargin
+|   |	|   |		  |	   /
+|   |	      ItemHMargin
+|
+
+*/
+
+#if 0
+# define DEBUG_SLOPPY_SUBMENU
+#endif
+
+// used for internal communication
+static QPopupMenu * syncMenu = 0;
+static int syncMenuId = 0;
+
+// Used to detect motion prior to mouse-release
+static int motion;
+
+// used to provide ONE single-shot timer
+static QTimer * singleSingleShot = 0;
+
+static bool supressAboutToShow = FALSE;
+
+static void cleanup()
+{
+    delete singleSingleShot;
+    singleSingleShot = 0;
+}
+
+static void popupSubMenuLater( int msec, QPopupMenu * receiver ) {
+    if ( !singleSingleShot ) {
+	singleSingleShot = new QTimer( qApp, "popup submenu timer" );
+	qAddPostRoutine( cleanup );
+    }
+
+    singleSingleShot->disconnect( SIGNAL(timeout()) );
+    QObject::connect( singleSingleShot, SIGNAL(timeout()),
+		      receiver, SLOT(subMenuTimer()) );
+    singleSingleShot->start( msec, TRUE );
+}
+
+static bool preventAnimation = FALSE;
+
+#ifndef QT_NO_WHATSTHIS
+extern void qWhatsThisBDH();
+static QMenuItem* whatsThisItem = 0;
+#endif
+
+/*!
+    \class QPopupMenu qpopupmenu.h
+    \brief The QPopupMenu class provides a popup menu widget.
+
+    \ingroup application
+    \ingroup basic
+    \mainclass
+
+    A popup menu widget is a selection menu. It can be either a
+    pull-down menu in a menu bar or a standalone context (popup) menu.
+    Pull-down menus are shown by the menu bar when the user clicks on
+    the respective item or presses the specified shortcut key. Use
+    QMenuBar::insertItem() to insert a popup menu into a menu bar.
+    Show a context menu either asynchronously with popup() or
+    synchronously with exec().
+
+    Technically, a popup menu consists of a list of menu items. You
+    add items with insertItem(). An item is either a string, a pixmap
+    or a custom item that provides its own drawing function (see
+    QCustomMenuItem). In addition, items can have an optional icon
+    drawn on the very left side and an accelerator key such as
+    "Ctrl+X".
+
+    There are three kinds of menu items: separators, menu items that
+    perform an action and menu items that show a submenu. Separators
+    are inserted with insertSeparator(). For submenus, you pass a
+    pointer to a QPopupMenu in your call to insertItem(). All other
+    items are considered action items.
+
+    When inserting action items you usually specify a receiver and a
+    slot. The receiver will be notifed whenever the item is selected.
+    In addition, QPopupMenu provides two signals, activated() and
+    highlighted(), which signal the identifier of the respective menu
+    item. It is sometimes practical to connect several items to one
+    slot. To distinguish between them, specify a slot that takes an
+    integer argument and use setItemParameter() to associate a unique
+    value with each item.
+
+    You clear a popup menu with clear() and remove single items with
+    removeItem() or removeItemAt().
+
+    A popup menu can display check marks for certain items when
+    enabled with setCheckable(TRUE). You check or uncheck items with
+    setItemChecked().
+
+    Items are either enabled or disabled. You toggle their state with
+    setItemEnabled(). Just before a popup menu becomes visible, it
+    emits the aboutToShow() signal. You can use this signal to set the
+    correct enabled/disabled states of all menu items before the user
+    sees it. The corresponding aboutToHide() signal is emitted when
+    the menu hides again.
+
+    You can provide What's This? help for single menu items with
+    setWhatsThis(). See QWhatsThis for general information about this
+    kind of lightweight online help.
+
+    For ultimate flexibility, you can also add entire widgets as items
+    into a popup menu (for example, a color selector).
+
+    A QPopupMenu can also provide a tear-off menu. A tear-off menu is
+    a top-level window that contains a copy of the menu. This makes it
+    possible for the user to "tear off" frequently used menus and
+    position them in a convenient place on the screen. If you want
+    that functionality for a certain menu, insert a tear-off handle
+    with insertTearOffHandle(). When using tear-off menus, bear in
+    mind that the concept isn't typically used on Microsoft Windows so
+    users may not be familiar with it. Consider using a QToolBar
+    instead. Tear-off menus cannot contain custom widgets; if the
+    original menu contains a custom widget item, this item is omitted.
+
+    \link menu-example.html menu/menu.cpp\endlink is an example of
+    QMenuBar and QPopupMenu use.
+
+    \important insertItem removeItem removeItemAt clear text pixmap iconSet insertSeparator changeItem whatsThis setWhatsThis accel setAccel setItemEnabled isItemEnabled setItemVisible isItemVisible setItemChecked isItemChecked connectItem disconnectItem setItemParameter itemParameter
+
+    <img src=qpopmenu-m.png> <img src=qpopmenu-w.png>
+
+    \sa QMenuBar
+    \link guibooks.html#fowler GUI Design Handbook: Menu, Drop-Down and
+    Pop-Up\endlink
+*/
+
+
+/*!
+    \fn void QPopupMenu::aboutToShow()
+
+    This signal is emitted just before the popup menu is displayed.
+    You can connect it to any slot that sets up the menu contents
+    (e.g. to ensure that the right items are enabled).
+
+    \sa aboutToHide(), setItemEnabled(), setItemChecked(), insertItem(), removeItem()
+*/
+
+/*!
+    \fn void QPopupMenu::aboutToHide()
+
+    This signal is emitted just before the popup menu is hidden after
+    it has been displayed.
+
+    \warning Do not open a widget in a slot connected to this signal.
+
+    \sa aboutToShow(), setItemEnabled(), setItemChecked(), insertItem(), removeItem()
+*/
+
+
+
+/*****************************************************************************
+  QPopupMenu member functions
+ *****************************************************************************/
+
+class QMenuDataData {
+    // attention: also defined in qmenudata.cpp
+public:
+    QMenuDataData();
+    QGuardedPtr<QWidget> aWidget;
+    int aInt;
+};
+
+class QPopupMenuPrivate {
+public:
+    struct Scroll {
+	enum { ScrollNone=0, ScrollUp=0x01, ScrollDown=0x02 };
+	uint scrollable : 2;
+	uint direction : 1;
+	int topScrollableIndex, scrollableSize;
+	QTime lastScroll;
+	QTimer *scrolltimer;
+    } scroll;
+    QSize calcSize;
+    QRegion mouseMoveBuffer;
+};
+
+static QPopupMenu* active_popup_menu = 0;
+
+/*!
+    Constructs a popup menu called \a name with parent \a parent.
+
+    Although a popup menu is always a top-level widget, if a parent is
+    passed the popup menu will be deleted when that parent is
+    destroyed (as with any other QObject).
+*/
+
+QPopupMenu::QPopupMenu( QWidget *parent, const char *name )
+    : QFrame( parent, name, WType_Popup  | WNoAutoErase )
+{
+    d = new QPopupMenuPrivate;
+    d->scroll.scrollableSize = d->scroll.topScrollableIndex = 0;
+    d->scroll.scrollable = QPopupMenuPrivate::Scroll::ScrollNone;
+    d->scroll.scrolltimer = 0;
+    isPopupMenu	  = TRUE;
+#ifndef QT_NO_ACCEL
+    autoaccel	  = 0;
+    accelDisabled = FALSE;
+#endif
+    popupActive	  = -1;
+    snapToMouse	  = TRUE;
+    tab = 0;
+    checkable = 0;
+    tornOff = 0;
+    pendingDelayedContentsChanges = 0;
+    pendingDelayedStateChanges = 0;
+    maxPMWidth = 0;
+
+    tab = 0;
+    ncols = 1;
+    setFrameStyle( QFrame::PopupPanel | QFrame::Raised );
+    setMouseTracking(style().styleHint(QStyle::SH_PopupMenu_MouseTracking, this));
+    style().polishPopupMenu( this );
+    setBackgroundMode( PaletteButton );
+    connectModalRecursionSafety = 0;
+
+    setFocusPolicy( StrongFocus );
+}
+
+/*!
+    Destroys the popup menu.
+*/
+
+QPopupMenu::~QPopupMenu()
+{
+    if ( syncMenu == this && qApp ) {
+	qApp->exit_loop();
+	syncMenu = 0;
+    }
+
+    if(d->scroll.scrolltimer)
+	delete d->scroll.scrolltimer;
+
+    if ( isVisible() ) {
+        parentMenu = 0;
+        hidePopups();
+    }
+
+    delete (QWidget*) QMenuData::d->aWidget;  // tear-off menu
+
+    preventAnimation = FALSE;
+    delete d;
+}
+
+
+/*!
+    Updates the item with identity \a id.
+*/
+void QPopupMenu::updateItem( int id )		// update popup menu item
+{
+    updateRow( indexOf(id) );
+}
+
+
+void QPopupMenu::setCheckable( bool enable )
+{
+    if ( isCheckable() != enable ) {
+	checkable = enable;
+	badSize = TRUE;
+	if ( QMenuData::d->aWidget )
+	    ( (QPopupMenu*)(QWidget*)QMenuData::d->aWidget)->setCheckable( enable );
+    }
+}
+
+/*!
+    \property QPopupMenu::checkable
+    \brief whether the display of check marks on menu items is enabled
+
+    When TRUE, the display of check marks on menu items is enabled.
+    Checking is always enabled when in Windows-style.
+
+    \sa QMenuData::setItemChecked()
+*/
+
+bool QPopupMenu::isCheckable() const
+{
+    return checkable;
+}
+
+void QPopupMenu::menuContentsChanged()
+{
+    // here the part that can't be delayed
+    QMenuData::menuContentsChanged();
+    badSize = TRUE;				// might change the size
+#if defined(Q_WS_MAC) && !defined(QMAC_QMENUBAR_NO_NATIVE)
+    mac_dirty_popup = 1;
+#endif
+    if( pendingDelayedContentsChanges )
+        return;
+    pendingDelayedContentsChanges = 1;
+    if( !pendingDelayedStateChanges ) // if the timer hasn't been started yet
+	QTimer::singleShot( 0, this, SLOT(performDelayedChanges()));
+}
+
+void QPopupMenu::performDelayedContentsChanged()
+{
+    pendingDelayedContentsChanges = 0;
+    // here the part the can be delayed
+#ifndef QT_NO_ACCEL
+    // if performDelayedStateChanged() will be called too,
+    // it will call updateAccel() too, no need to do it twice
+    if( !pendingDelayedStateChanges )
+        updateAccel( 0 );
+#endif
+    if ( isVisible() ) {
+	if ( tornOff )
+	    return;
+	updateSize(TRUE);
+	update();
+    }
+    QPopupMenu* p = (QPopupMenu*)(QWidget*)QMenuData::d->aWidget;
+    if ( p && p->isVisible() ) {
+	p->updateSize(TRUE);
+	p->update();
+    }
+#if defined(Q_WS_MAC) && !defined(QMAC_QMENUBAR_NO_NATIVE)
+    mac_dirty_popup = 1;
+#endif
+}
+
+
+void QPopupMenu::menuStateChanged()
+{
+    // here the part that can't be delayed
+    if( pendingDelayedStateChanges )
+	return;
+    pendingDelayedStateChanges = 1;
+    if( !pendingDelayedContentsChanges ) // if the timer hasn't been started yet
+	QTimer::singleShot( 0, this, SLOT(performDelayedChanges()));
+}
+
+void QPopupMenu::performDelayedStateChanged()
+{
+    pendingDelayedStateChanges = 0;
+    // here the part that can be delayed
+#ifndef QT_NO_ACCEL
+    updateAccel( 0 ); // ### when we have a good solution for the accel vs. focus widget problem, remove that. That is only a workaround
+    // if you remove this, see performDelayedContentsChanged()
+#endif
+    update();
+    if ( QMenuData::d->aWidget )
+	QMenuData::d->aWidget->update();
+}
+
+void QPopupMenu::performDelayedChanges()
+{
+    if( pendingDelayedContentsChanges )
+	performDelayedContentsChanged();
+    if( pendingDelayedStateChanges )
+	performDelayedStateChanged();
+}
+
+void QPopupMenu::menuInsPopup( QPopupMenu *popup )
+{
+    connect( popup, SIGNAL(activatedRedirect(int)),
+	     SLOT(subActivated(int)) );
+    connect( popup, SIGNAL(highlightedRedirect(int)),
+	     SLOT(subHighlighted(int)) );
+    connect( popup, SIGNAL(destroyed(QObject*)),
+	     this, SLOT(popupDestroyed(QObject*)) );
+}
+
+void QPopupMenu::menuDelPopup( QPopupMenu *popup )
+{
+    popup->disconnect( SIGNAL(activatedRedirect(int)) );
+    popup->disconnect( SIGNAL(highlightedRedirect(int)) );
+    disconnect( popup, SIGNAL(destroyed(QObject*)),
+		this, SLOT(popupDestroyed(QObject*)) );
+}
+
+
+void QPopupMenu::frameChanged()
+{
+    menuContentsChanged();
+}
+
+/*!
+    Displays the popup menu so that the item number \a indexAtPoint
+    will be at the specified \e global position \a pos. To translate a
+    widget's local coordinates into global coordinates, use
+    QWidget::mapToGlobal().
+
+    When positioning a popup with exec() or popup(), bear in mind that
+    you cannot rely on the popup menu's current size(). For
+    performance reasons, the popup adapts its size only when
+    necessary, so in many cases, the size before and after the show is
+    different. Instead, use sizeHint(). It calculates the proper size
+    depending on the menu's current contents.
+*/
+
+void QPopupMenu::popup( const QPoint &pos, int indexAtPoint )
+{
+    if ( !isPopup() && isVisible() )
+	hide();
+
+    //avoid circularity
+    if ( isVisible() || !isEnabled() )
+	return;
+
+#if defined(Q_WS_MAC) && !defined(QMAC_QMENUBAR_NO_NATIVE)
+    if( macPopupMenu(pos, indexAtPoint ))
+	return;
+#endif
+
+#if (QT_VERSION-0 >= 0x040000)
+#error "Fix this now"
+    // #### should move to QWidget - anything might need this functionality,
+    // #### since anything can have WType_Popup window flag.
+    // #### This includes stuff in QPushButton and some stuff for setting
+    // #### the geometry of QDialog.
+    // QPopupMenu
+    // ::exec()
+    // ::popup()
+    // QPushButton (shouldn't require QMenuPopup)
+    // ::popupPressed
+    // Some stuff in qwidget.cpp for dialogs... can't remember exactly.
+    // Also the code here indicatets the parameter should be a rect, not a
+    // point.
+#endif
+
+    if(d->scroll.scrollable) {
+	d->scroll.scrollable = QPopupMenuPrivate::Scroll::ScrollNone;
+	d->scroll.topScrollableIndex = d->scroll.scrollableSize = 0;
+	badSize = TRUE;
+    }
+    updateSize();
+
+    QPoint mouse = QCursor::pos();
+    snapToMouse = pos == mouse;
+
+    // have to emit here as a menu might be setup in a slot connected
+    // to aboutToShow which will change the size of the menu
+    bool s = supressAboutToShow;
+    supressAboutToShow = TRUE;
+    if ( !s) {
+	emit aboutToShow();
+	updateSize(TRUE);
+    }
+
+    int screen_num;
+    if (QApplication::desktop()->isVirtualDesktop())
+	screen_num =
+	    QApplication::desktop()->screenNumber( QApplication::reverseLayout() ?
+						   pos+QPoint(width(),0) : pos );
+    else
+	screen_num = QApplication::desktop()->screenNumber( this );
+#ifdef Q_WS_MAC
+    QRect screen = QApplication::desktop()->availableGeometry( screen_num );
+#else
+    QRect screen = QApplication::desktop()->screenGeometry( screen_num );
+#endif
+    int sw = screen.width();			// screen width
+    int sh = screen.height();			// screen height
+    int sx = screen.x();			// screen pos
+    int sy = screen.y();
+    int x  = pos.x();
+    int y  = pos.y();
+    if ( indexAtPoint >= 0 )			// don't subtract when < 0
+	y -= itemGeometry( indexAtPoint ).y();		// (would subtract 2 pixels!)
+    int w  = width();
+    int h  = height();
+
+    if ( snapToMouse ) {
+	if ( qApp->reverseLayout() )
+	    x -= w;
+	if ( x+w > sx+sw )
+	    x = mouse.x()-w;
+	if ( y+h > sy+sh )
+	    y = mouse.y()-h;
+	if ( x < sx )
+	    x = mouse.x();
+	if ( y < sy )
+	    y = sy;
+    }
+
+    if(style().styleHint(QStyle::SH_PopupMenu_Scrollable, this)) {
+	int off_top = 0, off_bottom = 0;
+	if(y+h > sy+sh)
+	    off_bottom = (y+h) - (sy+sh);
+	if(y < sy)
+	    off_top = sy - y;
+	if(off_bottom || off_top) {
+	    int ch = updateSize().height(); //store the old height, before setting scrollable --Sam
+	    const int vextra = style().pixelMetric(QStyle::PM_PopupMenuFrameVerticalExtra, this);
+	    d->scroll.scrollableSize = h - off_top - off_bottom - 2*vextra;
+	    if(off_top) {
+		move( x, y = sy );
+		d->scroll.scrollable = d->scroll.scrollable | QPopupMenuPrivate::Scroll::ScrollUp;
+	    }
+	    if( off_bottom )
+		d->scroll.scrollable = d->scroll.scrollable | QPopupMenuPrivate::Scroll::ScrollDown;
+	    if( off_top != off_bottom && indexAtPoint >= 0 ) {
+		ch -= (vextra * 2);
+		if(ch > sh) //no bigger than the screen!
+		    ch = sh;
+		if( ch > d->scroll.scrollableSize ) 
+		    d->scroll.scrollableSize = ch;
+	    }
+
+	    updateSize(TRUE); //now set the size using the scrollable/scrollableSize as above
+            w = width();
+            h = height();
+	    if(indexAtPoint >= 0) { 
+		if(off_top) { //scroll to it
+		    register QMenuItem *mi = NULL;
+		    QMenuItemListIt it(*mitems);
+		    for(int tmp_y = 0; tmp_y < off_top && (mi=it.current()); ) {
+			QSize sz = style().sizeFromContents(QStyle::CT_PopupMenuItem, this,
+							    QSize(0, itemHeight( mi )),
+							    QStyleOption(mi,maxPMWidth,0));
+			tmp_y += sz.height();
+			d->scroll.topScrollableIndex++;
+		    }
+		} 
+	    }
+	}
+    }
+    if ( x+w > sx+sw )				// the complete widget must
+	x = sx+sw - w;				//   be visible
+    if ( y+h > sy+sh )
+	y = sy+sh - h;
+    if ( x < sx )
+	x = sx;
+    if ( y < sy )
+	y = sy;
+    move( x, y );
+    motion=0;
+    actItem = -1;
+
+#ifndef QT_NO_EFFECTS
+    int hGuess = qApp->reverseLayout() ? QEffects::LeftScroll : QEffects::RightScroll;
+    int vGuess = QEffects::DownScroll;
+    if ( qApp->reverseLayout() ) {
+	if ( snapToMouse && ( x + w/2 > mouse.x() ) ||
+	    ( parentMenu && parentMenu->isPopupMenu &&
+	    ( x + w/2 > ((QPopupMenu*)parentMenu)->x() ) ) )
+	    hGuess = QEffects::RightScroll;
+    } else {
+	if ( snapToMouse && ( x + w/2 < mouse.x() ) ||
+	    ( parentMenu && parentMenu->isPopupMenu &&
+	    ( x + w/2 < ((QPopupMenu*)parentMenu)->x() ) ) )
+	    hGuess = QEffects::LeftScroll;
+    }
+
+#ifndef QT_NO_MENUBAR
+    if ( snapToMouse && ( y + h/2 < mouse.y() ) ||
+	( parentMenu && parentMenu->isMenuBar &&
+	( y + h/2 < ((QMenuBar*)parentMenu)->mapToGlobal( ((QMenuBar*)parentMenu)->pos() ).y() ) ) )
+	vGuess = QEffects::UpScroll;
+#endif
+
+    if ( QApplication::isEffectEnabled( UI_AnimateMenu ) &&
+	 preventAnimation == FALSE ) {
+	if ( QApplication::isEffectEnabled( UI_FadeMenu ) )
+	    qFadeEffect( this );
+	else if ( parentMenu )
+	    qScrollEffect( this, parentMenu->isPopupMenu ? hGuess : vGuess );
+	else
+	    qScrollEffect( this, hGuess | vGuess );
+    } else
+#endif
+    {
+	show();
+    }
+#if defined(QT_ACCESSIBILITY_SUPPORT)
+    QAccessible::updateAccessibility( this, 0, QAccessible::PopupMenuStart );
+#endif
+}
+
+/*!
+    \fn void QPopupMenu::activated( int id )
+
+    This signal is emitted when a menu item is selected; \a id is the
+    id of the selected item.
+
+    Normally, you connect each menu item to a single slot using
+    QMenuData::insertItem(), but sometimes you will want to connect
+    several items to a single slot (most often if the user selects
+    from an array). This signal is useful in such cases.
+
+    \sa highlighted(), QMenuData::insertItem()
+*/
+
+/*!
+    \fn void QPopupMenu::highlighted( int id )
+
+    This signal is emitted when a menu item is highlighted; \a id is
+    the id of the highlighted item.
+
+    \sa activated(), QMenuData::insertItem()
+*/
+
+/*! \fn void QPopupMenu::highlightedRedirect( int id )
+  \internal
+  Used internally to connect submenus to their parents.
+*/
+
+/*! \fn void QPopupMenu::activatedRedirect( int id )
+  \internal
+  Used internally to connect submenus to their parents.
+*/
+
+void QPopupMenu::subActivated( int id )
+{
+    emit activatedRedirect( id );
+}
+
+void QPopupMenu::subHighlighted( int id )
+{
+    emit highlightedRedirect( id );
+}
+
+static bool fromAccel = FALSE;
+
+#ifndef QT_NO_ACCEL
+void QPopupMenu::accelActivated( int id )
+{
+    QMenuItem *mi = findItem( id );
+    if ( mi && mi->isEnabledAndVisible() ) {
+	QGuardedPtr<QSignal> signal = mi->signal();
+	fromAccel = TRUE;
+	actSig( mi->id() );
+	fromAccel = FALSE;
+	if ( signal )
+	    signal->activate();
+    }
+}
+
+void QPopupMenu::accelDestroyed()		// accel about to be deleted
+{
+    autoaccel = 0;				// don't delete it twice!
+}
+#endif //QT_NO_ACCEL
+
+void QPopupMenu::popupDestroyed( QObject *o )
+{
+    removePopup( (QPopupMenu*)o );
+}
+
+void QPopupMenu::actSig( int id, bool inwhatsthis )
+{
+    if ( !inwhatsthis ) {
+	emit activated( id );
+#if defined(QT_ACCESSIBILITY_SUPPORT)
+	if ( !fromAccel )
+	    QAccessible::updateAccessibility( this, indexOf(id)+1, QAccessible::MenuCommand );
+#endif
+    } else {
+#ifndef QT_NO_WHATSTHIS
+	QRect r( itemGeometry( indexOf( id ) ) );
+	QPoint p( r.center().x(), r.bottom() );
+	QString whatsThis = findItem( id )->whatsThis();
+	if ( whatsThis.isNull() )
+	    whatsThis = QWhatsThis::textFor( this, p );
+	QWhatsThis::leaveWhatsThisMode( whatsThis, mapToGlobal( p ), this );
+#endif
+    }
+
+    emit activatedRedirect( id );
+}
+
+void QPopupMenu::hilitSig( int id )
+{
+    emit highlighted( id );
+    emit highlightedRedirect( id );
+
+#if defined(QT_ACCESSIBILITY_SUPPORT)
+    QAccessible::updateAccessibility( this, indexOf(id)+1, QAccessible::Focus );
+    QAccessible::updateAccessibility( this, indexOf(id)+1, QAccessible::Selection );
+#endif
+}
+
+void QPopupMenu::setFirstItemActive()
+{
+    QMenuItemListIt it(*mitems);
+    register QMenuItem *mi;
+    int ai = 0;
+    if(d->scroll.scrollable)
+	ai = d->scroll.topScrollableIndex;
+    while ( (mi=it.current()) ) {
+	++it;
+	if ( !mi->isSeparator() && mi->id() != QMenuData::d->aInt &&
+	     ( style().styleHint( QStyle::SH_PopupMenu_AllowActiveAndDisabled, this ) || mi->isEnabledAndVisible() )) {
+	    setActiveItem( ai );
+	    return;
+	}
+	ai++;
+    }
+    actItem = -1;
+}
+
+/*!
+  \internal
+  Hides all popup menus (in this menu tree) that are currently open.
+*/
+
+void QPopupMenu::hideAllPopups()
+{
+    register QMenuData *top = this;		// find top level popup
+    if ( !preventAnimation )
+	QTimer::singleShot( 10, this, SLOT(allowAnimation()) );
+    preventAnimation = TRUE;
+
+    if ( !isPopup() )
+	return; // nothing to do
+
+    while ( top->parentMenu && top->parentMenu->isPopupMenu
+	    && ((QPopupMenu*)top->parentMenu)->isPopup() )
+	top = top->parentMenu;
+    ((QPopupMenu*)top)->hide();			// cascade from top level
+
+#ifndef QT_NO_WHATSTHIS
+    if (whatsThisItem) {
+	qWhatsThisBDH();
+	whatsThisItem = 0;
+    }
+#endif
+
+}
+
+/*!
+  \internal
+  Hides all popup sub-menus.
+*/
+
+void QPopupMenu::hidePopups()
+{
+    if ( !preventAnimation )
+	QTimer::singleShot( 10, this, SLOT(allowAnimation()) );
+    preventAnimation = TRUE;
+
+    QMenuItemListIt it(*mitems);
+    register QMenuItem *mi;
+    while ( (mi=it.current()) ) {
+	++it;
+	if ( mi->popup() && mi->popup()->parentMenu == this ) //avoid circularity
+	    mi->popup()->hide();
+    }
+    popupActive = -1;				// no active sub menu
+    if(style().styleHint(QStyle::SH_PopupMenu_SubMenuPopupDelay, this))
+	d->mouseMoveBuffer = QRegion();
+
+    QRect mfrect = itemGeometry( actItem );
+    setMicroFocusHint( mfrect.x(), mfrect.y(), mfrect.width(), mfrect.height(), FALSE );
+}
+
+
+/*!
+  \internal
+  Sends the event to the menu bar.
+*/
+
+bool QPopupMenu::tryMenuBar( QMouseEvent *e )
+{
+    register QMenuData *top = this;		// find top level
+    while ( top->parentMenu )
+	top = top->parentMenu;
+#ifndef QT_NO_MENUBAR
+    return top->isMenuBar ?
+	((QMenuBar *)top)->tryMouseEvent( this, e ) :
+			      ((QPopupMenu*)top)->tryMouseEvent(this, e );
+#else
+    return ((QPopupMenu*)top)->tryMouseEvent(this, e );
+#endif
+}
+
+
+/*!
+  \internal
+*/
+bool QPopupMenu::tryMouseEvent( QPopupMenu *p, QMouseEvent * e)
+{
+    if ( p == this )
+	return FALSE;
+    QPoint pos = mapFromGlobal( e->globalPos() );
+    if ( !rect().contains( pos ) )		// outside
+	return FALSE;
+    QMouseEvent ee( e->type(), pos, e->globalPos(), e->button(), e->state() );
+    event( &ee );
+    return TRUE;
+}
+
+/*!
+  \internal
+  Tells the menu bar to go back to idle state.
+*/
+
+void QPopupMenu::byeMenuBar()
+{
+#ifndef QT_NO_MENUBAR
+    register QMenuData *top = this;		// find top level
+    while ( top->parentMenu )
+	top = top->parentMenu;
+#endif
+    hideAllPopups();
+#ifndef QT_NO_MENUBAR
+    if ( top->isMenuBar )
+	((QMenuBar *)top)->goodbye();
+#endif
+}
+
+
+/*!
+  \internal
+  Return the item at \a pos, or -1 if there is no item there or if
+  it is a separator item.
+*/
+
+int QPopupMenu::itemAtPos( const QPoint &pos, bool ignoreSeparator ) const
+{
+    if ( !contentsRect().contains(pos) )
+	return -1;
+
+    int row = 0;
+    int x = contentsRect().x();
+    int y = contentsRect().y();
+    QMenuItem *mi;
+    QMenuItemListIt it( *mitems );
+    if(d->scroll.scrollable) {
+	if(d->scroll.topScrollableIndex) {
+	    for( ; (mi = it.current()) && row < d->scroll.topScrollableIndex; row++)
+		++it;
+	    if(!mi) {
+		row = 0;
+		it.toFirst();
+	    }
+	    y += style().pixelMetric(QStyle::PM_PopupMenuScrollerHeight, this);
+	}
+    }
+    int itemw = contentsRect().width() / ncols;
+    QSize sz;
+    while ( (mi=it.current()) ) {
+	if(d->scroll.scrollable & QPopupMenuPrivate::Scroll::ScrollDown &&
+	   y >= contentsRect().height() - style().pixelMetric(QStyle::PM_PopupMenuScrollerHeight, this))
+	    return -1;
+	++it;
+	if ( !mi->isVisible() ) {
+	    ++row;
+	    continue;
+	}
+	int itemh = itemHeight( mi );
+
+	sz = style().sizeFromContents(QStyle::CT_PopupMenuItem, this,
+				      QSize(0, itemh),
+				      QStyleOption(mi,maxPMWidth));
+	sz = sz.expandedTo(QSize(itemw, sz.height()));
+	itemw = sz.width();
+	itemh = sz.height();
+
+	if ( ncols > 1 && y + itemh > contentsRect().bottom() ) {
+	    y = contentsRect().y();
+	    x +=itemw;
+	}
+	if ( QRect( x, y, itemw, itemh ).contains( pos ) )
+	    break;
+	y += itemh;
+	++row;
+    }
+
+    if ( mi && ( !ignoreSeparator || !mi->isSeparator() ) )
+	return row;
+    return -1;
+}
+
+/*!
+  \internal
+  Returns the geometry of item number \a index.
+*/
+
+QRect QPopupMenu::itemGeometry( int index )
+{
+    QMenuItem *mi;
+    QSize sz;
+    int row = 0, scrollh = 0;
+    int x = contentsRect().x();
+    int y = contentsRect().y();
+    QMenuItemListIt it( *mitems );
+    if(d->scroll.scrollable & QPopupMenuPrivate::Scroll::ScrollUp) {
+	scrollh = style().pixelMetric(QStyle::PM_PopupMenuScrollerHeight, this);
+	y += scrollh;
+	if(d->scroll.topScrollableIndex) {
+	    for( ; (mi = it.current()) && row < d->scroll.topScrollableIndex; row++)
+		++it;
+	    if(!mi) {
+		row = 0;
+		it.toFirst();
+	    }
+	}
+    }
+    int itemw = contentsRect().width() / ncols;
+    while ( (mi=it.current()) ) {
+	if(d->scroll.scrollable & QPopupMenuPrivate::Scroll::ScrollDown &&
+	   y >= contentsRect().height() - scrollh)
+	    break;
+	++it;
+	if ( !mi->isVisible() ) {
+	    ++row;
+	    continue;
+	}
+	int itemh = itemHeight( mi );
+
+	sz = style().sizeFromContents(QStyle::CT_PopupMenuItem, this,
+				      QSize(0, itemh),
+				      QStyleOption(mi,maxPMWidth));
+	sz = sz.expandedTo(QSize(itemw, sz.height()));
+	itemw = sz.width();
+	itemh = sz.height();
+	if(d->scroll.scrollable & QPopupMenuPrivate::Scroll::ScrollDown &&
+	   (y + itemh > contentsRect().height() - scrollh))
+	    itemh -= (y + itemh) - (contentsRect().height() - scrollh);
+	if ( ncols > 1 && y + itemh > contentsRect().bottom() ) {
+	    y = contentsRect().y();
+	    x +=itemw;
+	}
+	if ( row == index )
+	    return QRect( x,y,itemw,itemh );
+	y += itemh;
+	++row;
+    }
+
+    return QRect(0,0,0,0);
+}
+
+
+/*!
+  \internal
+  Calculates and sets the size of the popup menu, based on the size
+  of the items.
+*/
+
+QSize QPopupMenu::updateSize(bool force_update, bool do_resize)
+{
+    polish();
+    if ( count() == 0 ) {
+	QSize ret = QSize( 50, 8 );
+	if(do_resize)
+	    setFixedSize( ret );
+	badSize = TRUE;
+	return ret;
+    }
+
+    int scrheight = 0;
+    if(d->scroll.scrollableSize) {
+	if(d->scroll.scrollable & QPopupMenuPrivate::Scroll::ScrollUp)
+	    scrheight += style().pixelMetric(QStyle::PM_PopupMenuScrollerHeight, this);
+	if(d->scroll.scrollable & QPopupMenuPrivate::Scroll::ScrollDown)
+	    scrheight += style().pixelMetric(QStyle::PM_PopupMenuScrollerHeight, this);
+    }
+
+    if(badSize || force_update) {
+#ifndef QT_NO_ACCEL
+	updateAccel( 0 );
+#endif
+	int height = 0;
+	int max_width = 0, max_height = 0;
+	QFontMetrics fm = fontMetrics();
+	register QMenuItem *mi;
+	maxPMWidth = 0;
+	int maxWidgetWidth = 0;
+	tab = 0;
+
+	for ( QMenuItemListIt it( *mitems ); it.current(); ++it ) {
+	    mi = it.current();
+	    QWidget *miw = mi->widget();
+	    if (miw) {
+		if ( miw->parentWidget() != this )
+		    miw->reparent( this, QPoint(0,0), TRUE );
+		// widget items musn't propgate mouse events
+		((QPopupMenu*)miw)->setWFlags(WNoMousePropagation);
+	    }
+	    if ( mi->custom() )
+		mi->custom()->setFont( font() );
+	    if ( mi->iconSet() != 0)
+		maxPMWidth = QMAX( maxPMWidth,
+				   mi->iconSet()->pixmap( QIconSet::Small, QIconSet::Normal ).width() + 4 );
+	}
+
+	int dh = QApplication::desktop()->height();
+	ncols = 1;
+
+	for ( QMenuItemListIt it2( *mitems ); it2.current(); ++it2 ) {
+	    mi = it2.current();
+	    if ( !mi->isVisible() )
+		continue;
+	    int w = 0;
+	    int itemHeight = QPopupMenu::itemHeight( mi );
+
+	    if ( mi->widget() ) {
+		QSize s( mi->widget()->sizeHint() );
+		s = s.expandedTo( mi->widget()->minimumSize() );
+		mi->widget()->resize( s );
+		if ( s.width()  > maxWidgetWidth )
+		    maxWidgetWidth = s.width();
+		itemHeight = s.height();
+	    } else {
+		if( ! mi->isSeparator() ) {
+		    if ( mi->custom() ) {
+			if ( mi->custom()->fullSpan() ) {
+			    maxWidgetWidth = QMAX( maxWidgetWidth,
+						   mi->custom()->sizeHint().width() );
+			} else {
+			    QSize s ( mi->custom()->sizeHint() );
+			    w += s.width();
+			}
+		    }
+
+		    w += maxPMWidth;
+
+		    if (! mi->text().isNull()) {
+			QString s = mi->text();
+			int t;
+			if ( (t = s.find('\t')) >= 0 ) { // string contains tab
+			    w += fm.width( s, t );
+			    w -= s.contains('&') * fm.width('&');
+			    w += s.contains("&&") * fm.width('&');
+			    int tw = fm.width( s.mid(t + 1) );
+			    if ( tw > tab)
+				tab = tw;
+			} else {
+			    w += fm.width( s );
+			    w -= s.contains('&') * fm.width('&');
+			    w += s.contains("&&") * fm.width('&');
+			}
+		    } else if (mi->pixmap())
+			w += mi->pixmap()->width();
+		} else {
+		    if ( mi->custom() ) {
+			QSize s ( mi->custom()->sizeHint() );
+			w += s.width();
+		    } else {
+			w = itemHeight = 2;
+		    }
+		}
+
+		QSize sz = style().sizeFromContents(QStyle::CT_PopupMenuItem, this,
+						    QSize(w, itemHeight),
+						    QStyleOption(mi,maxPMWidth));
+
+		w = sz.width();
+		itemHeight = sz.height();
+
+#if defined(QT_CHECK_NULL)
+		if ( mi->text().isNull() && !mi->pixmap() && !mi->iconSet() &&
+		     !mi->isSeparator() && !mi->widget() && !mi->custom() )
+		    qWarning( "QPopupMenu: (%s) Popup has invalid menu item",
+			      name( "unnamed" ) );
+#endif
+	    }
+	    height += itemHeight;
+	    if(style().styleHint(QStyle::SH_PopupMenu_Scrollable, this)) {
+		if(scrheight && height >= d->scroll.scrollableSize - scrheight) {
+                    height = d->scroll.scrollableSize - scrheight;
+		    break;
+                }
+	    } else if( height + 2*frameWidth() >= dh ) {
+		ncols++;
+		max_height = QMAX(max_height, height - itemHeight);
+		height = 0;
+	    }
+	    if ( w > max_width )
+		max_width = w;
+	}
+	if( ncols == 1 && !max_height )
+	    max_height = height;
+
+	if(style().styleHint(QStyle::SH_PopupMenu_Scrollable, this)) {
+	    height += scrheight;
+	    setMouseTracking(TRUE);
+	}
+
+	if ( tab )
+	    tab -= fontMetrics().minRightBearing();
+	else
+	    max_width -= fontMetrics().minRightBearing();
+
+	if ( max_width + tab < maxWidgetWidth )
+	    max_width = maxWidgetWidth - tab;
+
+	const int fw = frameWidth();
+	int extra_width = (fw+style().pixelMetric(QStyle::PM_PopupMenuFrameHorizontalExtra, this)) * 2,
+	   extra_height = (fw+style().pixelMetric(QStyle::PM_PopupMenuFrameVerticalExtra,   this)) * 2;
+	if ( ncols == 1 )
+	    d->calcSize = QSize( QMAX( minimumWidth(), max_width + tab + extra_width ),
+			      QMAX( minimumHeight() , height + extra_height ) );
+	else
+	    d->calcSize = QSize( QMAX( minimumWidth(), (ncols*(max_width + tab)) + extra_width ),
+			      QMAX( minimumHeight(), QMIN( max_height + extra_height + 1, dh ) ) );
+	badSize = FALSE;
+    }
+
+    {
+	// Position the widget items. It could be done in drawContents
+	// but this way we get less flicker.
+	QSize sz;
+	int x = contentsRect().x();
+	int y = contentsRect().y();
+	int itemw = contentsRect().width() / ncols;
+	for(QMenuItemListIt it(*mitems); it.current(); ++it) {
+	    QMenuItem *mi = it.current();
+	    if ( !mi->isVisible() )
+		continue;
+
+	    int itemh = itemHeight( mi );
+	    
+	    sz = style().sizeFromContents(QStyle::CT_PopupMenuItem, this,
+					  QSize(0, itemh), QStyleOption(mi,maxPMWidth));
+	    sz = sz.expandedTo(QSize(itemw, sz.height()));
+	    itemw = sz.width();
+	    itemh = sz.height();
+
+	    if ( ncols > 1 && y + itemh > contentsRect().bottom() ) {
+		y = contentsRect().y();
+		x +=itemw;
+	    }
+	    if ( mi->widget() ) 
+		mi->widget()->setGeometry( x, y, itemw, mi->widget()->height() );
+	    y += itemh;
+	}
+    }
+
+    if( do_resize && size() != d->calcSize ) {
+	setMaximumSize( d->calcSize );
+        d->calcSize = maximumSize(); //let the max size adjust it (virtual)
+	resize( d->calcSize );
+    }
+    return d->calcSize;
+}
+
+
+#ifndef QT_NO_ACCEL
+/*!
+  \internal
+  The \a parent is 0 when it is updated when a menu item has
+  changed a state, or it is something else if called from the menu bar.
+*/
+
+void QPopupMenu::updateAccel( QWidget *parent )
+{
+    QMenuItemListIt it(*mitems);
+    register QMenuItem *mi;
+
+    if ( parent ) {
+	delete autoaccel;
+	autoaccel = 0;
+    } else if ( !autoaccel ) {
+	// we have no parent. Rather than ignoring any accelerators we try to find this popup's main window
+	if ( tornOff ) {
+	    parent = this;
+	} else {
+	    QWidget *w = (QWidget *) this;
+	    parent = w->parentWidget();
+	    while ( (!w->testWFlags(WType_TopLevel) || !w->testWFlags(WType_Popup)) && parent ) {
+		w = parent;
+		parent = parent->parentWidget();
+	    }
+	}
+    }
+
+    if ( parent == 0 && autoaccel == 0 )
+ 	return;
+
+    if ( autoaccel )				// build it from scratch
+	autoaccel->clear();
+    else {
+	// create an autoaccel in any case, even if we might not use
+	// it immediately. Maybe the user needs it later.
+	autoaccel = new QAccel( parent, this );
+	connect( autoaccel, SIGNAL(activated(int)),
+		 SLOT(accelActivated(int)) );
+	connect( autoaccel, SIGNAL(activatedAmbiguously(int)),
+		 SLOT(accelActivated(int)) );
+	connect( autoaccel, SIGNAL(destroyed()),
+		 SLOT(accelDestroyed()) );
+	if ( accelDisabled )
+	    autoaccel->setEnabled( FALSE );
+    }
+    while ( (mi=it.current()) ) {
+	++it;
+	QKeySequence k = mi->key();
+	if ( (int)k ) {
+	    int id = autoaccel->insertItem( k, mi->id() );
+#ifndef QT_NO_WHATSTHIS
+	    autoaccel->setWhatsThis( id, mi->whatsThis() );
+#endif
+	}
+	if ( !mi->text().isNull() || mi->custom() ) {
+	    QString s = mi->text();
+	    int i = s.find('\t');
+
+	    // Note: Only looking at the first key in the sequence!
+	    if ( (int)k && (int)k != Key_unknown ) {
+		QString t = (QString)mi->key();
+		if ( i >= 0 )
+		    s.replace( i+1, s.length()-i, t );
+		else {
+		    s += '\t';
+		    s += t;
+		}
+	    } else if ( !k ) {
+ 		if ( i >= 0 )
+ 		    s.truncate( i );
+	    }
+	    if ( s != mi->text() ) {
+		mi->setText( s );
+		badSize = TRUE;
+	    }
+	}
+	if ( mi->popup() && parent ) {		// call recursively
+	    // reuse
+	    QPopupMenu* popup = mi->popup();
+	    if (!popup->avoid_circularity) {
+		popup->avoid_circularity = 1;
+		popup->updateAccel( parent );
+		popup->avoid_circularity = 0;
+	    }
+	}
+    }
+}
+
+/*!
+  \internal
+  It would be better to check in the slot.
+*/
+
+void QPopupMenu::enableAccel( bool enable )
+{
+    if ( autoaccel )
+	autoaccel->setEnabled( enable );
+    accelDisabled = !enable;		// rememeber when updateAccel
+    QMenuItemListIt it(*mitems);
+    register QMenuItem *mi;
+    while ( (mi=it.current()) ) {		// do the same for sub popups
+	++it;
+	if ( mi->popup() )			// call recursively
+	    mi->popup()->enableAccel( enable );
+    }
+}
+#endif
+
+/*!
+    \reimp
+*/
+void QPopupMenu::setFont( const QFont &font )
+{
+    QWidget::setFont( font );
+    badSize = TRUE;
+    if ( isVisible() ) {
+	updateSize();
+	update();
+    }
+}
+
+/*!
+    \reimp
+*/
+void QPopupMenu::show()
+{
+    if ( !isPopup() && isVisible() )
+	hide();
+
+    if ( isVisible() ) {
+	supressAboutToShow = FALSE;
+	QWidget::show();
+	return;
+    }
+    if (!supressAboutToShow)
+	emit aboutToShow();
+    else
+	supressAboutToShow = FALSE;
+    performDelayedChanges();
+    updateSize(TRUE);
+    QWidget::show();
+    popupActive = -1;
+    if(style().styleHint(QStyle::SH_PopupMenu_SubMenuPopupDelay, this))
+	d->mouseMoveBuffer = QRegion();
+}
+
+/*!
+    \reimp
+*/
+
+void QPopupMenu::hide()
+{
+    if ( syncMenu == this && qApp ) {
+	qApp->exit_loop();
+	syncMenu = 0;
+    }
+
+    if ( !isVisible() ) {
+	QWidget::hide();
+  	return;
+    }
+    emit aboutToHide();
+
+    actItem = popupActive = -1;
+    if(style().styleHint(QStyle::SH_PopupMenu_SubMenuPopupDelay, this))
+	d->mouseMoveBuffer = QRegion();
+    mouseBtDn = FALSE;				// mouse button up
+#if defined(QT_ACCESSIBILITY_SUPPORT)
+    QAccessible::updateAccessibility( this, 0, QAccessible::PopupMenuEnd );
+#endif
+    parentMenu = 0;
+    hidePopups();
+    QWidget::hide();
+}
+
+
+/*!
+    Calculates the height in pixels of the item in row \a row.
+*/
+int QPopupMenu::itemHeight( int row ) const
+{
+    return itemHeight( mitems->at( row ) );
+}
+
+/*!
+    \overload
+
+    Calculates the height in pixels of the menu item \a mi.
+*/
+int QPopupMenu::itemHeight( QMenuItem *mi ) const
+{
+    if  ( mi->widget() )
+	return mi->widget()->height();
+    if ( mi->custom() && mi->custom()->fullSpan() )
+	return mi->custom()->sizeHint().height();
+
+    QFontMetrics fm(fontMetrics());
+    int h = 0;
+    if ( mi->isSeparator() ) // separator height
+        h = 2;
+    else if ( mi->pixmap() ) // pixmap height
+        h = mi->pixmap()->height();
+    else                     // text height
+        h = fm.height();
+
+    if ( !mi->isSeparator() && mi->iconSet() != 0 )
+        h = QMAX(h, mi->iconSet()->pixmap( QIconSet::Small,
+					   QIconSet::Normal ).height());
+    if ( mi->custom() )
+        h = QMAX(h, mi->custom()->sizeHint().height());
+
+    return h;
+}
+
+
+/*!
+    Draws menu item \a mi in the area \a x, \a y, \a w, \a h, using
+    painter \a p. The item is drawn active if \a act is TRUE or drawn
+    inactive if \a act is FALSE. The rightmost \a tab_ pixels are used
+    for accelerator text.
+
+    \sa QStyle::drawControl()
+*/
+void QPopupMenu::drawItem( QPainter* p, int tab_, QMenuItem* mi,
+			   bool act, int x, int y, int w, int h)
+{
+    QStyle::SFlags flags = QStyle::Style_Default;
+    if (isEnabled() && mi->isEnabledAndVisible() && (!mi->popup() || mi->popup()->isEnabled()) )
+	flags |= QStyle::Style_Enabled;
+    if (act)
+	flags |= QStyle::Style_Active;
+    if (mouseBtDn)
+	flags |= QStyle::Style_Down;
+
+    const QColorGroup &cg = ((flags&QStyle::Style_Enabled) ? colorGroup() : palette().disabled() );
+
+    if ( mi->custom() && mi->custom()->fullSpan() ) {
+	QMenuItem dummy;
+	style().drawControl(QStyle::CE_PopupMenuItem, p, this, QRect(x, y, w, h), cg,
+			    flags, QStyleOption(&dummy,maxPMWidth,tab_));
+	mi->custom()->paint( p, cg, act, flags&QStyle::Style_Enabled, x, y, w, h );
+    } else
+	style().drawControl(QStyle::CE_PopupMenuItem, p, this, QRect(x, y, w, h), cg,
+			    flags, QStyleOption(mi,maxPMWidth,tab_));
+}
+
+
+/*!
+    Draws all menu items using painter \a p.
+*/
+void QPopupMenu::drawContents( QPainter* p )
+{
+    QMenuItemListIt it(*mitems);
+    QMenuItem *mi = 0;
+    int row = 0;
+    int x = contentsRect().x();
+    int y = contentsRect().y();
+    if(d->scroll.scrollable) {
+	if(d->scroll.topScrollableIndex) {
+	    for( ; (mi = it.current()) && row < d->scroll.topScrollableIndex; row++)
+		++it;
+	    if(!mi)
+		it.toFirst();
+	}
+	if(d->scroll.scrollable & QPopupMenuPrivate::Scroll::ScrollUp) {
+	    QRect rect(x, y, contentsRect().width(),
+		       style().pixelMetric(QStyle::PM_PopupMenuScrollerHeight, this));
+	    if(!p->hasClipping() || p->clipRegion().contains(rect)) {
+		QStyle::SFlags flags = QStyle::Style_Up;
+		if (isEnabled())
+		    flags |= QStyle::Style_Enabled;
+		style().drawControl(QStyle::CE_PopupMenuScroller, p, this, rect,
+				    colorGroup(), flags, QStyleOption(maxPMWidth));
+	    }
+	    y += rect.height();
+	}
+    }
+
+    int itemw = contentsRect().width() / ncols;
+    QSize sz;
+    QStyle::SFlags flags;
+    while ( (mi=it.current()) ) {
+	if(d->scroll.scrollable & QPopupMenuPrivate::Scroll::ScrollDown &&
+	   y >= contentsRect().height() - style().pixelMetric(QStyle::PM_PopupMenuScrollerHeight, this))
+	    break;
+	++it;
+	if ( !mi->isVisible() ) {
+	    ++row;
+	    continue;
+	}
+	int itemh = itemHeight( mi );
+	sz = style().sizeFromContents(QStyle::CT_PopupMenuItem, this,
+				      QSize(0, itemh),
+				      QStyleOption(mi,maxPMWidth,0)
+				);
+	sz = sz.expandedTo(QSize(itemw, sz.height()));
+	itemw = sz.width();
+	itemh = sz.height();
+
+	if ( ncols > 1 && y + itemh > contentsRect().bottom() ) {
+	    if ( y < contentsRect().bottom() ) {
+		QRect rect(x, y, itemw, contentsRect().bottom() - y);
+		if(!p->hasClipping() || p->clipRegion().contains(rect)) {
+		    flags = QStyle::Style_Default;
+		    if (isEnabled() && mi->isEnabledAndVisible())
+			flags |= QStyle::Style_Enabled;
+		    style().drawControl(QStyle::CE_PopupMenuItem, p, this, rect,
+					colorGroup(), flags, QStyleOption((QMenuItem*)0,maxPMWidth));
+		}
+	    }
+	    y = contentsRect().y();
+	    x +=itemw;
+	}
+	if (!mi->widget() && (!p->hasClipping() || p->clipRegion().contains(QRect(x, y, itemw, itemh))))
+	    drawItem( p, tab, mi, row == actItem, x, y, itemw, itemh );
+	y += itemh;
+	++row;
+    }
+    if ( y < contentsRect().bottom() ) {
+	QRect rect(x, y, itemw, contentsRect().bottom() - y);
+	if(!p->hasClipping() || p->clipRegion().contains(rect)) {
+	    flags = QStyle::Style_Default;
+	    if ( isEnabled() )
+		flags |= QStyle::Style_Enabled;
+	    style().drawControl(QStyle::CE_PopupMenuItem, p, this, rect,
+				colorGroup(), flags, QStyleOption((QMenuItem*)0,maxPMWidth));
+	}
+    }
+    if( d->scroll.scrollable & QPopupMenuPrivate::Scroll::ScrollDown ) {
+	int sh = style().pixelMetric(QStyle::PM_PopupMenuScrollerHeight, this);
+	QRect rect(x, contentsRect().height() - sh, contentsRect().width(), sh);
+	if(!p->hasClipping() || p->clipRegion().contains(rect)) {
+	    QStyle::SFlags flags = QStyle::Style_Down;
+	    if (isEnabled())
+		flags |= QStyle::Style_Enabled;
+	    style().drawControl(QStyle::CE_PopupMenuScroller, p, this, rect,
+				colorGroup(), flags, QStyleOption(maxPMWidth));
+	}
+    }
+#if defined( DEBUG_SLOPPY_SUBMENU )
+    if ( style().styleHint(QStyle::SH_PopupMenu_SloppySubMenus, this )) {
+	p->setClipRegion( d->mouseMoveBuffer );
+	p->fillRect( d->mouseMoveBuffer.boundingRect(), colorGroup().brush( QColorGroup::Highlight ) );
+    }
+#endif
+}
+
+
+/*****************************************************************************
+  Event handlers
+ *****************************************************************************/
+
+/*!
+    \reimp
+*/
+
+void QPopupMenu::paintEvent( QPaintEvent *e )
+{
+    QFrame::paintEvent( e );
+}
+
+/*!
+    \reimp
+*/
+
+void QPopupMenu::closeEvent( QCloseEvent * e) {
+    e->accept();
+    byeMenuBar();
+}
+
+
+/*!
+    \reimp
+*/
+
+void QPopupMenu::mousePressEvent( QMouseEvent *e )
+{
+    int sh = style().pixelMetric(QStyle::PM_PopupMenuScrollerHeight, this);
+    if (rect().contains(e->pos()) &&
+	((d->scroll.scrollable & QPopupMenuPrivate::Scroll::ScrollUp && e->pos().y() <= sh) || //up
+	 (d->scroll.scrollable & QPopupMenuPrivate::Scroll::ScrollDown &&
+	     e->pos().y() >= contentsRect().height() - sh))) //down
+	return;
+
+    mouseBtDn = TRUE;				// mouse button down
+    int item = itemAtPos( e->pos() );
+    if ( item == -1 ) {
+	if ( !rect().contains(e->pos()) && !tryMenuBar(e) ) {
+	    byeMenuBar();
+	}
+	return;
+    }
+    register QMenuItem *mi = mitems->at(item);
+    if ( item != actItem )			// new item activated
+	setActiveItem( item );
+
+    QPopupMenu *popup = mi->popup();
+    if ( popup ) {
+	if ( popup->isVisible() ) {		// sub menu already open
+	    int pactItem = popup->actItem;
+	    popup->actItem = -1;
+	    popup->hidePopups();
+	    popup->updateRow( pactItem );
+	} else {				// open sub menu
+	    hidePopups();
+	    popupSubMenuLater( 20, this );
+	}
+    } else {
+	hidePopups();
+    }
+}
+
+/*!
+    \reimp
+*/
+
+void QPopupMenu::mouseReleaseEvent( QMouseEvent *e )
+{
+    // do not hide a standalone context menu on press-release, unless
+    // the user moved the mouse significantly
+    if ( !parentMenu && !mouseBtDn && actItem < 0 && motion < 6 )
+	return;
+
+    mouseBtDn = FALSE;
+
+    // if the user released the mouse outside the menu, pass control
+    // to the menubar or our parent menu
+    int sh = style().pixelMetric(QStyle::PM_PopupMenuScrollerHeight, this);
+    if ( !rect().contains( e->pos() ) && tryMenuBar(e) )
+	return;
+    else if((d->scroll.scrollable & QPopupMenuPrivate::Scroll::ScrollUp && e->pos().y() <= sh) || //up
+	    (d->scroll.scrollable & QPopupMenuPrivate::Scroll::ScrollDown &&
+	     e->pos().y() >= contentsRect().height() - sh)) //down
+	return;
+
+    if ( actItem < 0 ) { // we do not have an active item
+	// if the release is inside without motion (happens with
+	// oversized popup menus on small screens), ignore it
+	if ( rect().contains( e->pos() ) && motion < 6 )
+	    return;
+	else
+	    byeMenuBar();
+    } else {	// selected menu item!
+	register QMenuItem *mi = mitems->at(actItem);
+	if ( mi ->widget() ) {
+	    QWidget* widgetAt = QApplication::widgetAt( e->globalPos(), TRUE );
+	    if ( widgetAt && widgetAt != this ) {
+		QMouseEvent me( e->type(), widgetAt->mapFromGlobal( e->globalPos() ),
+				e->globalPos(), e->button(), e->state() );
+		QApplication::sendEvent( widgetAt, &me );
+	    }
+	}
+	QPopupMenu *popup = mi->popup();
+#ifndef QT_NO_WHATSTHIS
+	    bool b = QWhatsThis::inWhatsThisMode();
+#else
+	    const bool b = FALSE;
+#endif
+	if ( !mi->isEnabledAndVisible() ) {
+#ifndef QT_NO_WHATSTHIS
+	    if ( b ) {
+		actItem = -1;
+		updateItem( mi->id() );
+		byeMenuBar();
+		actSig( mi->id(), b);
+	    }
+#endif
+	} else 	if ( popup ) {
+	    popup->setFirstItemActive();
+	} else {				// normal menu item
+	    byeMenuBar();			// deactivate menu bar
+	    if ( mi->isEnabledAndVisible() ) {
+		actItem = -1;
+		updateItem( mi->id() );
+		active_popup_menu = this;
+		QGuardedPtr<QSignal> signal = mi->signal();
+		actSig( mi->id(), b );
+		if ( signal && !b )
+		    signal->activate();
+		active_popup_menu = 0;
+	    }
+	}
+    }
+}
+
+/*!
+    \reimp
+*/
+
+void QPopupMenu::mouseMoveEvent( QMouseEvent *e )
+{
+    motion++;
+
+    if ( parentMenu && parentMenu->isPopupMenu ) {
+	QPopupMenu* p = (QPopupMenu*)parentMenu;
+	int myIndex;
+
+	p->findPopup( this, &myIndex );
+	QPoint pPos = p->mapFromParent( e->globalPos() );
+	if ( p->actItem != myIndex && !p->rect().contains( pPos ) )
+	    p->setActiveItem( myIndex );
+
+	if ( style().styleHint(QStyle::SH_PopupMenu_SloppySubMenus, this )) {
+	    p->d->mouseMoveBuffer = QRegion();
+#ifdef DEBUG_SLOPPY_SUBMENU
+	    p->repaint();
+#endif
+	}
+    }
+
+    if ( (e->state() & Qt::MouseButtonMask) == 0 &&
+	 !hasMouseTracking() )
+	return;
+
+    if(d->scroll.scrollable && e->pos().x() >= rect().x() && e->pos().x() <= rect().width()) {
+        int sh = style().pixelMetric(QStyle::PM_PopupMenuScrollerHeight, this);
+        if((d->scroll.scrollable & QPopupMenuPrivate::Scroll::ScrollUp && e->pos().y() <= sh) || 
+           (d->scroll.scrollable & QPopupMenuPrivate::Scroll::ScrollDown && e->pos().y() >= height()-sh)) {
+            if(!d->scroll.scrolltimer) {
+                d->scroll.scrolltimer = new QTimer(this, "popup scroll timer");
+                QObject::connect( d->scroll.scrolltimer, SIGNAL(timeout()),
+                                  this, SLOT(subScrollTimer()) );
+            }
+            if(!d->scroll.scrolltimer->isActive())
+                d->scroll.scrolltimer->start(40);
+            return;
+        }
+    }
+
+    int	 item = itemAtPos( e->pos() );
+    if ( item == -1 ) {				// no valid item
+	int lastActItem = actItem;
+	actItem = -1;
+	if ( lastActItem >= 0 )
+	    updateRow( lastActItem );
+        if ( lastActItem > 0 ||
+		    ( !rect().contains( e->pos() ) && !tryMenuBar( e ) ) ) {
+	    popupSubMenuLater(style().styleHint(QStyle::SH_PopupMenu_SubMenuPopupDelay,
+						this), this);
+	}
+    } else {					// mouse on valid item
+	// but did not register mouse press
+	if ( (e->state() & Qt::MouseButtonMask) && !mouseBtDn )
+	    mouseBtDn = TRUE; // so mouseReleaseEvent will pop down
+
+	register QMenuItem *mi = mitems->at( item );
+
+	if ( mi->widget() ) {
+	    QWidget* widgetAt = QApplication::widgetAt( e->globalPos(), TRUE );
+	    if ( widgetAt && widgetAt != this ) {
+		QMouseEvent me( e->type(), widgetAt->mapFromGlobal( e->globalPos() ),
+				e->globalPos(), e->button(), e->state() );
+		QApplication::sendEvent( widgetAt, &me );
+	    }
+	}
+
+	if ( actItem == item )
+	    return;
+
+	if ( style().styleHint(QStyle::SH_PopupMenu_SloppySubMenus, this) &&
+	     d->mouseMoveBuffer.contains( e->pos() ) ) {
+	    actItem = item;
+	    popupSubMenuLater( style().styleHint(QStyle::SH_PopupMenu_SubMenuPopupDelay, this) * 6,
+			       this );
+	    return;
+	}
+
+	if ( mi->popup() || ( popupActive >= 0 && popupActive != item ))
+	    popupSubMenuLater( style().styleHint(QStyle::SH_PopupMenu_SubMenuPopupDelay, this),
+			       this );
+	else if ( singleSingleShot )
+	    singleSingleShot->stop();
+
+	if ( item != actItem )
+	    setActiveItem( item );
+    }
+}
+
+
+/*!
+    \reimp
+*/
+
+void QPopupMenu::keyPressEvent( QKeyEvent *e )
+{
+    /*
+      I get nothing but complaints about this.  -Brad
+
+      - if (mouseBtDn && actItem >= 0) {
+      -	if (e->key() == Key_Shift ||
+      -	    e->key() == Key_Control ||
+      -	    e->key() == Key_Alt)
+      -	    return;
+      -
+      -	QMenuItem *mi = mitems->at(actItem);
+      -	int modifier = (((e->state() & ShiftButton) ? SHIFT : 0) |
+      -			((e->state() & ControlButton) ? CTRL : 0) |
+      -			((e->state() & AltButton) ? ALT : 0));
+      -
+      - #ifndef QT_NO_ACCEL
+      -	if (mi)
+      -	    setAccel(modifier + e->key(), mi->id());
+      - #endif
+      - return;
+      - }
+    */
+
+    QMenuItem  *mi = 0;
+    QPopupMenu *popup;
+    int dy = 0;
+    bool ok_key = TRUE;
+
+    int key = e->key();
+    if ( QApplication::reverseLayout() ) {
+	// in reverse mode opening and closing keys for submenues are reversed
+	if ( key == Key_Left )
+	    key = Key_Right;
+	else if ( key == Key_Right )
+	    key = Key_Left;
+    }
+
+    switch ( key ) {
+    case Key_Tab:
+	// ignore tab, otherwise it will be passed to the menubar
+	break;
+
+    case Key_Up:
+	dy = -1;
+	break;
+
+    case Key_Down:
+	dy = 1;
+	break;
+
+    case Key_Alt:
+	if ( style().styleHint(QStyle::SH_MenuBar_AltKeyNavigation, this) )
+	    byeMenuBar();
+	break;
+
+    case Key_Escape:
+	if ( tornOff ) {
+	    close();
+	    return;
+	}
+	// just hide one
+	{
+	    QMenuData* p = parentMenu;
+	    hide();
+#ifndef QT_NO_MENUBAR
+	    if ( p && p->isMenuBar )
+		((QMenuBar*) p)->goodbye( TRUE );
+#endif
+	}
+	break;
+
+    case Key_Left:
+	if ( ncols > 1 && actItem >= 0 ) {
+	    QRect r( itemGeometry( actItem ) );
+	    int newActItem = itemAtPos( QPoint( r.left() - 1, r.center().y() ) );
+	    if ( newActItem >= 0 ) {
+		setActiveItem( newActItem );
+		break;
+	    }
+	}
+	if ( parentMenu && parentMenu->isPopupMenu ) {
+	    ((QPopupMenu *)parentMenu)->hidePopups();
+	    if ( singleSingleShot )
+		singleSingleShot->stop();
+	    break;
+	}
+
+	ok_key = FALSE;
+    	break;
+
+    case Key_Right:
+	if ( actItem >= 0 && ( mi=mitems->at(actItem) )->isEnabledAndVisible() && (popup=mi->popup()) ) {
+	    hidePopups();
+	    if ( singleSingleShot )
+		singleSingleShot->stop();
+	    // ### The next two lines were switched to fix the problem with the first item of the
+	    // submenu not being highlighted...any reason why they should have been the other way??
+	    subMenuTimer();
+	    popup->setFirstItemActive();
+	    break;
+	} else if ( actItem == -1 && ( parentMenu && !parentMenu->isMenuBar )) {
+	    dy = 1;
+	    break;
+	}
+	if ( ncols > 1 && actItem >= 0 ) {
+	    QRect r( itemGeometry( actItem ) );
+	    int newActItem = itemAtPos( QPoint( r.right() + 1, r.center().y() ) );
+	    if ( newActItem >= 0 ) {
+		setActiveItem( newActItem );
+		break;
+	    }
+	}
+	ok_key = FALSE;
+	break;
+
+    case Key_Space:
+	if (! style().styleHint(QStyle::SH_PopupMenu_SpaceActivatesItem, this))
+	    break;
+	// for motif, fall through
+
+    case Key_Return:
+    case Key_Enter:
+	{
+	    if ( actItem < 0 )
+		break;
+#ifndef QT_NO_WHATSTHIS
+	    bool b = QWhatsThis::inWhatsThisMode();
+#else
+	    const bool b = FALSE;
+#endif
+	    mi = mitems->at( actItem );
+	    if ( !mi->isEnabled() && !b )
+		break;
+	    popup = mi->popup();
+	    if ( popup ) {
+		hidePopups();
+		popupSubMenuLater( 20, this );
+		popup->setFirstItemActive();
+	    } else {
+		actItem = -1;
+		updateItem( mi->id() );
+		byeMenuBar();
+		if ( mi->isEnabledAndVisible() || b ) {
+		    active_popup_menu = this;
+		    QGuardedPtr<QSignal> signal = mi->signal();
+		    actSig( mi->id(), b );
+		    if ( signal && !b )
+			signal->activate();
+		    active_popup_menu = 0;
+		}
+	    }
+	}
+	break;
+#ifndef QT_NO_WHATSTHIS
+    case Key_F1:
+	if ( actItem < 0 || e->state() != ShiftButton)
+	    break;
+	mi = mitems->at( actItem );
+	if ( !mi->whatsThis().isNull() ){
+	    if ( !QWhatsThis::inWhatsThisMode() )
+		QWhatsThis::enterWhatsThisMode();
+	    QRect r( itemGeometry( actItem) );
+	    QWhatsThis::leaveWhatsThisMode( mi->whatsThis(), mapToGlobal( r.bottomLeft()) );
+	}
+	//fall-through!
+#endif
+    default:
+	ok_key = FALSE;
+
+    }
+    if ( !ok_key &&
+	 ( !e->state() || e->state() == AltButton || e->state() == ShiftButton ) &&
+	 e->text().length()==1 ) {
+	QChar c = e->text()[0].upper();
+
+	QMenuItemListIt it(*mitems);
+	QMenuItem* first = 0;
+	QMenuItem* currentSelected = 0;
+	QMenuItem* firstAfterCurrent = 0;
+
+	register QMenuItem *m;
+	mi = 0;
+	int indx = 0;
+	int clashCount = 0;
+	while ( (m=it.current()) ) {
+	    ++it;
+	    QString s = m->text();
+	    if ( !s.isEmpty() ) {
+		int i = s.find( '&' );
+		while ( i >= 0 && i < (int)s.length() - 1 ) {
+		    if ( s[i+1].upper() == c ) {
+			ok_key = TRUE;
+			clashCount++;
+			if ( !first )
+			    first = m;
+			if ( indx == actItem )
+			    currentSelected = m;
+			else if ( !firstAfterCurrent && currentSelected )
+			    firstAfterCurrent = m;
+			break;
+		    } else if ( s[i+1] == '&' ) {
+			i = s.find( '&', i+2 );
+		    } else {
+			break;
+		    }
+		}
+	    }
+	    if ( mi )
+		break;
+	    indx++;
+	}
+
+	if ( 1 == clashCount ) { // No clashes, continue with selection
+	    mi = first;
+	    popup = mi->popup();
+	    if ( popup ) {
+		setActiveItem( indexOf(mi->id()) );
+		hidePopups();
+		popupSubMenuLater( 20, this );
+		popup->setFirstItemActive();
+	    } else {
+		byeMenuBar();
+#ifndef QT_NO_WHATSTHIS
+		bool b = QWhatsThis::inWhatsThisMode();
+#else
+		const bool b = FALSE;
+#endif
+		if ( mi->isEnabledAndVisible() || b ) {
+		    active_popup_menu = this;
+		    QGuardedPtr<QSignal> signal = mi->signal();
+		    actSig( mi->id(), b );
+		    if ( signal && !b  )
+			signal->activate();
+		    active_popup_menu = 0;
+		}
+	    }
+	} else if ( clashCount > 1 ) { // Clashes, highlight next...
+	    // If there's clashes and no one is selected, use first one
+	    // or if there is no clashes _after_ current, use first one
+	    if ( !currentSelected || (currentSelected && !firstAfterCurrent))
+		dy = indexOf( first->id() ) - actItem;
+	    else
+		dy = indexOf( firstAfterCurrent->id() ) - actItem;
+	}
+    }
+#ifndef QT_NO_MENUBAR
+    if ( !ok_key ) {				// send to menu bar
+	register QMenuData *top = this;		// find top level
+	while ( top->parentMenu )
+	    top = top->parentMenu;
+	if ( top->isMenuBar ) {
+	    int beforeId = top->actItem;
+	    ((QMenuBar*)top)->tryKeyEvent( this, e );
+	    if ( beforeId != top->actItem )
+		ok_key = TRUE;
+	}
+    }
+#endif
+    if ( actItem < 0 ) {
+	if ( dy > 0 ) {
+	    setFirstItemActive();
+	} else if ( dy < 0 ) {
+	    QMenuItemListIt it(*mitems);
+	    it.toLast();
+	    register QMenuItem *mi;
+	    int ai = count() - 1;
+	    while ( (mi=it.current()) ) {
+		--it;
+		if ( !mi->isSeparator() && mi->id() != QMenuData::d->aInt ) {
+		    setActiveItem( ai );
+		    return;
+		}
+		ai--;
+	    }
+	    actItem = -1;
+	}
+	return;
+    }
+
+    if ( dy ) {				// highlight next/prev
+	register int i = actItem;
+	int c = mitems->count();
+	for(int n = c; n; n--) {
+	    i = i + dy;
+	    if(d->scroll.scrollable) {
+		if(d->scroll.scrolltimer)
+		    d->scroll.scrolltimer->stop();
+		if(i < 0)
+		    i = 0;
+		else if(i >= c)
+		    i  = c - 1;
+	    } else {
+		if ( i == c )
+		    i = 0;
+		else if ( i < 0 )
+		    i = c - 1;
+	    }
+	    mi = mitems->at( i );
+	    if ( !mi || !mi->isVisible() )
+		continue;
+
+	    if ( !mi->isSeparator() &&
+		 ( style().styleHint(QStyle::SH_PopupMenu_AllowActiveAndDisabled, this)
+		   || mi->isEnabledAndVisible() ) )
+		break;
+	}
+	if ( i != actItem )
+	    setActiveItem( i );
+	if(d->scroll.scrollable) { //need to scroll to make it visible?
+	    QRect r = itemGeometry(actItem);
+	    if(r.isNull() || r.height() < itemHeight(mitems->at(actItem))) {
+		bool refresh = FALSE;
+		if(d->scroll.scrollable & QPopupMenuPrivate::Scroll::ScrollUp && dy == -1) { //up
+		    if(d->scroll.topScrollableIndex >= 0) {
+			d->scroll.topScrollableIndex--;
+			refresh = TRUE;
+		    }
+		} else if(d->scroll.scrollable & QPopupMenuPrivate::Scroll::ScrollDown) { //down
+		    QMenuItemListIt it(*mitems);
+		    int sh = style().pixelMetric(QStyle::PM_PopupMenuScrollerHeight, this);
+		    for(int i = 0, y = ((d->scroll.scrollable & QPopupMenuPrivate::Scroll::ScrollUp) ? sh : 0); it.current(); i++, ++it) {
+			if(i >= d->scroll.topScrollableIndex) {
+			    int itemh = itemHeight(it.current());
+			    QSize sz = style().sizeFromContents(QStyle::CT_PopupMenuItem, this,
+								QSize(0, itemh),
+								QStyleOption(it.current(),maxPMWidth,0));
+			    y += sz.height();
+			    if(y > (contentsRect().height()-sh)) {
+				if(sz.height() > sh || !it.atLast())
+				    d->scroll.topScrollableIndex++;
+				refresh = TRUE;
+				break;
+			    }
+			}
+		    }
+		}
+		if(refresh) {
+		    updateScrollerState();
+		    update();
+		}
+	    }
+	}
+    }
+
+#ifdef Q_OS_WIN32
+    if ( !ok_key &&
+	!( e->key() == Key_Control || e->key() == Key_Shift || e->key() == Key_Meta ) )
+	qApp->beep();
+#endif // Q_OS_WIN32
+}
+
+
+/*!
+    \reimp
+*/
+
+void QPopupMenu::timerEvent( QTimerEvent *e )
+{
+    QFrame::timerEvent( e );
+}
+
+/*!
+    \reimp
+*/
+void QPopupMenu::leaveEvent( QEvent * )
+{
+    if ( testWFlags( WStyle_Tool ) && style().styleHint(QStyle::SH_PopupMenu_MouseTracking, this) ) {
+	int lastActItem = actItem;
+	actItem = -1;
+	if ( lastActItem >= 0 )
+	    updateRow( lastActItem );
+    }
+}
+
+/*!
+    \reimp
+*/
+void QPopupMenu::styleChange( QStyle& old )
+{
+    QFrame::styleChange( old );
+    setMouseTracking(style().styleHint(QStyle::SH_PopupMenu_MouseTracking, this));
+    style().polishPopupMenu( this );
+    updateSize(TRUE);
+}
+
+/*!\reimp
+ */
+void QPopupMenu::enabledChange( bool )
+{
+    if ( QMenuData::d->aWidget ) // torn-off menu
+	QMenuData::d->aWidget->setEnabled( isEnabled() );
+}
+
+
+/*!
+    If a popup menu does not fit on the screen it lays itself out so
+    that it does fit. It is style dependent what layout means (for
+    example, on Windows it will use multiple columns).
+
+    This functions returns the number of columns necessary.
+
+    \sa sizeHint()
+*/
+int QPopupMenu::columns() const
+{
+    return ncols;
+}
+
+/* This private slot handles the scrolling popupmenu */
+void QPopupMenu::subScrollTimer() {
+    QPoint pos = QCursor::pos();
+    if(!d->scroll.scrollable || !isVisible()) {
+	if(d->scroll.scrolltimer)
+	    d->scroll.scrolltimer->stop();
+	return;
+    } else if(pos.x() > x() + width() || pos.x() < x()) {
+	return;
+    }
+    int sh = style().pixelMetric(QStyle::PM_PopupMenuScrollerHeight, this);
+    if(!d->scroll.lastScroll.isValid()) {
+	d->scroll.lastScroll = QTime::currentTime();
+    } else {
+	int factor=0;
+	if(pos.y() < y())
+	    factor = y() - pos.y();
+	else if(pos.y() > y() + height())
+	    factor = pos.y() - (y() + height());
+	int msecs = 250 - ((factor / 10) * 40);
+	if(d->scroll.lastScroll.msecsTo(QTime::currentTime()) < QMAX(0, msecs))
+	    return;
+	d->scroll.lastScroll = QTime::currentTime();
+    }
+    if(d->scroll.scrollable & QPopupMenuPrivate::Scroll::ScrollUp && pos.y() <= y() + sh) { //up
+	if(d->scroll.topScrollableIndex > 0) {
+	    d->scroll.topScrollableIndex--;
+	    updateScrollerState();
+	    update(contentsRect());
+	}
+    } else if(d->scroll.scrollable & QPopupMenuPrivate::Scroll::ScrollDown &&
+	      pos.y() >= (y() + contentsRect().height()) - sh) { //down
+	QMenuItemListIt it(*mitems);
+	for(int i = 0, y = contentsRect().y() + sh; it.current(); i++, ++it) {
+	    if(i >= d->scroll.topScrollableIndex) {
+		int itemh = itemHeight(it.current());
+		QSize sz = style().sizeFromContents(QStyle::CT_PopupMenuItem, this, QSize(0, itemh),
+						    QStyleOption(it.current(),maxPMWidth,0));
+		y += sz.height();
+		if(y > contentsRect().height() - sh) {
+		    d->scroll.topScrollableIndex++;
+		    updateScrollerState();
+		    update(contentsRect());
+		    break;
+		}
+	    }
+	}
+    }
+}
+
+/* This private slot handles the delayed submenu effects */
+
+void QPopupMenu::subMenuTimer() {
+
+    if ( !isVisible() || (actItem < 0 && popupActive < 0) || actItem == popupActive )
+	return;
+
+    if ( popupActive >= 0 ) {
+	hidePopups();
+	popupActive = -1;
+    }
+
+    // hidePopups() may change actItem etc.
+    if ( !isVisible() || actItem < 0 || actItem == popupActive )
+	return;
+
+    QMenuItem *mi = mitems->at(actItem);
+    if ( !mi || !mi->isEnabledAndVisible() )
+	return;
+
+    QPopupMenu *popup = mi->popup();
+    if ( !popup || !popup->isEnabled() )
+	return;
+
+    //avoid circularity
+    if ( popup->isVisible() )
+	return;
+
+    Q_ASSERT( popup->parentMenu == 0 );
+    popup->parentMenu = this;			// set parent menu
+
+    emit popup->aboutToShow();
+    supressAboutToShow = TRUE;
+
+
+    QRect r( itemGeometry( actItem ) );
+    QPoint p;
+    QSize ps = popup->sizeHint();
+    if( QApplication::reverseLayout() ) {
+	p = QPoint( r.left() + motifArrowHMargin - ps.width(), r.top() + motifArrowVMargin );
+	p = mapToGlobal( p );
+
+	bool right = FALSE;
+	if ( ( parentMenu && parentMenu->isPopupMenu &&
+	       ((QPopupMenu*)parentMenu)->geometry().x() < geometry().x() ) ||
+	     p.x() < 0 )
+	    right = TRUE;
+	if ( right && (ps.width() > QApplication::desktop()->width() - mapToGlobal( r.topRight() ).x() ) )
+	    right = FALSE;
+	if ( right )
+	    p.setX( mapToGlobal( r.topRight() ).x() );
+    } else {
+	p = QPoint( r.right() - motifArrowHMargin, r.top() + motifArrowVMargin );
+	p = mapToGlobal( p );
+
+	bool left = FALSE;
+	if ( ( parentMenu && parentMenu->isPopupMenu &&
+	       ((QPopupMenu*)parentMenu)->geometry().x() > geometry().x() ) ||
+	     p.x() + ps.width() > QApplication::desktop()->width() )
+	    left = TRUE;
+	if ( left && (ps.width() > mapToGlobal( r.topLeft() ).x() ) )
+	    left = FALSE;
+	if ( left )
+	    p.setX( mapToGlobal( r.topLeft() ).x() - ps.width() );
+    }
+    QRect pr = popup->itemGeometry(popup->count() - 1);
+    if (p.y() + ps.height() > QApplication::desktop()->height() &&
+	p.y() - ps.height() + (QCOORD) pr.height() >= 0)
+	p.setY( p.y() - ps.height() + (QCOORD) pr.height());
+
+    if ( style().styleHint(QStyle::SH_PopupMenu_SloppySubMenus, this )) {
+	 QPoint cur = QCursor::pos();
+	 if ( r.contains( mapFromGlobal( cur ) ) ) {
+	     QPoint pts[4];
+	     pts[0] = QPoint( cur.x(), cur.y() - 2 );
+	     pts[3] = QPoint( cur.x(), cur.y() + 2 );
+	     if ( p.x() >= cur.x() )	{
+		 pts[1] = QPoint( geometry().right(), p.y() );
+		 pts[2] = QPoint( geometry().right(), p.y() + ps.height() );
+	     } else {
+		 pts[1] = QPoint( p.x() + ps.width(), p.y() );
+		 pts[2] = QPoint( p.x() + ps.width(), p.y() + ps.height() );
+	     }
+	     QPointArray points( 4 );
+	     for( int i = 0; i < 4; i++ )
+		 points.setPoint( i, mapFromGlobal( pts[i] ) );
+	     d->mouseMoveBuffer = QRegion( points );
+	     repaint();
+	 }
+    }
+
+    popupActive = actItem;
+    popup->popup( p );
+}
+
+void QPopupMenu::allowAnimation()
+{
+    preventAnimation = FALSE;
+}
+
+void QPopupMenu::updateRow( int row )
+{
+    if ( !isVisible() )
+	return;
+
+    if ( badSize ) {
+	updateSize();
+	update();
+	return;
+    }
+    updateSize();
+    QRect r = itemGeometry( row );
+    if ( !r.isNull() ) // can happen via the scroller
+	repaint( r );
+}
+
+
+/*!
+    \overload
+
+    Executes this popup synchronously.
+
+    Opens the popup menu so that the item number \a indexAtPoint will
+    be at the specified \e global position \a pos. To translate a
+    widget's local coordinates into global coordinates, use
+    QWidget::mapToGlobal().
+
+    The return code is the id of the selected item in either the popup
+    menu or one of its submenus, or -1 if no item is selected
+    (normally because the user pressed Esc).
+
+    Note that all signals are emitted as usual. If you connect a menu
+    item to a slot and call the menu's exec(), you get the result both
+    via the signal-slot connection and in the return value of exec().
+
+    Common usage is to position the popup at the current mouse
+    position:
+    \code
+	exec( QCursor::pos() );
+    \endcode
+    or aligned to a widget:
+    \code
+	exec( somewidget.mapToGlobal(QPoint(0, 0)) );
+    \endcode
+
+    When positioning a popup with exec() or popup(), bear in mind that
+    you cannot rely on the popup menu's current size(). For
+    performance reasons, the popup adapts its size only when
+    necessary. So in many cases, the size before and after the show is
+    different. Instead, use sizeHint(). It calculates the proper size
+    depending on the menu's current contents.
+
+    \sa popup(), sizeHint()
+*/
+
+int QPopupMenu::exec( const QPoint & pos, int indexAtPoint )
+{
+    snapToMouse = TRUE;
+    if ( !qApp )
+	return -1;
+
+    QPopupMenu* priorSyncMenu = syncMenu;
+
+    syncMenu = this;
+    syncMenuId = -1;
+
+    QGuardedPtr<QPopupMenu> that = this;
+    connectModal( that, TRUE );
+    popup( pos, indexAtPoint );
+    qApp->enter_loop();
+    connectModal( that, FALSE );
+
+    syncMenu = priorSyncMenu;
+    return syncMenuId;
+}
+
+
+
+/*
+  Connect the popup and all its submenus to modalActivation() if
+  \a doConnect is true, otherwise disconnect.
+ */
+void QPopupMenu::connectModal( QPopupMenu* receiver, bool doConnect )
+{
+    if ( !receiver )
+	return;
+
+    connectModalRecursionSafety = doConnect;
+
+    if ( doConnect )
+	connect( this, SIGNAL(activated(int)),
+		 receiver, SLOT(modalActivation(int)) );
+    else
+	disconnect( this, SIGNAL(activated(int)),
+		    receiver, SLOT(modalActivation(int)) );
+
+    QMenuItemListIt it(*mitems);
+    register QMenuItem *mi;
+    while ( (mi=it.current()) ) {
+	++it;
+	if ( mi->popup() && mi->popup() != receiver
+	     && (bool)(mi->popup()->connectModalRecursionSafety) != doConnect )
+	    mi->popup()->connectModal( receiver, doConnect ); //avoid circular
+    }
+}
+
+
+/*!
+    Executes this popup synchronously.
+
+    This is equivalent to \c{exec(mapToGlobal(QPoint(0,0)))}. In most
+    situations you'll want to specify the position yourself, for
+    example at the current mouse position:
+    \code
+	exec(QCursor::pos());
+    \endcode
+    or aligned to a widget:
+    \code
+	exec(somewidget.mapToGlobal(QPoint(0,0)));
+    \endcode
+*/
+
+int QPopupMenu::exec()
+{
+    return exec(mapToGlobal(QPoint(0,0)));
+}
+
+
+/*  Internal slot used for exec(). */
+
+void QPopupMenu::modalActivation( int id )
+{
+    syncMenuId = id;
+}
+
+
+/*!
+    Sets the currently active item to index \a i and repaints as necessary.
+*/
+
+void QPopupMenu::setActiveItem( int i )
+{
+    int lastActItem = actItem;
+    actItem = i;
+    if ( lastActItem >= 0 )
+	updateRow( lastActItem );
+    if ( i >= 0 && i != lastActItem )
+	updateRow( i );
+    QMenuItem *mi = mitems->at( actItem );
+    if ( !mi )
+	return;
+
+    if ( mi->widget() && mi->widget()->isFocusEnabled() ) {
+	mi->widget()->setFocus();
+    } else {
+	setFocus();
+	QRect mfrect = itemGeometry( actItem );
+	setMicroFocusHint( mfrect.x(), mfrect.y(), mfrect.width(), mfrect.height(), FALSE );
+    }
+    if ( mi->id() != -1 )
+	hilitSig( mi->id() );
+#ifndef QT_NO_WHATSTHIS
+    if (whatsThisItem && whatsThisItem != mi) {
+	qWhatsThisBDH();
+    }
+    whatsThisItem = mi;
+#endif
+}
+
+
+/*!
+    \reimp
+*/
+QSize QPopupMenu::sizeHint() const
+{
+    constPolish();
+    QPopupMenu* that = (QPopupMenu*) this;
+    //We do not need a resize here, just the sizeHint..
+    return that->updateSize(FALSE, FALSE).expandedTo( QApplication::globalStrut() );
+}
+
+
+/*!
+    \overload
+
+    Returns the id of the item at \a pos, or -1 if there is no item
+    there or if it is a separator.
+*/
+int QPopupMenu::idAt( const QPoint& pos ) const
+{
+    return idAt( itemAtPos( pos ) );
+}
+
+
+/*!
+    \fn int QPopupMenu::idAt( int index ) const
+
+    Returns the identifier of the menu item at position \a index in
+    the internal list, or -1 if \a index is out of range.
+
+    \sa QMenuData::setId(), QMenuData::indexOf()
+*/
+
+
+/*!
+    \reimp
+ */
+bool QPopupMenu::customWhatsThis() const
+{
+    return TRUE;
+}
+
+
+/*!
+    \reimp
+ */
+bool QPopupMenu::focusNextPrevChild( bool next )
+{
+    register QMenuItem *mi;
+    int dy = next? 1 : -1;
+    if ( dy && actItem < 0 ) {
+	setFirstItemActive();
+    } else if ( dy ) {				// highlight next/prev
+	register int i = actItem;
+	int c = mitems->count();
+	int n = c;
+	while ( n-- ) {
+	    i = i + dy;
+	    if ( i == c )
+		i = 0;
+	    else if ( i < 0 )
+		i = c - 1;
+	    mi = mitems->at( i );
+	    if ( mi && !mi->isSeparator() &&
+		 ( style().styleHint(QStyle::SH_PopupMenu_AllowActiveAndDisabled, this)
+		   || mi->isEnabledAndVisible() ) )
+		break;
+	}
+	if ( i != actItem )
+	    setActiveItem( i );
+    }
+    return TRUE;
+}
+
+
+/*!
+    \reimp
+ */
+void QPopupMenu::focusInEvent( QFocusEvent * )
+{
+}
+
+/*!
+    \reimp
+ */
+void QPopupMenu::focusOutEvent( QFocusEvent * )
+{
+}
+
+
+class QTearOffMenuItem : public QCustomMenuItem
+{
+public:
+    QTearOffMenuItem()
+    {
+    }
+    ~QTearOffMenuItem()
+    {
+    }
+    void paint( QPainter* p, const QColorGroup& cg, bool /* act*/,
+		bool /*enabled*/, int x, int y, int w, int h )
+    {
+	p->setPen( QPen( cg.dark(), 1, DashLine ) );
+	p->drawLine( x+2, y+h/2-1, x+w-4, y+h/2-1 );
+	p->setPen( QPen( cg.light(), 1, DashLine ) );
+	p->drawLine( x+2, y+h/2, x+w-4, y+h/2 );
+    }
+    bool fullSpan() const
+    {
+	return TRUE;
+    }
+
+    QSize sizeHint()
+    {
+	return QSize( 20, 6 );
+    }
+};
+
+
+
+/*!
+    Inserts a tear-off handle into the menu. A tear-off handle is a
+    special menu item that creates a copy of the menu when the menu is
+    selected. This "torn-off" copy lives in a separate window. It
+    contains the same menu items as the original menu, with the
+    exception of the tear-off handle.
+
+    The handle item is assigned the identifier \a id or an
+    automatically generated identifier if \a id is < 0. The generated
+    identifiers (negative integers) are guaranteed to be unique within
+    the entire application.
+
+    The \a index specifies the position in the menu. The tear-off
+    handle is appended at the end of the list if \a index is negative.
+*/
+int QPopupMenu::insertTearOffHandle( int id, int index )
+{
+    int myid = insertItem( new QTearOffMenuItem, id, index );
+    connectItem( myid, this, SLOT( toggleTearOff() ) );
+    QMenuData::d->aInt = myid;
+    return myid;
+}
+
+
+/*!\internal
+
+  implements tear-off menus
+ */
+void QPopupMenu::toggleTearOff()
+{
+    if ( active_popup_menu && active_popup_menu->tornOff ) {
+	active_popup_menu->close();
+    } else  if (QMenuData::d->aWidget ) {
+	delete (QWidget*) QMenuData::d->aWidget; // delete the old one
+    } else {
+	// create a tear off menu
+	QPopupMenu* p = new QPopupMenu( parentWidget(), "tear off menu" );
+	connect( p, SIGNAL( activated(int) ), this, SIGNAL( activated(int) ) );
+#ifndef QT_NO_WIDGET_TOPEXTRA
+	p->setCaption( caption() );
+#endif
+	p->setCheckable( isCheckable() );
+	p->reparent( parentWidget(), WType_TopLevel | WStyle_Tool |
+		     WNoAutoErase | WDestructiveClose,
+		     geometry().topLeft(), FALSE );
+	p->mitems->setAutoDelete( FALSE );
+	p->tornOff = TRUE;
+	for ( QMenuItemListIt it( *mitems ); it.current(); ++it ) {
+	    if ( it.current()->id() != QMenuData::d->aInt && !it.current()->widget() )
+		p->mitems->append( it.current() );
+	}
+	p->show();
+	QMenuData::d->aWidget = p;
+    }
+}
+
+/*!
+    \reimp
+ */
+void QPopupMenu::activateItemAt( int index )
+{
+    if ( index >= 0 && index < (int) mitems->count() ) {
+	QMenuItem *mi = mitems->at( index );
+	if ( index != actItem )			// new item activated
+	    setActiveItem( index );
+	QPopupMenu *popup = mi->popup();
+	if ( popup ) {
+	    if ( popup->isVisible() ) {		// sub menu already open
+		int pactItem = popup->actItem;
+		popup->actItem = -1;
+		popup->hidePopups();
+		popup->updateRow( pactItem );
+	    } else {				// open sub menu
+		hidePopups();
+		actItem = index;
+		subMenuTimer();
+		popup->setFirstItemActive();
+	    }
+	} else {
+	    byeMenuBar();			// deactivate menu bar
+
+#ifndef QT_NO_WHATSTHIS
+	    bool b = QWhatsThis::inWhatsThisMode();
+#else
+	    const bool b = FALSE;
+#endif
+	    if ( !mi->isEnabledAndVisible() ) {
+#ifndef QT_NO_WHATSTHIS
+		if ( b ) {
+		    actItem = -1;
+		    updateItem( mi->id() );
+		    byeMenuBar();
+		    actSig( mi->id(), b);
+		}
+#endif
+	    } else {
+		byeMenuBar();			// deactivate menu bar
+		if ( mi->isEnabledAndVisible() ) {
+		    actItem = -1;
+		    updateItem( mi->id() );
+		    active_popup_menu = this;
+		    QGuardedPtr<QSignal> signal = mi->signal();
+		    actSig( mi->id(), b );
+		    if ( signal && !b )
+			signal->activate();
+		    active_popup_menu = 0;
+		}
+	    }
+	}
+    } else {
+	if ( tornOff ) {
+	    close();
+	} else {
+	    QMenuData* p = parentMenu;
+	    hide();
+#ifndef QT_NO_MENUBAR
+	    if ( p && p->isMenuBar )
+		((QMenuBar*) p)->goodbye( TRUE );
+#endif
+	}
+    }
+
+}
+
+/*! \internal
+  This private function is to update the scroll states in styles that support scrolling. */
+void
+QPopupMenu::updateScrollerState()
+{
+    uint old_scrollable = d->scroll.scrollable;
+    d->scroll.scrollable = QPopupMenuPrivate::Scroll::ScrollNone;
+    if(!style().styleHint(QStyle::SH_PopupMenu_Scrollable, this))
+	return;
+
+    QMenuItem *mi;
+    QMenuItemListIt it( *mitems );
+    if(d->scroll.topScrollableIndex) {
+	for(int row = 0; (mi = it.current()) && row < d->scroll.topScrollableIndex; row++)
+	    ++it;
+	if(!mi)
+	    it.toFirst();
+    }
+    int y = 0, sh = style().pixelMetric(QStyle::PM_PopupMenuScrollerHeight, this);
+    if(!it.atFirst()) {
+	// can't use |= because of a bug/feature in IBM xlC 5.0.2
+	d->scroll.scrollable = d->scroll.scrollable | QPopupMenuPrivate::Scroll::ScrollUp;
+	y += sh;
+    }
+    while ( (mi=it.current()) ) {
+	++it;
+	int myheight = contentsRect().height();
+	QSize sz = style().sizeFromContents(QStyle::CT_PopupMenuItem, this,
+					    QSize(0, itemHeight( mi )),
+					    QStyleOption(mi,maxPMWidth));
+	if(y + sz.height() >= myheight) {
+	    d->scroll.scrollable = d->scroll.scrollable | QPopupMenuPrivate::Scroll::ScrollDown;
+	    break;
+	}
+	y += sz.height();
+    }
+    if((d->scroll.scrollable & QPopupMenuPrivate::Scroll::ScrollUp) &&
+       !(old_scrollable & QPopupMenuPrivate::Scroll::ScrollUp))
+	d->scroll.topScrollableIndex++;
+}
+
+#endif // QT_NO_POPUPMENU
+
diff -Nru qt-x11-free-3.3.3.orig/src/widgets/qprogressbar.cpp qt-x11-free-3.3.3/src/widgets/qprogressbar.cpp
--- qt-x11-free-3.3.3.orig/src/widgets/qprogressbar.cpp	2004-08-22 13:20:57.520937532 +0200
+++ qt-x11-free-3.3.3/src/widgets/qprogressbar.cpp	2004-08-22 13:23:33.153502888 +0200
@@ -47,6 +47,14 @@
 #endif
 #include <limits.h>
 
+class QProgressBarPrivate
+{
+    public:
+	QProgressBarPrivate() : last_painted_progress( 0 ) { }
+
+    int last_painted_progress;
+};
+
 /*!
     \class QProgressBar qprogressbar.h
     \brief The QProgressBar widget provides a horizontal progress bar.
@@ -99,7 +107,7 @@
       center_indicator( TRUE ),
       auto_indicator( TRUE ),
       percentage_visible( TRUE ),
-      d( 0 )
+      d( new QProgressBarPrivate )
 {
     setSizePolicy( QSizePolicy( QSizePolicy::Expanding, QSizePolicy::Fixed ) );
     initFrame();
@@ -130,12 +138,20 @@
       center_indicator( TRUE ),
       auto_indicator( TRUE ),
       percentage_visible( TRUE ),
-      d( 0 )
+      d( new QProgressBarPrivate )
 {
     setSizePolicy( QSizePolicy( QSizePolicy::Expanding, QSizePolicy::Fixed ) );
     initFrame();
 }
 
+/*!
+    Destroys the object and frees any allocated ressources.
+*/
+
+QProgressBar::~QProgressBar()
+{
+    delete d;
+}
 
 /*!
     Reset the progress bar. The progress bar "rewinds" and shows no
@@ -188,11 +204,16 @@
 	 progress < 0 || ( ( progress > total_steps ) && total_steps ) )
 	return;
 
+    const bool needRepaint = isVisible() && requireRepaint( progress );
+
     progress_val = progress;
 
     setIndicator( progress_str, progress_val, total_steps );
 
-    repaint( FALSE );
+    if ( needRepaint ) {
+	repaint( FALSE );
+	d->last_painted_progress = progress;
+    }
 
 #if defined(QT_ACCESSIBILITY_SUPPORT)
     QAccessible::updateAccessibility( this, 0, QAccessible::ValueChanged );
@@ -318,6 +339,31 @@
     QFrame::styleChange( old );
 }
 
+/*!
+    This method returns whether changing the progress to the \a newValue
+    would require a repaint of the progress bar. This allows efficient
+    repainting.
+*/
+bool QProgressBar::requireRepaint( int newProgress ) const
+{
+    if ( newProgress == progress_val ||
+	 newProgress == d->last_painted_progress ) {
+	return false;
+    }
+
+    const int width = contentsRect().width();
+    if ( width == 0 ) {
+	return false;
+    }
+
+    float progressPerPixel = 1.0;
+    if ( total_steps > width ) {
+	progressPerPixel = float( total_steps ) / float( width );
+    }
+
+    const int delta = d->last_painted_progress - newProgress;
+    return QABS( delta ) >= progressPerPixel;
+}
 
 /*!
     This method is called to generate the text displayed in the center
diff -Nru qt-x11-free-3.3.3.orig/src/widgets/qprogressbar.h qt-x11-free-3.3.3/src/widgets/qprogressbar.h
--- qt-x11-free-3.3.3.orig/src/widgets/qprogressbar.h	2004-08-22 13:20:57.524936774 +0200
+++ qt-x11-free-3.3.3/src/widgets/qprogressbar.h	2004-08-22 13:23:33.151503266 +0200
@@ -61,6 +61,7 @@
 public:
     QProgressBar( QWidget* parent=0, const char* name=0, WFlags f=0 );
     QProgressBar( int totalSteps, QWidget* parent=0, const char* name=0, WFlags f=0 );
+    virtual ~QProgressBar();
 
     int		totalSteps() const;
     int		progress()   const;
@@ -91,6 +92,7 @@
     virtual bool setIndicator( QString & progress_str, int progress,
 			       int totalSteps );
     void styleChange( QStyle& );
+    bool	requireRepaint( int newProgress ) const;
 
 private:
     int		total_steps;
diff -Nru qt-x11-free-3.3.3.orig/src/widgets/qscrollview.cpp qt-x11-free-3.3.3/src/widgets/qscrollview.cpp
--- qt-x11-free-3.3.3.orig/src/widgets/qscrollview.cpp	2004-08-22 13:20:57.527936207 +0200
+++ qt-x11-free-3.3.3/src/widgets/qscrollview.cpp	2004-08-22 13:23:53.009751790 +0200
@@ -1551,6 +1551,9 @@
         case QEvent::LayoutHint:
             d->autoResizeHint(this);
             break;
+        case QEvent::WindowActivate:
+        case QEvent::WindowDeactivate:
+            return TRUE;
         default:
             break;
         }
diff -Nru qt-x11-free-3.3.3.orig/src/widgets/qtoolbar.cpp qt-x11-free-3.3.3/src/widgets/qtoolbar.cpp
--- qt-x11-free-3.3.3.orig/src/widgets/qtoolbar.cpp	2004-08-22 13:20:57.478945482 +0200
+++ qt-x11-free-3.3.3/src/widgets/qtoolbar.cpp	2004-08-22 13:24:26.202483287 +0200
@@ -648,7 +648,7 @@
 	        QString s = b->textLabel();
 	        if ( s.isEmpty() )
 		    s = b->text();
-	        if ( b->popup() && b->popupDelay() == 0 )
+	        if ( b->popup() && b->popupDelay() <= 0 )
 		    id = d->extensionPopup->insertItem( b->iconSet(), s, b->popup() );
 		else
 		    id = d->extensionPopup->insertItem( b->iconSet(), s, b, SLOT( emulateClick() ) ) ;
diff -Nru qt-x11-free-3.3.3.orig/tools/designer/designer/hierarchyview.cpp qt-x11-free-3.3.3/tools/designer/designer/hierarchyview.cpp
--- qt-x11-free-3.3.3.orig/tools/designer/designer/hierarchyview.cpp	2004-08-22 13:20:57.786887179 +0200
+++ qt-x11-free-3.3.3/tools/designer/designer/hierarchyview.cpp	2004-08-22 13:23:07.033438719 +0200
@@ -605,6 +605,7 @@
 		    formWindow->mainWindow()->setupTabWidgetHierarchyMenu(
 				  this, SLOT( addTabPage() ),
 				  SLOT( removeTabPage() ) );
+	    tabWidgetMenu->setItemEnabled(MainWindow::POPUP_REMOVE_PAGE_ID, ((QDesignerTabWidget*)w )->count() > 1);
 	    tabWidgetMenu->popup( p );
 	}
     }
diff -Nru qt-x11-free-3.3.3.orig/tools/designer/designer/hierarchyview.cpp~ qt-x11-free-3.3.3/tools/designer/designer/hierarchyview.cpp~
--- qt-x11-free-3.3.3.orig/tools/designer/designer/hierarchyview.cpp~	1970-01-01 01:00:00.000000000 +0100
+++ qt-x11-free-3.3.3/tools/designer/designer/hierarchyview.cpp~	2003-12-05 13:47:56.000000000 +0100
@@ -0,0 +1,1493 @@
+/**********************************************************************
+** Copyright (C) 2000-2001 Trolltech AS.  All rights reserved.
+**
+** This file is part of Qt Designer.
+**
+** This file may be distributed and/or modified under the terms of the
+** GNU General Public License version 2 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.
+**
+** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
+** licenses may use this file in accordance with the Qt Commercial License
+** Agreement provided with the Software.
+**
+** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+**
+** See http://www.trolltech.com/gpl/ for GPL licensing information.
+** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
+**   information about Qt Commercial License Agreements.
+**
+** Contact info@trolltech.com if any conditions of this licensing are
+** not clear to you.
+**
+**********************************************************************/
+
+#include "hierarchyview.h"
+#include "formwindow.h"
+#include "globaldefs.h"
+#include "mainwindow.h"
+#include "command.h"
+#include "widgetfactory.h"
+#include "widgetdatabase.h"
+#include "project.h"
+#include "sourceeditor.h"
+#include "propertyeditor.h"
+#include "editfunctionsimpl.h"
+#include "listeditor.h"
+#include "actiondnd.h"
+#include "actioneditorimpl.h"
+#include "variabledialogimpl.h"
+#include "popupmenueditor.h"
+#include "menubareditor.h"
+
+#include <qpalette.h>
+#include <qobjectlist.h>
+#include <qheader.h>
+#include <qpopupmenu.h>
+#include <qtabwidget.h>
+#include <qwizard.h>
+#include <qwidgetstack.h>
+#include <qtabbar.h>
+#include <qfeatures.h>
+#include <qapplication.h>
+#include <qtimer.h>
+#include "../interfaces/languageinterface.h"
+#include <qworkspace.h>
+#include <qaccel.h>
+#include <qmessagebox.h>
+
+#include <stdlib.h>
+
+QListViewItem *newItem = 0;
+
+static QPluginManager<ClassBrowserInterface> *classBrowserInterfaceManager = 0;
+
+HierarchyItem::HierarchyItem( Type type, QListViewItem *parent, QListViewItem *after,
+			      const QString &txt1, const QString &txt2, const QString &txt3 )
+    : QListViewItem( parent, after, txt1, txt2, txt3 ), typ( type )
+{
+}
+
+HierarchyItem::HierarchyItem( Type type, QListView *parent, QListViewItem *after,
+			      const QString &txt1, const QString &txt2, const QString &txt3 )
+    : QListViewItem( parent, after, txt1, txt2, txt3 ), typ( type )
+{
+}
+
+void HierarchyItem::paintCell( QPainter *p, const QColorGroup &cg, int column, int width, int align )
+{
+    QColorGroup g( cg );
+    g.setColor( QColorGroup::Base, backgroundColor() );
+    g.setColor( QColorGroup::Foreground, Qt::black );
+    g.setColor( QColorGroup::Text, Qt::black );
+    QString txt = text( 0 );
+    if ( rtti() == Function &&
+	 MainWindow::self->currProject()->isCpp() &&
+	 ( txt == "init()" || txt == "destroy()" ) ) {
+	listView()->setUpdatesEnabled( FALSE );
+	if ( txt == "init()" )
+	    setText( 0, txt + " " + "(Constructor)" );
+	else
+	    setText( 0, txt + " " + "(Destructor)" );
+	QListViewItem::paintCell( p, g, column, width, align );
+	setText( 0, txt );
+	listView()->setUpdatesEnabled( TRUE );
+    } else {
+	QListViewItem::paintCell( p, g, column, width, align );
+    }
+    p->save();
+    p->setPen( QPen( cg.dark(), 1 ) );
+    if ( column == 0 )
+	p->drawLine( 0, 0, 0, height() - 1 );
+    if ( listView()->firstChild() != this ) {
+	if ( nextSibling() != itemBelow() && itemBelow()->depth() < depth() ) {
+	    int d = depth() - itemBelow()->depth();
+	    p->drawLine( -listView()->treeStepSize() * d, height() - 1, 0, height() - 1 );
+	}
+    }
+    p->drawLine( 0, height() - 1, width, height() - 1 );
+    p->drawLine( width - 1, 0, width - 1, height() );
+    p->restore();
+}
+
+QColor HierarchyItem::backgroundColor()
+{
+    updateBackColor();
+    return backColor;
+}
+
+void HierarchyItem::updateBackColor()
+{
+    if ( listView()->firstChild() == this ) {
+	backColor = *backColor1;
+	return;
+    }
+
+    QListViewItemIterator it( this );
+    --it;
+    if ( it.current() ) {
+	if ( ( ( HierarchyItem*)it.current() )->backColor == *backColor1 )
+	    backColor = *backColor2;
+	else
+	    backColor = *backColor1;
+    } else {
+	backColor = *backColor1;
+    }
+}
+
+void HierarchyItem::setObject( QObject *o )
+{
+    obj = o;
+}
+
+QObject *HierarchyItem::object() const
+{
+    return obj;
+}
+
+void HierarchyItem::okRename( int col )
+{
+    if ( newItem == this )
+	newItem = 0;
+    QListViewItem::okRename( col );
+}
+
+void HierarchyItem::cancelRename( int col )
+{
+    if ( newItem == this ) {
+	newItem = 0;
+	QListViewItem::cancelRename( col );
+	delete this;
+	return;
+    }
+    QListViewItem::cancelRename( col );
+}
+
+
+
+
+HierarchyList::HierarchyList( QWidget *parent, FormWindow *fw, bool doConnects )
+    : QListView( parent ), formWindow( fw )
+{
+    init_colors();
+
+    setDefaultRenameAction( Accept );
+    header()->setMovingEnabled( FALSE );
+    header()->setStretchEnabled( TRUE );
+    normalMenu = 0;
+    tabWidgetMenu = 0;
+    addColumn( tr( "Name" ) );
+    addColumn( tr( "Class" ) );
+    QPalette p( palette() );
+    p.setColor( QColorGroup::Base, QColor( *backColor2 ) );
+    (void)*selectedBack; // hack
+    setPalette( p );
+    disconnect( header(), SIGNAL( sectionClicked( int ) ),
+		this, SLOT( changeSortColumn( int ) ) );
+    setSorting( -1 );
+    setHScrollBarMode( AlwaysOff );
+    setVScrollBarMode( AlwaysOn );
+    if ( doConnects ) {
+	connect( this, SIGNAL( clicked( QListViewItem * ) ),
+		 this, SLOT( objectClicked( QListViewItem * ) ) );
+	connect( this, SIGNAL( doubleClicked( QListViewItem * ) ),
+		 this, SLOT( objectDoubleClicked( QListViewItem * ) ) );
+	connect( this, SIGNAL( returnPressed( QListViewItem * ) ),
+		 this, SLOT( objectClicked( QListViewItem * ) ) );
+	connect( this, SIGNAL( contextMenuRequested( QListViewItem *, const QPoint&, int ) ),
+		 this, SLOT( showRMBMenu( QListViewItem *, const QPoint & ) ) );
+    }
+    deselect = TRUE;
+    setColumnWidthMode( 1, Manual );
+}
+
+void HierarchyList::keyPressEvent( QKeyEvent *e )
+{
+    if ( e->key() == Key_Shift || e->key() == Key_Control )
+	deselect = FALSE;
+    else
+	deselect = TRUE;
+    QListView::keyPressEvent( e );
+}
+
+void HierarchyList::keyReleaseEvent( QKeyEvent *e )
+{
+    deselect = TRUE;
+    QListView::keyReleaseEvent( e );
+}
+
+void HierarchyList::viewportMousePressEvent( QMouseEvent *e )
+{
+    if ( e->state() & ShiftButton || e->state() & ControlButton )
+	deselect = FALSE;
+    else
+	deselect = TRUE;
+    QListView::viewportMousePressEvent( e );
+}
+
+void HierarchyList::viewportMouseReleaseEvent( QMouseEvent *e )
+{
+    QListView::viewportMouseReleaseEvent( e );
+}
+
+QObject *HierarchyList::handleObjectClick( QListViewItem *i )
+{
+    if ( !i )
+	return 0;
+
+    QObject *o = findObject( i );
+    if ( !o )
+	return 0;
+    if ( formWindow == o ) {
+	if ( deselect )
+	    formWindow->clearSelection( FALSE );
+	formWindow->emitShowProperties( formWindow );
+	return 0;
+    }
+    if ( o->isWidgetType() ) {
+	QWidget *w = (QWidget*)o;
+	if ( !formWindow->widgets()->find( w ) ) {
+	    if ( ::qt_cast<QWidgetStack*>(w->parent()) ) {
+		if (::qt_cast<QTabWidget*>(w->parent()->parent()) ) {
+		    ((QTabWidget*)w->parent()->parent())->showPage( w );
+		    o = (QWidget*)w->parent()->parent();
+		    formWindow->emitUpdateProperties( formWindow->currentWidget() );
+		} else if ( ::qt_cast<QWizard*>(w->parent()->parent()) ) {
+		    ((QDesignerWizard*)w->parent()->parent())->
+			setCurrentPage( ( (QDesignerWizard*)w->parent()->parent() )->pageNum( w ) );
+		    o = (QWidget*)w->parent()->parent();
+		    formWindow->emitUpdateProperties( formWindow->currentWidget() );
+		} else {
+		    ( (QWidgetStack*)w->parent() )->raiseWidget( w );
+		    if ( (QWidgetStack*)w->parent()->isA( "QDesignerWidgetStack" ) )
+			( (QDesignerWidgetStack*)w->parent() )->updateButtons();
+		}
+	    } else if ( ::qt_cast<QMenuBar*>(w) || ::qt_cast<QDockWindow*>(w) ) {
+		formWindow->setActiveObject( w );
+	    } else if ( ::qt_cast<QPopupMenu*>(w) ) {
+		return 0; // ### we could try to find our menu bar and change the currentMenu to our index
+	    } else {
+		return 0;
+	    }
+	}
+    } else if ( ::qt_cast<QAction*>(o) ) {
+	MainWindow::self->actioneditor()->setCurrentAction( (QAction*)o );
+	deselect = TRUE;
+    }
+
+    if ( deselect )
+	formWindow->clearSelection( FALSE );
+
+    return o;
+}
+
+
+void HierarchyList::objectDoubleClicked( QListViewItem *i )
+{
+    QObject *o = handleObjectClick( i );
+    if ( !o )
+	return;
+    if ( o->isWidgetType() && ( (QWidget*)o )->isVisibleTo( formWindow ) ) {
+	QWidget *w = (QWidget*)o;
+	if ( !w->parentWidget() ||
+	     WidgetFactory::layoutType( w->parentWidget() ) == WidgetFactory::NoLayout )
+	    w->raise();
+	formWindow->selectWidget( w, TRUE );
+    }
+}
+
+void HierarchyList::objectClicked( QListViewItem *i )
+{
+    QObject *o = handleObjectClick( i );
+    if ( !o )
+	return;
+    if ( o->isWidgetType() && ( (QWidget*)o )->isVisibleTo( formWindow ) ) {
+	QWidget *w = (QWidget*)o;
+	formWindow->selectWidget( w, TRUE );
+    }
+}
+
+QObject *HierarchyList::findObject( QListViewItem *i )
+{
+    return ( (HierarchyItem*)i )->object();
+}
+
+QListViewItem *HierarchyList::findItem( QObject *o )
+{
+    QListViewItemIterator it( this );
+    while ( it.current() ) {
+	if ( ( (HierarchyItem*)it.current() )->object() == o )
+	    return it.current();
+	++it;
+    }
+    return 0;
+}
+
+QObject *HierarchyList::current() const
+{
+    if ( currentItem() )
+	return ( (HierarchyItem*)currentItem() )->object();
+    return 0;
+}
+
+void HierarchyList::changeNameOf( QObject *o, const QString &name )
+{
+    QListViewItem *item = findItem( o );
+    if ( !item )
+	return;
+    item->setText( 0, name );
+}
+
+
+void HierarchyList::changeDatabaseOf( QObject *o, const QString &info )
+{
+#ifndef QT_NO_SQL
+    if ( !formWindow->isDatabaseAware() )
+	return;
+    QListViewItem *item = findItem( o );
+    if ( !item )
+	return;
+    item->setText( 2, info );
+#endif
+}
+
+static QPtrList<QWidgetStack> *widgetStacks = 0;
+
+void HierarchyList::setup()
+{
+    if ( !formWindow || formWindow->isFake() )
+	return;
+    clear();
+    QWidget *w = formWindow->mainContainer();
+#ifndef QT_NO_SQL
+    if ( formWindow->isDatabaseAware() ) {
+	if ( columns() == 2 ) {
+	    addColumn( tr( "Database" ) );
+	    header()->resizeSection( 0, 1 );
+	    header()->resizeSection( 1, 1 );
+	    header()->resizeSection( 2, 1 );
+	    header()->adjustHeaderSize();
+	}
+    } else {
+	if ( columns() == 3 ) {
+	    removeColumn( 2 );
+	}
+    }
+#endif
+    if ( !widgetStacks )
+	widgetStacks = new QPtrList<QWidgetStack>;
+    if ( w )
+	insertObject( w, 0 );
+    widgetStacks->clear();
+}
+
+void HierarchyList::setOpen( QListViewItem *i, bool b )
+{
+    QListView::setOpen( i, b );
+}
+
+void HierarchyList::insertObject( QObject *o, QListViewItem *parent )
+{
+    if ( QString( o->name() ).startsWith( "qt_dead_widget_" ) )
+	return;
+    bool fakeMainWindow = FALSE;
+    if ( ::qt_cast<QMainWindow*>(o) ) {
+	QObject *cw = ( (QMainWindow*)o )->centralWidget();
+	if ( cw ) {
+	    o = cw;
+	    fakeMainWindow = TRUE;
+	}
+    }
+    QListViewItem *item = 0;
+    QString className = WidgetFactory::classNameOf( o );
+    if ( ::qt_cast<QLayoutWidget*>(o) ) {
+	switch ( WidgetFactory::layoutType( (QWidget*)o ) ) {
+	case WidgetFactory::HBox:
+	    className = "HBox";
+	    break;
+	case WidgetFactory::VBox:
+	    className = "VBox";
+	    break;
+	case WidgetFactory::Grid:
+	    className = "Grid";
+	    break;
+	default:
+	    break;
+	}
+    }
+
+    QString dbInfo;
+#ifndef QT_NO_SQL
+    dbInfo = MetaDataBase::fakeProperty( o, "database" ).toStringList().join(".");
+#endif
+
+    QString name = o->name();
+    if ( ::qt_cast<QWidgetStack*>(o->parent()) ) {
+	if ( ::qt_cast<QTabWidget*>(o->parent()->parent()) )
+	    name = ( (QTabWidget*)o->parent()->parent() )->tabLabel( (QWidget*)o );
+	else if ( ::qt_cast<QWizard*>(o->parent()->parent()) )
+	    name = ( (QWizard*)o->parent()->parent() )->title( (QWidget*)o );
+    }
+
+    QToolBox *tb;
+    if ( o->parent() && o->parent()->parent() &&
+	 (tb = ::qt_cast<QToolBox*>(o->parent()->parent()->parent())) )
+	name = tb->itemLabel( tb->indexOf((QWidget*)o) );
+
+    if ( fakeMainWindow ) {
+	name = o->parent()->name();
+	className = "QMainWindow";
+    }
+
+    if ( !parent )
+	item = new HierarchyItem( HierarchyItem::Widget, this, 0, name, className, dbInfo );
+    else
+	item = new HierarchyItem( HierarchyItem::Widget, parent, 0, name, className, dbInfo );
+    item->setOpen( TRUE );
+    if ( !parent )
+	item->setPixmap( 0, QPixmap::fromMimeSource( "designer_form.png" ) );
+    else if ( ::qt_cast<QLayoutWidget*>(o) )
+	item->setPixmap( 0, QPixmap::fromMimeSource( "designer_layout.png" ));
+    else
+	item->setPixmap( 0, WidgetDatabase::iconSet(
+		    WidgetDatabase::idFromClassName( WidgetFactory::classNameOf( o ) ) ).
+			 pixmap( QIconSet::Small, QIconSet::Normal ) );
+    if ( ::qt_cast<QAction*>(o) )
+	item->setPixmap( 0, ( (QAction*)o )->iconSet().pixmap() );
+
+    ( (HierarchyItem*)item )->setObject( o );
+    const QObjectList *l = o->children();
+    if ( ::qt_cast<QDesignerToolBar*>(o) )
+	l = 0;
+    if ( l ) {
+	QObjectListIt it( *l );
+	it.toLast();
+	for ( ; it.current(); --it ) {
+	    if ( !it.current()->isWidgetType() ||
+		 ( (QWidget*)it.current() )->isHidden() )
+		continue;
+	    if ( !formWindow->widgets()->find( (QWidget*)it.current() ) ) {
+		if ( ::qt_cast<QWidgetStack*>(it.current()->parent()) ||
+		     ::qt_cast<QWidgetStack*>(it.current()) ) {
+		    QObject *obj = it.current();
+		    QDesignerTabWidget *tw = ::qt_cast<QDesignerTabWidget*>(it.current()->parent());
+		    QDesignerWizard *dw = ::qt_cast<QDesignerWizard*>(it.current()->parent());
+		    QWidgetStack *stack = 0;
+		    if ( dw || tw || ::qt_cast<QWidgetStack*>(obj) )
+			stack = (QWidgetStack*)obj;
+		    else
+			stack = (QWidgetStack*)obj->parent();
+		    if ( widgetStacks->findRef( stack ) != -1 )
+			continue;
+		    widgetStacks->append( stack );
+		    QObjectList *l2 = stack->queryList( "QWidget", 0, TRUE, FALSE );
+		    for ( obj = l2->last(); obj; obj = l2->prev() ) {
+			if ( qstrcmp( obj->className(),
+				      "QWidgetStackPrivate::Invisible" ) == 0 ||
+			     ( tw && !tw->tabBar()->tab( stack->id( (QWidget*)obj ) ) ) ||
+			     ( dw && dw->isPageRemoved( (QWidget*)obj ) ) )
+			    continue;
+			if ( qstrcmp( obj->name(), "designer_wizardstack_button" ) == 0 )
+			    continue;
+			if ( stack->id( (QWidget*)obj ) == -1 )
+			    continue;
+			insertObject( obj, item );
+		    }
+		    delete l2;
+		} else if ( ::qt_cast<QToolBox*>(it.current()->parent()) ) {
+		    if ( !::qt_cast<QScrollView*>(it.current()) )
+			continue;
+		    QToolBox *tb = (QToolBox*)it.current()->parent();
+		    for ( int i = tb->count() - 1; i >= 0; --i )
+			insertObject( tb->item( i ), item );
+		}
+		continue;
+	    }
+	    insertObject( it.current(), item );
+	}
+    }
+    
+    if ( fakeMainWindow ) {
+	QObjectList *l = o->parent()->queryList( "QDesignerToolBar" );
+	QObject *obj;
+	for ( obj = l->first(); obj; obj = l->next() )
+	    insertObject( obj, item );
+	delete l;
+	l = o->parent()->queryList( "MenuBarEditor" );
+	for ( obj = l->first(); obj; obj = l->next() )
+	    insertObject( obj, item );
+	delete l;
+    } else if ( ::qt_cast<QDesignerToolBar*>(o) || ::qt_cast<PopupMenuEditor*>(o) ) {
+	QPtrList<QAction> actions;
+	if ( ::qt_cast<QDesignerToolBar*>(o) )
+	    actions = ( (QDesignerToolBar*)o )->insertedActions();
+	else
+	    ( (PopupMenuEditor*)o )->insertedActions( actions );
+
+	QPtrListIterator<QAction> it( actions );
+	it.toLast();
+	while ( it.current() ) {
+	    QAction *a = it.current();
+	    if ( ::qt_cast<QDesignerAction*>(a) ) {
+		QDesignerAction *da = (QDesignerAction*)a;
+		if ( da->supportsMenu() )
+		    insertObject( da, item );
+		else
+		    insertObject( da->widget(), item );
+	    } else if ( ::qt_cast<QDesignerActionGroup*>(a) ) {
+		insertObject( a, item );
+	    }
+	    --it;
+	}
+    } else if ( ::qt_cast<QDesignerActionGroup*>(o) && o->children() ) {
+	QObjectList *l = (QObjectList*)o->children();
+	for ( QObject *obj = l->last(); obj; obj = l->prev() ) {
+	    if ( ::qt_cast<QDesignerAction*>(obj) ) {
+		QDesignerAction *da = (QDesignerAction*)obj;
+		if ( da->supportsMenu() )
+		    insertObject( da, item );
+		else
+		    insertObject( da->widget(), item );
+	    } else if ( ::qt_cast<QDesignerActionGroup*>(obj) ) {
+		insertObject( obj, item );
+	    }
+	}
+    } else if ( ::qt_cast<MenuBarEditor*>(o) ) {
+	MenuBarEditor *mb = (MenuBarEditor*)o;
+	for ( int i = mb->count() -1; i >= 0; --i ) {
+	    MenuBarEditorItem *md = mb->item( i );
+	    if ( !md || !md->menu() )
+		continue;
+	    insertObject( md->menu(), item );
+	}
+    }
+}
+
+void HierarchyList::setCurrent( QObject *o )
+{
+    QListViewItemIterator it( this );
+    while ( it.current() ) {
+	if ( ( (HierarchyItem*)it.current() )->object() == o ) {
+	    blockSignals( TRUE );
+	    setCurrentItem( it.current() );
+	    ensureItemVisible( it.current() );
+	    blockSignals( FALSE );
+	    return;
+	}
+	++it;
+    }
+}
+
+void HierarchyList::showRMBMenu( QListViewItem *i, const QPoint & p )
+{
+    if ( !i )
+	return;
+
+    QObject *o = findObject( i );
+    if ( !o )
+	return;
+
+    if ( !o->isWidgetType() ||
+	 ( o != formWindow && !formWindow->widgets()->find( (QWidget*)o ) ) )
+	return;
+
+    QWidget *w = (QWidget*)o;
+    if ( w->isVisibleTo( formWindow ) ) {
+	if ( !::qt_cast<QTabWidget*>(w) && !::qt_cast<QWizard*>(w) ) {
+	    if ( !normalMenu )
+		normalMenu = formWindow->mainWindow()->setupNormalHierarchyMenu( this );
+	    normalMenu->popup( p );
+	} else {
+	    if ( !tabWidgetMenu )
+		tabWidgetMenu =
+		    formWindow->mainWindow()->setupTabWidgetHierarchyMenu(
+				  this, SLOT( addTabPage() ),
+				  SLOT( removeTabPage() ) );
+	    tabWidgetMenu->popup( p );
+	}
+    }
+}
+
+void HierarchyList::addTabPage()
+{
+    QObject *o = current();
+    if ( !o || !o->isWidgetType() )
+	return;
+    QWidget *w = (QWidget*)o;
+    if ( ::qt_cast<QTabWidget*>(w) ) {
+	QTabWidget *tw = (QTabWidget*)w;
+	AddTabPageCommand *cmd = new AddTabPageCommand( tr( "Add Page to %1" ).
+							arg( tw->name() ), formWindow,
+							tw, "Tab" );
+	formWindow->commandHistory()->addCommand( cmd );
+	cmd->execute();
+    } else if ( ::qt_cast<QWizard*>(w) ) {
+	QWizard *wiz = (QWizard*)formWindow->mainContainer();
+	AddWizardPageCommand *cmd = new AddWizardPageCommand( tr( "Add Page to %1" ).
+							      arg( wiz->name() ), formWindow,
+							      wiz, "Page" );
+	formWindow->commandHistory()->addCommand( cmd );
+	cmd->execute();
+    }
+}
+
+void HierarchyList::removeTabPage()
+{
+    QObject *o = current();
+    if ( !o || !o->isWidgetType() )
+	return;
+    QWidget *w = (QWidget*)o;
+    if ( ::qt_cast<QTabWidget*>(w) ) {
+	QTabWidget *tw = (QTabWidget*)w;
+	if ( tw->currentPage() ) {
+	    QDesignerTabWidget *dtw = (QDesignerTabWidget*)tw;
+	    DeleteTabPageCommand *cmd =
+		new DeleteTabPageCommand( tr( "Delete Page %1 of %2" ).
+					  arg( dtw->pageTitle() ).arg( tw->name() ),
+					  formWindow, tw, tw->currentPage() );
+	    formWindow->commandHistory()->addCommand( cmd );
+	    cmd->execute();
+	}
+    } else if ( ::qt_cast<QWizard*>(w) ) {
+	QWizard *wiz = (QWizard*)formWindow->mainContainer();
+	if ( wiz->currentPage() ) {
+	    QDesignerWizard *dw = (QDesignerWizard*)wiz;
+	    DeleteWizardPageCommand *cmd =
+		new DeleteWizardPageCommand( tr( "Delete Page %1 of %2" ).
+					     arg( dw->pageTitle() ).arg( wiz->name() ),
+					     formWindow, wiz,
+					     wiz->indexOf( wiz->currentPage() ), TRUE );
+	    formWindow->commandHistory()->addCommand( cmd );
+	    cmd->execute();
+	}
+    }
+}
+
+// ------------------------------------------------------------
+
+FormDefinitionView::FormDefinitionView( QWidget *parent, FormWindow *fw )
+    : HierarchyList( parent, fw, TRUE )
+{
+    header()->hide();
+    removeColumn( 1 );
+    connect( this, SIGNAL( itemRenamed( QListViewItem *, int, const QString & ) ),
+	     this, SLOT( renamed( QListViewItem * ) ) );
+    popupOpen = FALSE;
+}
+
+void FormDefinitionView::setup()
+{
+    if ( popupOpen || !formWindow )
+	return;
+    if ( !formWindow->project()->isCpp() )
+	return;
+    QListViewItem *i = firstChild();
+    while ( i ) {
+	if ( i->rtti() == HierarchyItem::DefinitionParent ) {
+	    QListViewItem *a = i;
+	    i = i->nextSibling();
+	    delete a;
+	    continue;
+	}
+	i = i->nextSibling();
+    }
+
+    LanguageInterface *lIface = MetaDataBase::languageInterface( formWindow->project()->language() );
+    if ( lIface ) {
+	QStringList defs = lIface->definitions();
+	for ( QStringList::Iterator dit = defs.begin(); dit != defs.end(); ++dit ) {
+	    HierarchyItem *itemDef = new HierarchyItem( HierarchyItem::DefinitionParent, this, 0,
+							tr( *dit ), QString::null, QString::null );
+	    itemDef->setPixmap( 0, QPixmap::fromMimeSource( "designer_folder.png" ) );
+	    itemDef->setOpen( TRUE );
+	    QStringList entries =
+		lIface->definitionEntries( *dit, formWindow->mainWindow()->designerInterface() );
+	    HierarchyItem *item = 0;
+	    for ( QStringList::Iterator eit = entries.begin(); eit != entries.end(); ++eit ) {
+		item = new HierarchyItem( HierarchyItem::Definition,
+					  itemDef, item, *eit, QString::null, QString::null );
+		item->setRenameEnabled( 0, TRUE );
+	    }
+	}
+	lIface->release();
+    }
+    setupVariables();
+    refresh();
+}
+
+void FormDefinitionView::setupVariables()
+{
+    bool pubOpen, protOpen, privOpen;
+    pubOpen = protOpen = privOpen = TRUE;
+    QListViewItem *i = firstChild();
+    while ( i ) {
+	if ( i->rtti() == HierarchyItem::VarParent ) {
+	    QListViewItem *a = i;
+	    i = i->firstChild();
+	    while ( i ) {
+		if ( i->rtti() == HierarchyItem::VarPublic )
+		    pubOpen = i->isOpen();
+		else if ( i->rtti() == HierarchyItem::VarProtected )
+		    protOpen = i->isOpen();
+		else if ( i->rtti() == HierarchyItem::VarPrivate )
+		    privOpen = i->isOpen();
+		i = i->nextSibling();
+	    }
+	    delete a;
+	    break;
+	}
+	i = i->nextSibling();
+    }
+
+    HierarchyItem *itemVar = new HierarchyItem( HierarchyItem::VarParent, this, 0, tr( "Class Variables" ),
+						QString::null, QString::null );
+    itemVar->setPixmap( 0, QPixmap::fromMimeSource( "designer_folder.png" ) );
+    itemVar->setOpen( TRUE );
+
+    itemVarPriv = new HierarchyItem( HierarchyItem::VarPrivate, itemVar, 0, tr( "private" ),
+				     QString::null, QString::null );
+    itemVarProt = new HierarchyItem( HierarchyItem::VarProtected, itemVar, 0, tr( "protected" ),
+				     QString::null, QString::null );
+    itemVarPubl = new HierarchyItem( HierarchyItem::VarPublic, itemVar, 0, tr( "public" ),
+				     QString::null, QString::null );
+
+    QValueList<MetaDataBase::Variable> varList = MetaDataBase::variables( formWindow );
+    QValueList<MetaDataBase::Variable>::Iterator it = --( varList.end() );
+    if ( !varList.isEmpty() && itemVar ) {
+	for (;;) {
+	    QListViewItem *item = 0;
+	    if ( (*it).varAccess == "public" )
+		item = new HierarchyItem( HierarchyItem::Variable, itemVarPubl, 0, (*it).varName,
+					  QString::null, QString::null );
+	    else if ( (*it).varAccess == "private" )
+		item = new HierarchyItem( HierarchyItem::Variable, itemVarPriv, 0, (*it).varName,
+					  QString::null, QString::null );
+	    else // default is protected
+		item = new HierarchyItem( HierarchyItem::Variable, itemVarProt, 0, (*it).varName,
+					  QString::null, QString::null );
+	    item->setPixmap( 0, QPixmap::fromMimeSource( "designer_editslots.png" ) );
+	    if ( it == varList.begin() )
+		break;
+	    --it;
+	}
+    }
+    itemVar->setOpen( TRUE );
+    itemVarPriv->setOpen( privOpen );
+    itemVarProt->setOpen( protOpen );
+    itemVarPubl->setOpen( pubOpen );
+}
+
+void FormDefinitionView::refresh()
+{
+    if ( popupOpen || !formWindow || !formWindow->project()->isCpp() )
+	return;
+
+    bool fuPub, fuProt, fuPriv, slPub, slProt, slPriv;
+    fuPub = fuProt = fuPriv = slPub = slProt = slPriv = TRUE;
+    QListViewItem *i = firstChild();
+    while ( i ) {
+        if ( i->rtti() == HierarchyItem::SlotParent ||
+	     i->rtti() == HierarchyItem::FunctParent ) {
+	    QListViewItem *a = i;
+	    i = i->firstChild();
+	    while ( i ) {
+		switch( i->rtti() ) {
+		case HierarchyItem::FunctPublic:
+		    fuPub = i->isOpen();
+		case HierarchyItem::FunctProtected:
+		    fuProt = i->isOpen();
+		    break;
+		case HierarchyItem::FunctPrivate:
+		    fuPriv = i->isOpen();
+		    break;
+		case HierarchyItem::SlotPublic:
+		    slPub = i->isOpen();
+		    if ( slPub )
+		    break;
+		case HierarchyItem::SlotProtected:
+		    slProt = i->isOpen();
+		    break;
+		case HierarchyItem::SlotPrivate:
+		    slPriv = i->isOpen();
+		}
+		i = i->nextSibling();
+	    }
+	    i = a->nextSibling();
+	    delete a;
+	    continue;
+	}
+	i = i->nextSibling();
+    }
+
+
+    itemFunct = new HierarchyItem( HierarchyItem::FunctParent,
+				   this, 0, tr( "Functions" ), QString::null, QString::null );
+    itemFunct->moveItem( i );
+    itemFunct->setPixmap( 0, QPixmap::fromMimeSource( "designer_folder.png" ) );
+    itemFunctPriv = new HierarchyItem( HierarchyItem::FunctPrivate, itemFunct, 0,
+				       tr( "private" ), QString::null, QString::null );
+    itemFunctProt = new HierarchyItem( HierarchyItem::FunctProtected, itemFunct, 0,
+				       tr( "protected" ), QString::null, QString::null );
+    itemFunctPubl = new HierarchyItem( HierarchyItem::FunctPublic, itemFunct, 0,
+				       tr( "public" ), QString::null, QString::null );
+
+    itemSlots = new HierarchyItem( HierarchyItem::SlotParent,
+				   this, 0, tr( "Slots" ), QString::null, QString::null );
+    itemSlots->setPixmap( 0, QPixmap::fromMimeSource( "designer_folder.png" ) );
+    itemPrivate = new HierarchyItem( HierarchyItem::SlotPrivate, itemSlots, 0, tr( "private" ),
+				     QString::null, QString::null );
+    itemProtected = new HierarchyItem( HierarchyItem::SlotProtected, itemSlots, 0, tr( "protected" ),
+				       QString::null, QString::null );
+    itemPublic = new HierarchyItem( HierarchyItem::SlotPublic, itemSlots, 0, tr( "public" ),
+				    QString::null, QString::null );
+
+    QValueList<MetaDataBase::Function> functionList = MetaDataBase::functionList( formWindow );
+    QValueList<MetaDataBase::Function>::Iterator it = --( functionList.end() );
+    if ( !functionList.isEmpty() && itemFunct ) {
+	for (;;) {
+	    QListViewItem *item = 0;
+	    if ( (*it).type == "slot" ) {
+		if ( (*it).access == "protected" )
+		    item = new HierarchyItem( HierarchyItem::Slot, itemProtected, 0, (*it).function,
+					      QString::null, QString::null );
+		else if ( (*it).access == "private" )
+		    item = new HierarchyItem( HierarchyItem::Slot, itemPrivate, 0, (*it).function,
+					      QString::null, QString::null );
+		else // default is public
+		    item = new HierarchyItem( HierarchyItem::Slot, itemPublic, 0, (*it).function,
+					      QString::null, QString::null );
+	    } else {
+		if ( (*it).access == "protected" )
+		    item = new HierarchyItem( HierarchyItem::Function, itemFunctProt, 0, (*it).function,
+					      QString::null, QString::null );
+		else if ( (*it).access == "private" )
+		    item = new HierarchyItem( HierarchyItem::Function, itemFunctPriv, 0, (*it).function,
+					      QString::null, QString::null );
+		else // default is public
+		    item = new HierarchyItem( HierarchyItem::Function, itemFunctPubl, 0, (*it).function,
+					      QString::null, QString::null );
+	    }
+	    item->setPixmap( 0, QPixmap::fromMimeSource( "designer_editslots.png" ) );
+	    if ( it == functionList.begin() )
+		break;
+	    --it;
+	}
+    }
+
+    itemFunct->setOpen( TRUE );
+    itemFunctPubl->setOpen( fuPub );
+    itemFunctProt->setOpen( fuProt );
+    itemFunctPriv->setOpen( fuPriv );
+
+    itemSlots->setOpen( TRUE );
+    itemPublic->setOpen( slPub );
+    itemProtected->setOpen( slProt );
+    itemPrivate->setOpen( slPriv );
+}
+
+
+void FormDefinitionView::setCurrent( QWidget * )
+{
+}
+
+void FormDefinitionView::objectClicked( QListViewItem *i )
+{
+    if ( !i )
+	return;
+    if ( (i->rtti() == HierarchyItem::Slot) || (i->rtti() == HierarchyItem::Function) )
+	formWindow->mainWindow()->editFunction( i->text( 0 ) );
+}
+
+static HierarchyItem::Type getChildType( int type )
+{
+    switch ( (HierarchyItem::Type)type ) {
+    case HierarchyItem::Widget:
+	qWarning( "getChildType: Inserting childs dynamically to Widget or SlotParent is not allowed!" );
+	break;
+    case HierarchyItem::SlotParent:
+    case HierarchyItem::SlotPublic:
+    case HierarchyItem::SlotProtected:
+    case HierarchyItem::SlotPrivate:
+    case HierarchyItem::Slot:
+	return HierarchyItem::Slot;
+    case HierarchyItem::DefinitionParent:
+    case HierarchyItem::Definition:
+	return HierarchyItem::Definition;
+    case HierarchyItem::Event:
+    case HierarchyItem::EventFunction:
+	return HierarchyItem::Event;
+    case HierarchyItem::FunctParent:
+    case HierarchyItem::FunctPublic:
+    case HierarchyItem::FunctProtected:
+    case HierarchyItem::FunctPrivate:
+    case HierarchyItem::Function:
+	return HierarchyItem::Function;
+    case HierarchyItem::VarParent:
+    case HierarchyItem::VarPublic:
+    case HierarchyItem::VarProtected:
+    case HierarchyItem::VarPrivate:
+    case HierarchyItem::Variable:
+	return HierarchyItem::Variable;
+    }
+    return (HierarchyItem::Type)type;
+}
+
+void HierarchyList::insertEntry( QListViewItem *i, const QPixmap &pix, const QString &s )
+{
+    QListViewItem *after = i->firstChild();
+    while ( after && after->nextSibling() )
+	after = after->nextSibling();
+    HierarchyItem *item = new HierarchyItem( getChildType( i->rtti() ), i, after, s,
+					     QString::null, QString::null );
+    if ( !pix.isNull() )
+	item->setPixmap( 0, pix );
+    item->setRenameEnabled( 0, TRUE );
+    setCurrentItem( item );
+    ensureItemVisible( item );
+    qApp->processEvents();
+    newItem = item;
+    item->startRename( 0 );
+}
+
+void FormDefinitionView::contentsMouseDoubleClickEvent( QMouseEvent *e )
+{
+    QListViewItem *i = itemAt( contentsToViewport( e->pos() ) );
+    if ( !i )
+	return;
+
+    if ( i->rtti() == HierarchyItem::SlotParent || i->rtti() == HierarchyItem::FunctParent ||
+	 i->rtti() == HierarchyItem::VarParent )
+	return;
+
+    HierarchyItem::Type t = getChildType( i->rtti() );
+    if ( (int)t == i->rtti() )
+	i = i->parent();
+
+    if ( formWindow->project()->isCpp() )
+	switch( i->rtti() ) {
+	case HierarchyItem::FunctPublic:
+	    execFunctionDialog( "public", "function", TRUE );
+	    break;
+	case HierarchyItem::FunctProtected:
+	    execFunctionDialog( "protected", "function", TRUE );
+	    break;
+	case HierarchyItem::FunctPrivate:
+	    execFunctionDialog( "private", "function", TRUE );
+	    break;
+	case HierarchyItem::SlotPublic:
+	    execFunctionDialog( "public", "slot", TRUE );
+	    break;
+	case HierarchyItem::SlotProtected:
+	    execFunctionDialog( "protected", "slot", TRUE );
+	    break;
+	case HierarchyItem::SlotPrivate:
+	    execFunctionDialog( "private", "slot", TRUE );
+	    break;
+	case HierarchyItem::VarPublic:
+	case HierarchyItem::VarProtected:
+	case HierarchyItem::VarPrivate: {
+	    VariableDialog varDia( formWindow, this );
+	    QListViewItem *i = selectedItem();
+	    if ( i )
+		varDia.setCurrentItem( i->text( 0 ) );
+	    varDia.exec();
+	    break;
+	}
+	default:
+	    insertEntry( i );
+    } else
+	insertEntry( i );
+}
+
+void FormDefinitionView::execFunctionDialog( const QString &access, const QString &type, bool addFunc )
+{
+    FormFile *formFile = formWindow->formFile();
+    if ( !formFile || !formFile->isUihFileUpToDate() )
+	    return;
+	
+    // refresh the functions list in the metadatabase
+    SourceEditor *editor = formFile->editor();
+    if ( editor )
+	editor->refresh( TRUE );
+
+    EditFunctions dlg( this, formWindow );
+    if ( addFunc )
+	dlg.functionAdd( access, type );
+    dlg.exec();
+}
+
+void FormDefinitionView::showRMBMenu( QListViewItem *i, const QPoint &pos )
+{
+    if ( !i )
+	return;
+
+    const int EDIT = 1;
+    const int NEW = 2;
+    const int DEL = 3;
+    const int PROPS = 4;
+    const int GOIMPL = 5;
+
+    QPopupMenu menu;
+    bool insertDelete = FALSE;
+
+    if ( i->rtti() == HierarchyItem::FunctParent || i->rtti() == HierarchyItem::SlotParent ||
+	 i->rtti() == HierarchyItem::VarParent ) {
+	menu.insertItem( QPixmap::fromMimeSource( "designer_editslots.png" ), tr( "Edit..." ), EDIT );
+    } else
+	menu.insertItem( QPixmap::fromMimeSource( "designer_filenew.png" ), tr( "New" ), NEW );
+    if ( i->rtti() == HierarchyItem::DefinitionParent || i->rtti() == HierarchyItem::Variable ||
+	 i->rtti() == HierarchyItem::Definition ) {
+	menu.insertItem( QPixmap::fromMimeSource( "designer_editslots.png" ), tr( "Edit..." ), EDIT );
+    }
+    if ( i->rtti() == HierarchyItem::Function || i->rtti() == HierarchyItem::Slot ) {
+	if ( formWindow->project()->isCpp() )
+	    menu.insertItem( QPixmap::fromMimeSource( "designer_editslots.png" ), tr( "Properties..." ), PROPS );
+	if ( MetaDataBase::hasEditor( formWindow->project()->language() ) )
+	    menu.insertItem( tr( "Goto Implementation" ), GOIMPL );
+	insertDelete = TRUE;
+    }
+    if ( insertDelete || i->rtti() == HierarchyItem::Variable ||
+	 i->rtti() == HierarchyItem::Function || i->rtti() == HierarchyItem::Slot ||
+	 i->rtti() == HierarchyItem::Definition ) {
+	menu.insertSeparator();
+	menu.insertItem( QPixmap::fromMimeSource( "designer_editcut.png" ), tr( "Delete..." ), DEL );
+    }
+    popupOpen = TRUE;
+    int res = menu.exec( pos );
+    popupOpen = FALSE;
+    if ( res == -1 )
+	return;
+
+    if ( res == EDIT ) {
+	switch( i->rtti() ) {
+	case HierarchyItem::FunctParent:
+	    execFunctionDialog( "public", "function", FALSE );
+	    break;
+	case HierarchyItem::SlotParent:
+	    execFunctionDialog( "public", "slot", FALSE );
+	    break;
+	case HierarchyItem::VarParent:
+	case HierarchyItem::VarPublic:
+	case HierarchyItem::VarProtected:
+	case HierarchyItem::VarPrivate:
+	case HierarchyItem::Variable: {
+	    VariableDialog varDia( formWindow, this );
+	    QListViewItem *i = selectedItem();
+	    if ( i )
+		varDia.setCurrentItem( i->text( 0 ) );
+	    if ( varDia.exec() == QDialog::Accepted )
+		formWindow->commandHistory()->setModified( TRUE );
+	    break;
+	}
+	case HierarchyItem::Definition:
+	case HierarchyItem::DefinitionParent:
+	    LanguageInterface *lIface = MetaDataBase::languageInterface( formWindow->project()->language() );
+	    if ( !lIface )
+		return;
+	    if ( i->rtti() == HierarchyItem::Definition )
+		i = i->parent();
+	    ListEditor dia( this, 0, TRUE );
+	    dia.setCaption( tr( "Edit %1" ).arg( i->text( 0 ) ) );
+	    QStringList entries = lIface->definitionEntries( i->text( 0 ), MainWindow::self->designerInterface() );
+	    dia.setList( entries );
+	    dia.exec();
+	    Command *cmd = new EditDefinitionsCommand( tr( "Edit " ) + i->text( 0 ), formWindow,
+						       lIface, i->text( 0 ), dia.items() );
+	    formWindow->commandHistory()->addCommand( cmd );
+	    cmd->execute();
+	}
+    } else if ( res == NEW ) {
+	HierarchyItem::Type t = getChildType( i->rtti() );
+	if ( (int)t == i->rtti() )
+	    i = i->parent();
+	switch( i->rtti() ) {
+	case HierarchyItem::SlotPublic:
+	    execFunctionDialog( "public", "slot", TRUE );
+	    break;
+	case HierarchyItem::SlotProtected:
+	    execFunctionDialog( "protected", "slot", TRUE );
+	    break;
+	case HierarchyItem::SlotPrivate:
+	    execFunctionDialog( "private" , "slot", TRUE );
+	    break;
+	case HierarchyItem::FunctPublic:
+	    execFunctionDialog( "public", "function", TRUE );
+	    break;
+	case HierarchyItem::FunctProtected:
+	    execFunctionDialog( "protected", "function", TRUE );
+	    break;
+	case HierarchyItem::FunctPrivate:
+	    execFunctionDialog( "private" , "function", TRUE );
+	    break;
+    	default:
+	    insertEntry( i );
+	}
+    } else if ( res == DEL ) {
+	if ( i->rtti() == HierarchyItem::Slot || i->rtti() == HierarchyItem::Function ) {
+
+	    QCString funct( MetaDataBase::normalizeFunction( i->text( 0 ) ).latin1() );
+	    Command *cmd = new RemoveFunctionCommand( tr( "Remove function" ), formWindow, funct,
+						     QString::null, QString::null, QString::null,
+						     QString::null, formWindow->project()->language() );
+	    formWindow->commandHistory()->addCommand( cmd );
+	    cmd->execute();
+	    formWindow->mainWindow()->objectHierarchy()->updateFormDefinitionView();
+	} else if ( i->rtti() == HierarchyItem::Variable ) {
+	    Command *cmd = new RemoveVariableCommand( tr( "Remove variable" ), formWindow,
+						      i->text( 0 ) );
+	    formWindow->commandHistory()->addCommand( cmd );
+	    cmd->execute();
+	} else {
+	    QListViewItem *p = i->parent();
+	    delete i;
+	    save( p, 0 );
+	}
+    } else if ( res == PROPS ) {
+	if ( i->rtti() == HierarchyItem::Slot ||
+	     i->rtti() == HierarchyItem::Function ) {
+	    EditFunctions dlg( this, formWindow );
+	    dlg.setCurrentFunction( MetaDataBase::normalizeFunction( i->text( 0 ) ) );
+	    dlg.exec();
+	}
+    } else if ( res == GOIMPL ) {
+	if ( i->rtti() == HierarchyItem::Slot ||
+	     i->rtti() == HierarchyItem::Function ) {
+	    formWindow->mainWindow()->editFunction( i->text( 0 ) );
+	}
+    }
+}
+
+void FormDefinitionView::renamed( QListViewItem *i )
+{
+    if ( newItem == i )
+	newItem = 0;
+    if ( !i->parent() )
+	return;
+    save( i->parent(), i );
+}
+
+
+void FormDefinitionView::save( QListViewItem *p, QListViewItem *i )
+{
+    if ( i && i->text( 0 ).isEmpty() ) {
+	delete i;
+	return;
+    }
+
+    if ( i && i->rtti() == HierarchyItem::Variable ) {
+	i->setRenameEnabled( 0, FALSE );
+	QString varName = i->text( 0 );
+	varName = varName.simplifyWhiteSpace();
+	if ( varName[(int)varName.length() - 1] != ';' )
+	    varName += ";";
+	if ( MetaDataBase::hasVariable( formWindow, varName ) ) {
+	    QMessageBox::information( this, tr( "Edit Variables" ),
+				      tr( "This variable has already been declared!" ) );
+	} else {
+	    if ( p->rtti() == HierarchyItem::VarPublic )
+		addVariable( varName, "public" );
+	    else if ( p->rtti() == HierarchyItem::VarProtected )
+		addVariable( varName, "protected" );
+	    else if ( p->rtti() == HierarchyItem::VarPrivate )
+		addVariable( varName, "private" );
+	}
+    } else {
+	LanguageInterface *lIface = MetaDataBase::languageInterface( formWindow->project()->language() );
+	if ( !lIface )
+	    return;
+	QStringList lst;
+	i = p->firstChild();
+	while ( i ) {
+	    lst << i->text( 0 );
+	    i = i->nextSibling();
+	}
+	Command *cmd = new EditDefinitionsCommand( tr( "Edit " ) + p->text( 0 ), formWindow,
+						   lIface, p->text( 0 ), lst );
+	formWindow->commandHistory()->addCommand( cmd );
+	cmd->execute();
+    }
+}
+
+void FormDefinitionView::addVariable( const QString &varName, const QString &access )
+{
+    Command *cmd = new AddVariableCommand( tr( "Add variable" ), formWindow,
+					      varName, access );
+    formWindow->commandHistory()->addCommand( cmd );
+    cmd->execute();
+}
+
+// ------------------------------------------------------------
+
+HierarchyView::HierarchyView( QWidget *parent )
+    : QTabWidget( parent, 0, WStyle_Customize | WStyle_NormalBorder | WStyle_Title |
+		  WStyle_Tool |WStyle_MinMax | WStyle_SysMenu )
+{
+    formwindow = 0;
+    editor = 0;
+    listview = new HierarchyList( this, formWindow() );
+    fView = new FormDefinitionView( this, formWindow() );
+    if ( !MainWindow::self->singleProjectMode() ) {
+	addTab( listview, tr( "Objects" ) );
+	setTabToolTip( listview, tr( "List of all widgets and objects of the current form in hierarchical order" ) );
+	addTab( fView, tr( "Members" ) );
+	setTabToolTip( fView, tr( "List of all members of the current form" ) );
+    } else {
+	listview->hide();
+	fView->hide();
+    }
+
+    if ( !classBrowserInterfaceManager ) {
+	classBrowserInterfaceManager =
+	    new QPluginManager<ClassBrowserInterface>( IID_ClassBrowser, QApplication::libraryPaths(),
+						       MainWindow::self->pluginDirectory() );
+    }
+
+    classBrowsers = new QMap<QString, ClassBrowser>();
+    QStringList langs = MetaDataBase::languages();
+    for ( QStringList::Iterator it = langs.begin(); it != langs.end(); ++it ) {
+	QInterfacePtr<ClassBrowserInterface> ciface = 0;
+	classBrowserInterfaceManager->queryInterface( *it, &ciface );
+	if ( ciface ) {
+	    ClassBrowser cb( ciface->createClassBrowser( this ), ciface );
+	    addTab( cb.lv, tr( "Class Declarations" ) );
+	    setTabToolTip( cb.lv, tr( "List of all classes and its declarations of the current source file" ) );
+	    ciface->onClick( this, SLOT( jumpTo( const QString &, const QString &, int ) ) );
+	    classBrowsers->insert( *it, cb );
+	    setTabEnabled( cb.lv, FALSE );
+	}
+    }
+}
+
+HierarchyView::~HierarchyView()
+{
+}
+
+void HierarchyView::clear()
+{
+    listview->clear();
+    fView->clear();
+    for ( QMap<QString, ClassBrowser>::Iterator it = classBrowsers->begin();
+	  it != classBrowsers->end(); ++it ) {
+	(*it).iface->clear();
+    }
+}
+
+void HierarchyView::setFormWindow( FormWindow *fw, QObject *o )
+{
+    bool fake = fw && qstrcmp( fw->name(), "qt_fakewindow" ) == 0;
+    if ( fw == 0 || o == 0 ) {
+	listview->clear();
+	fView->clear();
+	listview->setFormWindow( fw );
+	fView->setFormWindow( fw );
+	formwindow = 0;
+	editor = 0;
+    }
+
+    setTabEnabled( listview, TRUE );
+    setTabEnabled( fView, fw && fw->project()->isCpp() );
+
+    if ( fw == formwindow ) {
+	if ( fw ) {
+	    if ( !fake )
+		listview->setCurrent( (QWidget*)o );
+	    else
+		listview->clear();
+	    if ( MainWindow::self->qWorkspace()->activeWindow() == fw )
+		showPage( listview );
+	    else if ( fw->project()->isCpp() )
+		showPage( fView );
+	    else
+		showClasses( fw->formFile()->editor() );
+	}
+    }
+
+    formwindow = fw;
+    if ( !fake ) {
+	listview->setFormWindow( fw );
+    } else {
+	listview->setFormWindow( 0 );
+	listview->clear();
+    }
+
+    fView->setFormWindow( fw );
+    if ( !fake ) {
+	listview->setup();
+	listview->setCurrent( (QWidget*)o );
+    }
+    fView->setup();
+
+    for ( QMap<QString, ClassBrowser>::Iterator it = classBrowsers->begin();
+	  it != classBrowsers->end(); ++it ) {
+	(*it).iface->clear();
+	setTabEnabled( (*it).lv, fw && !fw->project()->isCpp() );
+    }
+
+    if ( MainWindow::self->qWorkspace()->activeWindow() == fw )
+	showPage( listview );
+    else if ( fw && fw->project()->isCpp() )
+	showPage( fView );
+    else if ( fw )
+	showClasses( fw->formFile()->editor() );
+
+    editor = 0;
+}
+
+void HierarchyView::showClasses( SourceEditor *se )
+{
+    if ( !se->object() )
+	return;
+
+    lastSourceEditor = se;
+    QTimer::singleShot( 100, this, SLOT( showClassesTimeout() ) );
+}
+
+void HierarchyView::showClassesTimeout()
+{
+    if ( !lastSourceEditor )
+	return;
+    SourceEditor *se = (SourceEditor*)lastSourceEditor;
+    if ( !se->object() )
+	return;
+    if ( se->formWindow() && se->formWindow()->project()->isCpp() ) {
+	setFormWindow( se->formWindow(), se->formWindow()->currentWidget() );
+	MainWindow::self->propertyeditor()->setWidget( se->formWindow()->currentWidget(),
+						       se->formWindow() );
+	return;
+    }
+
+    setTabEnabled( listview, !!se->formWindow() && !se->formWindow()->isFake() );
+    setTabEnabled( fView, FALSE );
+
+    formwindow = 0;
+    listview->setFormWindow( 0 );
+    fView->setFormWindow( 0 );
+    listview->clear();
+    fView->clear();
+    if ( !se->formWindow() )
+	MainWindow::self->propertyeditor()->setWidget( 0, 0 );
+    editor = se;
+
+    for ( QMap<QString, ClassBrowser>::Iterator it = classBrowsers->begin();
+	  it != classBrowsers->end(); ++it ) {
+	if ( it.key() == se->project()->language() ) {
+	    (*it).iface->update( se->text() );
+	    setTabEnabled( (*it).lv, TRUE );
+	    showPage( (*it).lv );
+	} else {
+	    setTabEnabled( (*it).lv, FALSE );
+	    (*it).iface->clear();
+	}
+    }
+}
+
+void HierarchyView::updateClassBrowsers()
+{
+    if ( !editor )
+	return;
+    for ( QMap<QString, ClassBrowser>::Iterator it = classBrowsers->begin();
+	  it != classBrowsers->end(); ++it ) {
+	if ( it.key() == editor->project()->language() )
+	    (*it).iface->update( editor->text() );
+	else
+	    (*it).iface->clear();
+    }
+}
+
+FormWindow *HierarchyView::formWindow() const
+{
+    return formwindow;
+}
+
+void HierarchyView::closeEvent( QCloseEvent *e )
+{
+    emit hidden();
+    e->accept();
+}
+
+void HierarchyView::widgetInserted( QWidget * )
+{
+    listview->setup();
+}
+
+void HierarchyView::widgetRemoved( QWidget * )
+{
+    listview->setup();
+}
+
+void HierarchyView::widgetsInserted( const QWidgetList & )
+{
+    listview->setup();
+}
+
+void HierarchyView::widgetsRemoved( const QWidgetList & )
+{
+    listview->setup();
+}
+
+void HierarchyView::namePropertyChanged( QWidget *w, const QVariant & )
+{
+    QWidget *w2 = w;
+    if ( ::qt_cast<QMainWindow*>(w) )
+	w2 = ( (QMainWindow*)w )->centralWidget();
+    listview->changeNameOf( w2, w->name() );
+}
+
+
+void HierarchyView::databasePropertyChanged( QWidget *w, const QStringList& info )
+{
+#ifndef QT_NO_SQL
+    QString i = info.join( "." );
+    listview->changeDatabaseOf( w, i );
+#endif
+}
+
+
+void HierarchyView::tabsChanged( QTabWidget * )
+{
+    listview->setup();
+}
+
+void HierarchyView::pagesChanged( QWizard * )
+{
+    listview->setup();
+}
+
+void HierarchyView::rebuild()
+{
+    listview->setup();
+}
+
+void HierarchyView::closed( FormWindow *fw )
+{
+    if ( fw == formwindow ) {
+	listview->clear();
+	fView->clear();
+    }
+}
+
+void HierarchyView::updateFormDefinitionView()
+{
+    fView->setup();
+}
+
+void HierarchyView::jumpTo( const QString &func, const QString &clss, int type )
+{
+    if ( !editor )
+	return;
+    if ( type == ClassBrowserInterface::Class )
+	editor->setClass( func );
+    else
+	editor->setFunction( func, clss );
+}
+
+HierarchyView::ClassBrowser::ClassBrowser( QListView *l, ClassBrowserInterface *i )
+    : lv( l ), iface( i )
+{
+}
+
+HierarchyView::ClassBrowser::~ClassBrowser()
+{
+}
diff -Nru qt-x11-free-3.3.3.orig/tools/designer/designer/mainwindow.cpp qt-x11-free-3.3.3/tools/designer/designer/mainwindow.cpp
--- qt-x11-free-3.3.3.orig/tools/designer/designer/mainwindow.cpp	2004-08-22 13:20:57.794885664 +0200
+++ qt-x11-free-3.3.3/tools/designer/designer/mainwindow.cpp	2004-08-22 13:23:07.037437963 +0200
@@ -2457,8 +2457,8 @@
 {
     QPopupMenu *menu = new QPopupMenu( parent );
 
-    menu->insertItem( tr( "Add Page" ), parent, addSlot );
-    menu->insertItem( tr( "Delete Page" ), parent, removeSlot );
+    menu->insertItem( tr( "Add Page" ), parent, addSlot, 0, POPUP_REMOVE_PAGE_ID+1 );
+    menu->insertItem( tr( "Delete Page" ), parent, removeSlot, 0, POPUP_REMOVE_PAGE_ID );
     menu->insertSeparator();
     actionEditCut->addTo( menu );
     actionEditCopy->addTo( menu );
diff -Nru qt-x11-free-3.3.3.orig/tools/designer/designer/mainwindow.cpp~ qt-x11-free-3.3.3/tools/designer/designer/mainwindow.cpp~
--- qt-x11-free-3.3.3.orig/tools/designer/designer/mainwindow.cpp~	1970-01-01 01:00:00.000000000 +0100
+++ qt-x11-free-3.3.3/tools/designer/designer/mainwindow.cpp~	2004-03-29 18:14:05.000000000 +0200
@@ -0,0 +1,3771 @@
+ /**********************************************************************
+** Copyright (C) 2000-2002 Trolltech AS.  All rights reserved.
+**
+** This file is part of Qt Designer.
+**
+** This file may be distributed and/or modified under the terms of the
+** GNU General Public License version 2 as published by the Free Software
+** Foundation and appearing in the file LICENSE.GPL included in the
+** packaging of this file.
+**
+** Licensees holding valid Qt Enterprise Edition or Qt Professional Edition
+** licenses may use this file in accordance with the Qt Commercial License
+** Agreement provided with the Software.
+**
+** This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
+** WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+**
+** See http://www.trolltech.com/gpl/ for GPL licensing information.
+** See http://www.trolltech.com/pricing.html or email sales@trolltech.com for
+**   information about Qt Commercial License Agreements.
+**
+** Contact info@trolltech.com if any conditions of this licensing are
+** not clear to you.
+**
+**********************************************************************/
+
+#include "designerappiface.h"
+#include "designerapp.h"
+
+#include "mainwindow.h"
+#include "defs.h"
+#include "globaldefs.h"
+#include "formwindow.h"
+#include "widgetdatabase.h"
+#include "widgetfactory.h"
+#include "propertyeditor.h"
+#include "metadatabase.h"
+#include "resource.h"
+#include "hierarchyview.h"
+#include "newformimpl.h"
+#include "workspace.h"
+#include "about.h"
+#include "multilineeditorimpl.h"
+#include "wizardeditorimpl.h"
+#include "outputwindow.h"
+#include "actioneditorimpl.h"
+#include "actiondnd.h"
+#include "project.h"
+#include "projectsettingsimpl.h"
+#include "qwidgetfactory.h"
+#include "pixmapcollection.h"
+#include "qcompletionedit.h"
+#include "sourcefile.h"
+#include "orderindicator.h"
+#include <qtoolbox.h>
+#include "widgetaction.h"
+#include "propertyobject.h"
+#include "popupmenueditor.h"
+#include "menubareditor.h"
+
+#include "startdialog.h"
+#include "createtemplate.h"
+#include "editfunctions.h"
+//#include "connectionviewer.h"
+#include "formsettings.h"
+#include "preferences.h"
+#include "pixmapcollectioneditor.h"
+#ifndef QT_NO_SQL
+#include "dbconnectionimpl.h"
+#endif
+//#include "connectioneditor.h"
+#include "customwidgeteditorimpl.h"
+#include "paletteeditorimpl.h"
+#include "listboxeditorimpl.h"
+#include "listvieweditorimpl.h"
+#include "iconvieweditorimpl.h"
+#include "tableeditorimpl.h"
+#include "multilineeditor.h"
+#include "finddialog.h"
+#include "replacedialog.h"
+#include "gotolinedialog.h"
+
+#include <qinputdialog.h>
+#include <qtoolbar.h>
+#include <qfeatures.h>
+#include <qmetaobject.h>
+#include <qaction.h>
+#include <qpixmap.h>
+#include <qworkspace.h>
+#include <qfiledialog.h>
+#include <qclipboard.h>
+#include <qmessagebox.h>
+#include <qbuffer.h>
+#include <qdir.h>
+#include <qstyle.h>
+#include <qlabel.h>
+#include <qstatusbar.h>
+#include <qfile.h>
+#include <qcheckbox.h>
+#include <qwhatsthis.h>
+#include <qwizard.h>
+#include <qtimer.h>
+#include <qlistbox.h>
+#include <qdockwindow.h>
+#include <qstylefactory.h>
+#include <qvbox.h>
+#include <qprocess.h>
+#include <qsettings.h>
+#include <qaccel.h>
+#include <qtooltip.h>
+#include <qsizegrip.h>
+#include <qtextview.h>
+#include <qassistantclient.h>
+#include <stdlib.h>
+
+static bool mblockNewForms = FALSE;
+extern QMap<QWidget*, QString> *qwf_forms;
+extern QString *qwf_language;
+extern bool qwf_execute_code;
+extern bool qwf_stays_on_top;
+extern void set_splash_status( const QString &txt );
+extern QObject* qwf_form_object;
+extern QString *qwf_plugin_dir;
+
+MainWindow *MainWindow::self = 0;
+
+QString assistantPath()
+{
+    QString path = QDir::cleanDirPath( QString( qInstallPathBins() ) +
+				       QDir::separator() );
+    return path;
+}
+
+
+static QString textNoAccel( const QString& text)
+{
+    QString t = text;
+    int i;
+    while ( (i = t.find('&') )>= 0 ) {
+	t.remove(i,1);
+    }
+    return t;
+}
+
+
+MainWindow::MainWindow( bool asClient, bool single, const QString &plgDir )
+    : QMainWindow( 0, "designer_mainwindow", WType_TopLevel | (single ? 0 : WDestructiveClose) | WGroupLeader ),
+      grd( 10, 10 ), sGrid( TRUE ), snGrid( TRUE ), restoreConfig( TRUE ), splashScreen( TRUE ),
+      fileFilter( tr( "Qt User-Interface Files (*.ui)" ) ), client( asClient ),
+      previewing( FALSE ), databaseAutoEdit( FALSE ), autoSaveEnabled( FALSE ), autoSaveInterval( 1800 )
+{
+    extern void qInitImages_designercore();
+    qInitImages_designercore();
+
+    self = this;
+    setPluginDirectory( plgDir );
+    customWidgetToolBar = customWidgetToolBar2 = 0;
+    guiStuffVisible = TRUE;
+    editorsReadOnly = FALSE;
+    sSignalHandlers = TRUE;
+    init_colors();
+    shStartDialog = TRUE;
+
+    desInterface = new DesignerInterfaceImpl( this );
+    desInterface->addRef();
+    inDebugMode = FALSE;
+    savePluginPaths = FALSE;
+
+    updateFunctionsTimer = new QTimer( this );
+    connect( updateFunctionsTimer, SIGNAL( timeout() ),
+	     this, SLOT( doFunctionsChanged() ) );
+
+    autoSaveTimer = new QTimer( this );
+    connect( autoSaveTimer, SIGNAL( timeout() ),
+	     this, SLOT( fileSaveAll() ) );
+
+    set_splash_status( "Loading Plugins..." );
+    setupPluginManagers();
+
+    if ( !single )
+	qApp->setMainWidget( this );
+    QWidgetFactory::addWidgetFactory( new CustomWidgetFactory );
+#ifndef Q_WS_MACX
+    setIcon( QPixmap::fromMimeSource( "designer_appicon.png" ) );
+#endif
+
+    actionGroupTools = 0;
+    prefDia = 0;
+    windowMenu = 0;
+    hierarchyView = 0;
+    actionEditor = 0;
+    currentProject = 0;
+    wspace = 0;
+    oWindow = 0;
+    singleProject = single;
+
+    statusBar()->clear();
+#if defined(QT_NON_COMMERCIAL)
+    statusBar()->addWidget( new QLabel(tr("Ready - This is the non-commercial version of Qt - "
+	"For commercial evaluations, use the help menu to register with Trolltech."), statusBar()), 1 );
+#else
+    statusBar()->addWidget( new QLabel("Ready", statusBar()), 1 );
+#endif
+
+
+    set_splash_status( "Setting up GUI..." );
+    setupMDI();
+    setupMenuBar();
+
+    setupToolbox();
+
+    setupFileActions();
+    setupEditActions();
+    setupProjectActions();
+    setupSearchActions();
+    layoutToolBar = new QToolBar( this, "Layout" );
+    layoutToolBar->setCloseMode( QDockWindow::Undocked );
+    addToolBar( layoutToolBar, tr( "Layout" ) );
+    interpreterPluginManager = 0;
+    setupToolActions();
+    setupLayoutActions();
+    setupPreviewActions();
+    setupOutputWindow();
+    setupActionManager();
+    setupWindowActions();
+
+    setupWorkspace();
+    setupHierarchyView();
+    setupPropertyEditor();
+    setupActionEditor();
+
+    setupHelpActions();
+
+    setupRMBMenus();
+
+    connect( this, SIGNAL( projectChanged() ), this, SLOT( emitProjectSignals() ) );
+    connect( this, SIGNAL( hasActiveWindow(bool) ), this, SLOT( emitProjectSignals() ) );
+
+    emit hasActiveForm( FALSE );
+    emit hasActiveWindow( FALSE );
+
+    lastPressWidget = 0;
+    qApp->installEventFilter( this );
+
+    QSize as( qApp->desktop()->size() );
+    as -= QSize( 30, 30 );
+    resize( QSize( 1200, 1000 ).boundedTo( as ) );
+
+    connect( qApp->clipboard(), SIGNAL( dataChanged() ),
+	     this, SLOT( clipboardChanged() ) );
+    clipboardChanged();
+    layoutChilds = FALSE;
+    layoutSelected = FALSE;
+    breakLayout = FALSE;
+    backPix = TRUE;
+
+    set_splash_status( "Loading User Settings..." );
+    readConfig();
+    // hack to make WidgetFactory happy (so it knows QWidget and QDialog for resetting properties)
+    QWidget *w = WidgetFactory::create( WidgetDatabase::idFromClassName( "QWidget" ), this, 0, FALSE );
+    delete w;
+    w = WidgetFactory::create( WidgetDatabase::idFromClassName( "QDialog" ), this, 0, FALSE );
+    delete w;
+    w = WidgetFactory::create( WidgetDatabase::idFromClassName( "QLabel" ), this, 0, FALSE );
+    delete w;
+    w = WidgetFactory::create( WidgetDatabase::idFromClassName( "QTabWidget" ), this, 0, FALSE );
+    delete w;
+    w = WidgetFactory::create( WidgetDatabase::idFromClassName( "QFrame" ), this, 0, FALSE );
+    delete w;
+    setAppropriate( (QDockWindow*)actionEditor->parentWidget(), FALSE );
+    actionEditor->parentWidget()->hide();
+
+    assistant = new QAssistantClient( assistantPath(), this );
+
+    statusBar()->setSizeGripEnabled( TRUE );
+    set_splash_status( "Initialization Done." );
+    if ( shStartDialog )
+	QTimer::singleShot( 0, this, SLOT( showStartDialog() ));
+
+    if ( autoSaveEnabled )
+	autoSaveTimer->start( autoSaveInterval * 1000 );
+}
+
+MainWindow::~MainWindow()
+{
+    QValueList<Tab>::Iterator tit;
+    for ( tit = preferenceTabs.begin(); tit != preferenceTabs.end(); ++tit ) {
+	Tab t = *tit;
+	delete t.w;
+    }
+    for ( tit = projectTabs.begin(); tit != projectTabs.end(); ++tit ) {
+	Tab t = *tit;
+	delete t.w;
+    }
+
+    QMap< QAction*, Project* >::Iterator it = projects.begin();
+    while ( it != projects.end() ) {
+	Project *p = *it;
+	++it;
+	delete p;
+    }
+    projects.clear();
+
+    delete oWindow;
+    oWindow = 0;
+
+    desInterface->release();
+    desInterface = 0;
+
+    delete actionPluginManager;
+    delete preferencePluginManager;
+    delete projectSettingsPluginManager;
+    delete interpreterPluginManager;
+    delete templateWizardPluginManager;
+    delete editorPluginManager;
+    delete sourceTemplatePluginManager;
+
+    MetaDataBase::clearDataBase();
+    if(self == this)
+	self = 0;
+}
+
+void MainWindow::setupMDI()
+{
+    QVBox *vbox = new QVBox( this );
+    setCentralWidget( vbox );
+    vbox->setFrameStyle( QFrame::StyledPanel | QFrame::Sunken );
+    vbox->setMargin( 1 );
+    vbox->setLineWidth( 1 );
+    qworkspace = new QWorkspace( vbox );
+    qworkspace->setPaletteBackgroundPixmap( QPixmap::fromMimeSource( "designer_background.png" ) );
+    qworkspace->setScrollBarsEnabled( TRUE );
+    connect( qworkspace, SIGNAL( windowActivated( QWidget * ) ),
+	     this, SLOT( activeWindowChanged( QWidget * ) ) );
+    lastActiveFormWindow = 0;
+    qworkspace->setAcceptDrops( TRUE );
+}
+
+void MainWindow::setupMenuBar()
+{
+    menubar = menuBar();
+}
+
+void MainWindow::setupPropertyEditor()
+{
+    QDockWindow *dw = new QDockWindow( QDockWindow::InDock, this );
+    dw->setResizeEnabled( TRUE );
+    dw->setCloseMode( QDockWindow::Always );
+    propertyEditor = new PropertyEditor( dw );
+    addToolBar( dw, Qt::DockRight );
+    dw->setWidget( propertyEditor );
+    dw->setFixedExtentWidth( 250 );
+    dw->setCaption( tr( "Property Editor/Signal Handlers" ) );
+    QWhatsThis::add( propertyEditor,
+		     tr("<b>The Property Editor</b>"
+			"<p>You can change the appearance and behavior of the selected widget in the "
+			"property editor.</p>"
+			"<p>You can set properties for components and forms at design time and see the "
+			"immediately see the effects of the changes. "
+			"Each property has its own editor which (depending on the property) can be used "
+			"to enter "
+			"new values, open a special dialog, or to select values from a predefined list. "
+			"Click <b>F1</b> to get detailed help for the selected property.</p>"
+			"<p>You can resize the columns of the editor by dragging the separators in the "
+			"list's header.</p>"
+			"<p><b>Signal Handlers</b></p>"
+			"<p>In the Signal Handlers tab you can define connections between "
+			"the signals emitted by widgets and the slots in the form. "
+			"(These connections can also be made using the connection tool.)" ) );
+    dw->show();
+}
+
+void MainWindow::setupOutputWindow()
+{
+    QDockWindow *dw = new QDockWindow( QDockWindow::InDock, this );
+    dw->setResizeEnabled( TRUE );
+    dw->setCloseMode( QDockWindow::Always );
+    addToolBar( dw, Qt::DockBottom );
+    oWindow = new OutputWindow( dw );
+    dw->setWidget( oWindow );
+    dw->setFixedExtentHeight( 150 );
+    dw->setCaption( tr( "Output Window" ) );
+}
+
+void MainWindow::setupHierarchyView()
+{
+    if ( hierarchyView )
+	return;
+    QDockWindow *dw = new QDockWindow( QDockWindow::InDock, this );
+    dw->setResizeEnabled( TRUE );
+    dw->setCloseMode( QDockWindow::Always );
+    hierarchyView = new HierarchyView( dw );
+    addToolBar( dw, Qt::DockRight );
+    dw->setWidget( hierarchyView );
+
+    dw->setCaption( tr( "Object Explorer" ) );
+    dw->setFixedExtentWidth( 250 );
+    QWhatsThis::add( hierarchyView,
+		     tr("<b>The Object Explorer</b>"
+			"<p>The Object Explorer provides an overview of the relationships "
+			"between the widgets in a form. You can use the clipboard functions using "
+			"a context menu for each item in the view. It is also useful for selecting widgets "
+			"in forms that have complex layouts.</p>"
+			"<p>The columns can be resized by dragging the separator in the list's header.</p>"
+			"<p>The second tab shows all the form's slots, class variables, includes, etc.</p>") );
+    dw->show();
+}
+
+void MainWindow::setupWorkspace()
+{
+    QDockWindow *dw = new QDockWindow( QDockWindow::InDock, this );
+    dw->setResizeEnabled( TRUE );
+    dw->setCloseMode( QDockWindow::Always );
+    QVBox *vbox = new QVBox( dw );
+    QCompletionEdit *edit = new QCompletionEdit( vbox );
+    QToolTip::add( edit, tr( "Start typing the buffer you want to switch to here (ALT+B)" ) );
+    QAccel *a = new QAccel( this );
+    a->connectItem( a->insertItem( ALT + Key_B ), edit, SLOT( setFocus() ) );
+    wspace = new Workspace( vbox, this );
+    wspace->setBufferEdit( edit );
+    wspace->setCurrentProject( currentProject );
+    addToolBar( dw, Qt::DockRight );
+    dw->setWidget( vbox );
+
+    dw->setCaption( tr( "Project Overview" ) );
+    QWhatsThis::add( wspace, tr("<b>The Project Overview Window</b>"
+				"<p>The Project Overview Window displays all the current "
+				"project, including forms and source files.</p>"
+				"<p>Use the search field to rapidly switch between files.</p>"));
+    dw->setFixedExtentHeight( 100 );
+    dw->show();
+}
+
+void MainWindow::setupActionEditor()
+{
+    QDockWindow *dw = new QDockWindow( QDockWindow::OutsideDock, this, 0 );
+    addDockWindow( dw, Qt::DockTornOff );
+    dw->setResizeEnabled( TRUE );
+    dw->setCloseMode( QDockWindow::Always );
+    actionEditor = new ActionEditor( dw );
+    dw->setWidget( actionEditor );
+    actionEditor->show();
+    dw->setCaption( tr( "Action Editor" ) );
+    QWhatsThis::add( actionEditor, tr("<b>The Action Editor</b>"
+				      "<p>The Action Editor is used to add actions and action groups to "
+				      "a form, and to connect actions to slots. Actions and action "
+				      "groups can be dragged into menus and into toolbars, and may "
+				      "feature keyboard shortcuts and tooltips. If actions have pixmaps "
+				      "these are displayed on toolbar buttons and besides their names in "
+				      "menus.</p>" ) );
+    dw->hide();
+    setAppropriate( dw, FALSE );
+}
+
+void MainWindow::setupToolbox()
+{
+    QDockWindow *dw = new QDockWindow( QDockWindow::InDock, this );
+    dw->setResizeEnabled( TRUE );
+    dw->setCloseMode( QDockWindow::Always );
+    addToolBar( dw, Qt::DockLeft );
+    toolBox = new QToolBox( dw );
+    dw->setWidget( toolBox );
+    dw->setFixedExtentWidth( 160 );
+    dw->setCaption( tr( "Toolbox" ) );
+    dw->show();
+    setDockEnabled( dw, Qt::DockTop, FALSE );
+    setDockEnabled( dw, Qt::DockBottom, FALSE );
+    commonWidgetsToolBar = new QToolBar( "Common Widgets", 0, toolBox, FALSE, "Common Widgets" );
+    commonWidgetsToolBar->setFrameStyle( QFrame::NoFrame );
+    commonWidgetsToolBar->setOrientation( Qt::Vertical );
+    commonWidgetsToolBar->setBackgroundMode(PaletteBase);
+    toolBox->addItem( commonWidgetsToolBar, "Common Widgets" );
+}
+
+void MainWindow::setupRMBMenus()
+{
+    rmbWidgets = new QPopupMenu( this );
+    actionEditCut->addTo( rmbWidgets );
+    actionEditCopy->addTo( rmbWidgets );
+    actionEditPaste->addTo( rmbWidgets );
+    actionEditDelete->addTo( rmbWidgets );
+#if 0
+    rmbWidgets->insertSeparator();
+    actionEditLower->addTo( rmbWidgets );
+    actionEditRaise->addTo( rmbWidgets );
+#endif
+    rmbWidgets->insertSeparator();
+    actionEditAdjustSize->addTo( rmbWidgets );
+    actionEditHLayout->addTo( rmbWidgets );
+    actionEditVLayout->addTo( rmbWidgets );
+    actionEditGridLayout->addTo( rmbWidgets );
+    actionEditSplitHorizontal->addTo( rmbWidgets );
+    actionEditSplitVertical->addTo( rmbWidgets );
+    actionEditBreakLayout->addTo( rmbWidgets );
+    rmbWidgets->insertSeparator();
+    if ( !singleProjectMode() )
+	actionEditConnections->addTo( rmbWidgets );
+    actionEditSource->addTo( rmbWidgets );
+
+    rmbFormWindow = new QPopupMenu( this );
+    actionEditPaste->addTo( rmbFormWindow );
+    actionEditSelectAll->addTo( rmbFormWindow );
+    actionEditAccels->addTo( rmbFormWindow );
+    rmbFormWindow->insertSeparator();
+    actionEditAdjustSize->addTo( rmbFormWindow );
+    actionEditHLayout->addTo( rmbFormWindow );
+    actionEditVLayout->addTo( rmbFormWindow );
+    actionEditGridLayout->addTo( rmbFormWindow );
+    actionEditBreakLayout->addTo( rmbFormWindow );
+    rmbFormWindow->insertSeparator();
+    if ( !singleProjectMode() ) {
+	actionEditFunctions->addTo( rmbFormWindow );
+	actionEditConnections->addTo( rmbFormWindow );
+    }
+    actionEditSource->addTo( rmbFormWindow );
+    rmbFormWindow->insertSeparator();
+    actionEditFormSettings->addTo( rmbFormWindow );
+}
+
+void MainWindow::toolSelected( QAction* action )
+{
+    actionCurrentTool = action;
+    emit currentToolChanged();
+    if ( formWindow() )
+	formWindow()->commandHistory()->emitUndoRedo();
+}
+
+int MainWindow::currentTool() const
+{
+    if ( !actionCurrentTool )
+	return POINTER_TOOL;
+    return QString::fromLatin1(actionCurrentTool->name()).toInt();
+}
+
+void MainWindow::runProjectPrecondition()
+{
+    for ( SourceEditor *e = sourceEditors.first(); e; e = sourceEditors.next() ) {
+	e->save();
+	e->saveBreakPoints();
+    }
+    fileSaveProject();
+
+    if ( currentTool() == ORDER_TOOL )
+	resetTool();
+    oWindow->clearErrorMessages();
+    oWindow->clearDebug();
+    oWindow->showDebugTab();
+    previewing = TRUE;
+}
+
+void MainWindow::runProjectPostcondition( QObjectList *l )
+{
+    inDebugMode = TRUE;
+    debuggingForms = *l;
+    enableAll( FALSE );
+    for ( SourceEditor *e2 = sourceEditors.first(); e2; e2 = sourceEditors.next() ) {
+	if ( e2->project() == currentProject )
+	    e2->editorInterface()->setMode( EditorInterface::Debugging );
+    }
+}
+
+QWidget* MainWindow::previewFormInternal( QStyle* style, QPalette* palet )
+{
+    qwf_execute_code = FALSE;
+    for ( SourceEditor *e = sourceEditors.first(); e; e = sourceEditors.next() )
+	e->save();
+    if ( currentTool() == ORDER_TOOL )
+	resetTool();
+
+    FormWindow *fw = formWindow();
+    if ( !fw )
+	return 0;
+
+    QStringList databases;
+    QPtrDictIterator<QWidget> wit( *fw->widgets() );
+    while ( wit.current() ) {
+	QStringList lst = MetaDataBase::fakeProperty( wit.current(), "database" ).toStringList();
+	if ( !lst.isEmpty() )
+	    databases << lst [ 0 ];
+	++wit;
+    }
+
+    if ( fw->project() ) {
+	QStringList::ConstIterator it;
+	for ( it = databases.begin(); it != databases.end(); ++it )
+	    fw->project()->openDatabase( *it, FALSE );
+    }
+    QApplication::setOverrideCursor( WaitCursor );
+
+    QCString s;
+    QBuffer buffer( s );
+    buffer.open( IO_WriteOnly );
+    Resource resource( this );
+    resource.setWidget( fw );
+    QValueList<Resource::Image> images;
+    resource.save( &buffer );
+
+    buffer.close();
+    buffer.open( IO_ReadOnly );
+
+    QWidget *w = QWidgetFactory::create( &buffer );
+    if ( w ) {
+	previewedForm = w;
+	if ( palet ) {
+	    if ( style )
+		style->polish( *palet );
+	    w->setPalette( *palet );
+	}
+
+	if ( style )
+	    w->setStyle( style );
+
+	QObjectList *l = w->queryList( "QWidget" );
+	for ( QObject *o = l->first(); o; o = l->next() ) {
+	    if ( style )
+		( (QWidget*)o )->setStyle( style );
+	}
+	delete l;
+
+	w->move( fw->mapToGlobal( QPoint(0,0) ) );
+	((MainWindow*)w )->setWFlags( WDestructiveClose );
+	previewing = TRUE;
+	w->show();
+	previewing = FALSE;
+	QApplication::restoreOverrideCursor();
+	return w;
+    }
+    QApplication::restoreOverrideCursor();
+    return 0;
+}
+
+void MainWindow::previewForm()
+{
+    QWidget* w = previewFormInternal();
+    if ( w )
+	w->show();
+}
+
+void MainWindow::previewForm( const QString & style )
+{
+    QStyle* st = QStyleFactory::create( style );
+    QWidget* w = 0;
+    if ( style == "Motif" ) {
+	QPalette p( QColor( 192, 192, 192 ) );
+	w = previewFormInternal( st, &p );
+    } else if ( style == "Windows" ) {
+	QPalette p( QColor( 212, 208, 200 ) );
+	w = previewFormInternal( st, &p );
+    } else if ( style == "Platinum" ) {
+	QPalette p( QColor( 220, 220, 220 ) );
+	w = previewFormInternal( st, &p );
+    } else if ( style == "CDE" ) {
+	QPalette p( QColor( 75, 123, 130 ) );
+	p.setColor( QPalette::Active, QColorGroup::Base, QColor( 55, 77, 78 ) );
+	p.setColor( QPalette::Inactive, QColorGroup::Base, QColor( 55, 77, 78 ) );
+	p.setColor( QPalette::Disabled, QColorGroup::Base, QColor( 55, 77, 78 ) );
+	p.setColor( QPalette::Active, QColorGroup::Highlight, Qt::white );
+	p.setColor( QPalette::Active, QColorGroup::HighlightedText, QColor( 55, 77, 78 ) );
+	p.setColor( QPalette::Inactive, QColorGroup::Highlight, Qt::white );
+	p.setColor( QPalette::Inactive, QColorGroup::HighlightedText, QColor( 55, 77, 78 ) );
+	p.setColor( QPalette::Disabled, QColorGroup::Highlight, Qt::white );
+	p.setColor( QPalette::Disabled, QColorGroup::HighlightedText, QColor( 55, 77, 78 ) );
+	p.setColor( QPalette::Active, QColorGroup::Foreground, Qt::white );
+	p.setColor( QPalette::Active, QColorGroup::Text, Qt::white );
+	p.setColor( QPalette::Active, QColorGroup::ButtonText, Qt::white );
+	p.setColor( QPalette::Inactive, QColorGroup::Foreground, Qt::white );
+	p.setColor( QPalette::Inactive, QColorGroup::Text, Qt::white );
+	p.setColor( QPalette::Inactive, QColorGroup::ButtonText, Qt::white );
+	p.setColor( QPalette::Disabled, QColorGroup::Foreground, Qt::lightGray );
+	p.setColor( QPalette::Disabled, QColorGroup::Text, Qt::lightGray );
+	p.setColor( QPalette::Disabled, QColorGroup::ButtonText, Qt::lightGray );
+
+	w = previewFormInternal( st, &p );
+    } else if ( style == "SGI" ) {
+	QPalette p( QColor( 220, 220, 220 ) );
+	w = previewFormInternal( st, &p );
+    } else if ( style == "MotifPlus" ) {
+	QColor gtkfg(0x00, 0x00, 0x00);
+	QColor gtkdf(0x75, 0x75, 0x75);
+	QColor gtksf(0xff, 0xff, 0xff);
+	QColor gtkbs(0xff, 0xff, 0xff);
+	QColor gtkbg(0xd6, 0xd6, 0xd6);
+	QColor gtksl(0x00, 0x00, 0x9c);
+	QColorGroup active(gtkfg,            // foreground
+			   gtkbg,            // button
+			   gtkbg.light(),    // light
+			   gtkbg.dark(142),  // dark
+			   gtkbg.dark(110),  // mid
+			   gtkfg,            // text
+			   gtkfg,            // bright text
+			   gtkbs,            // base
+			   gtkbg),           // background
+	    disabled(gtkdf,            // foreground
+		     gtkbg,            // button
+		     gtkbg.light(), // light
+		     gtkbg.dark(156),  // dark
+		     gtkbg.dark(110),  // mid
+		     gtkdf,            // text
+		     gtkdf,            // bright text
+		     gtkbs,            // base
+		     gtkbg);           // background
+
+	QPalette pal(active, disabled, active);
+
+	pal.setColor(QPalette::Active, QColorGroup::Highlight,
+		     gtksl);
+	pal.setColor(QPalette::Active, QColorGroup::HighlightedText,
+		     gtksf);
+	pal.setColor(QPalette::Inactive, QColorGroup::Highlight,
+		     gtksl);
+	pal.setColor(QPalette::Inactive, QColorGroup::HighlightedText,
+		     gtksf);
+	pal.setColor(QPalette::Disabled, QColorGroup::Highlight,
+		     gtksl);
+	pal.setColor(QPalette::Disabled, QColorGroup::HighlightedText,
+		     gtkdf);
+	w = previewFormInternal( st, &pal );
+    } else {
+	w = previewFormInternal( st );
+    }
+
+    if ( !w )
+	return;
+    w->insertChild( st );
+    w->show();
+}
+
+void MainWindow::helpContents()
+{
+    QWidget *focusWidget = qApp->focusWidget();
+    bool showClassDocu = TRUE;
+    while ( focusWidget ) {
+	if ( focusWidget->isA( "PropertyList" ) ) {
+	    showClassDocu = FALSE;
+	    break;
+	}
+	focusWidget = focusWidget->parentWidget();
+    }
+
+    QString source = "designer-manual.html";
+    if ( propertyDocumentation.isEmpty() ) {
+	QString indexFile = documentationPath() + "/propertyindex";
+	QFile f( indexFile );
+	if ( f.open( IO_ReadOnly ) ) {
+	    QTextStream ts( &f );
+	    while ( !ts.eof() ) {
+		QString s = ts.readLine();
+		int from = s.find( "\"" );
+		if ( from == -1 )
+		    continue;
+		int to = s.findRev( "\"" );
+		if ( to == -1 )
+		    continue;
+		propertyDocumentation[ s.mid( from + 1, to - from - 1 ) ] = s.mid( to + 2 ) + "-prop";
+	    }
+	    f.close();
+	}
+    }
+
+    if ( propertyEditor->widget() && !showClassDocu ) {
+	if ( !propertyEditor->currentProperty().isEmpty() ) {
+	    QMetaObject* mo = propertyEditor->metaObjectOfCurrentProperty();
+	    QString s;
+	    QString cp = propertyEditor->currentProperty();
+	    if ( cp == "layoutMargin" ) {
+		source = propertyDocumentation[ "QLayout/margin" ];
+	    } else if ( cp == "layoutSpacing" ) {
+		source = propertyDocumentation[ "QLayout/spacing" ];
+	    } else if ( cp == "toolTip" ) {
+		source = "qtooltip.html#details";
+	    } else if ( mo && qstrcmp( mo->className(), "Spacer" ) == 0 ) {
+		if ( cp != "name" )
+		    source = "qsizepolicy.html#SizeType";
+		else
+		    source = propertyDocumentation[ "QObject/name" ];
+	    } else {
+		while ( mo && !propertyDocumentation.contains( ( s = QString( mo->className() ) + "/" + cp ) ) )
+		    mo = mo->superClass();
+		if ( mo )
+		    source = "p:" + propertyDocumentation[s];
+	    }
+	}
+
+	QString classname =  WidgetFactory::classNameOf( propertyEditor->widget() );
+	if ( source.isEmpty() || source == "designer-manual.html" ) {
+	    if ( classname.lower() == "spacer" )
+		source = "qspaceritem.html#details";
+	    else if ( classname == "QLayoutWidget" )
+		source = "layout.html";
+	    else
+		source = QString( WidgetFactory::classNameOf( propertyEditor->widget() ) ).lower() + ".html#details";
+	}
+    } else if ( propertyEditor->widget() ) {
+	source = QString( WidgetFactory::classNameOf( propertyEditor->widget() ) ).lower() + ".html#details";
+    }
+
+    if ( !source.isEmpty() )
+	assistant->showPage( documentationPath() + source );
+}
+
+void MainWindow::helpManual()
+{
+    assistant->showPage( documentationPath() + "/designer-manual.html" );
+}
+
+void MainWindow::helpAbout()
+{
+    AboutDialog dlg( this, 0, TRUE );
+    if ( singleProjectMode() ) {
+	dlg.aboutPixmap->setText( "" );
+	dlg.aboutVersion->setText( "" );
+	dlg.aboutCopyright->setText( "" );
+	LanguageInterface *iface = MetaDataBase::languageInterface( eProject->language() );
+	dlg.aboutLicense->setText( iface->aboutText() );
+    }
+    dlg.aboutVersion->setText(QString("Version ") + QString(QT_VERSION_STR));
+    dlg.resize( dlg.width(), dlg.layout()->heightForWidth(dlg.width()) );
+    dlg.exec();
+}
+
+void MainWindow::helpAboutQt()
+{
+    QMessageBox::aboutQt( this, "Qt Designer" );
+}
+
+#if defined(_WS_WIN_)
+#include <qt_windows.h>
+#include <qprocess.h>
+#endif
+
+void MainWindow::helpRegister()
+{
+#if defined(_WS_WIN_)
+    HKEY key;
+    HKEY subkey;
+    long res;
+    DWORD type;
+    DWORD size = 255;
+    QString command;
+    QString sub( "htmlfile\\shell" );
+#if defined(UNICODE)
+    if ( QApplication::winVersion() & Qt::WV_NT_based ) {
+	unsigned char data[256];
+	res = RegOpenKeyExW( HKEY_CLASSES_ROOT, NULL, 0, KEY_READ, &key );
+	res = RegOpenKeyExW( key, (TCHAR*)sub.ucs2(), 0, KEY_READ, &subkey );
+	res = RegQueryValueExW( subkey, NULL, NULL, &type, data, &size );
+	command = qt_winQString( data ) + "\\command";
+	size = 255;
+	res = RegOpenKeyExW( subkey, (TCHAR*)command.ucs2(), 0, KEY_READ, &subkey );
+	res = RegQueryValueExW( subkey, NULL, NULL, &type, data, &size );
+	command = qt_winQString( data );
+    } else
+#endif
+    {
+	unsigned char data[256];
+	res = RegOpenKeyExA( HKEY_CLASSES_ROOT, NULL, 0, KEY_READ, &key );
+	res = RegOpenKeyExA( key, sub.local8Bit(), 0, KEY_READ, &subkey );
+	res = RegQueryValueExA( subkey, NULL, NULL, &type, data, &size );
+	command = QString::fromLocal8Bit( (const char*) data ) + "\\command";
+	size = 255;
+	res = RegOpenKeyExA( subkey, command.local8Bit(), 0, KEY_READ, &subkey );
+	res = RegQueryValueExA( subkey, NULL, NULL, &type, data, &size );
+	command = QString::fromLocal8Bit( (const char*) data );
+    }
+
+    res = RegCloseKey( subkey );
+    res = RegCloseKey( key );
+
+    QProcess process( command + " www.trolltech.com/products/download/eval/evaluation.html" );
+    if ( !process.start() )
+	QMessageBox::information( this, "Register Qt", "Launching your web browser failed.\n"
+	"To register Qt, point your browser to www.trolltech.com/products/download/eval/evaluation.html" );
+#endif
+}
+
+void MainWindow::showProperties( QObject *o )
+{
+    if ( !o->isWidgetType() ) {
+	propertyEditor->setWidget( o, lastActiveFormWindow );
+	if ( lastActiveFormWindow )
+	    hierarchyView->setFormWindow( lastActiveFormWindow, lastActiveFormWindow->mainContainer() );
+	else
+	    hierarchyView->setFormWindow( 0, 0 );
+	return;
+    }
+    QWidget *w = (QWidget*)o;
+    setupHierarchyView();
+    FormWindow *fw = (FormWindow*)isAFormWindowChild( w );
+    if ( fw ) {
+	if ( fw->numSelectedWidgets() > 1 ) {
+	    QWidgetList wl = fw->selectedWidgets();
+	    if ( wl.first() != w ) {
+		wl.removeRef( w );
+		wl.insert( 0, w );
+	    }
+	    propertyEditor->setWidget( new PropertyObject( wl ), fw );
+	} else {
+	    propertyEditor->setWidget( w, fw );
+	}
+	hierarchyView->setFormWindow( fw, w );
+    } else {
+	propertyEditor->setWidget( 0, 0 );
+	hierarchyView->setFormWindow( 0, 0 );
+    }
+
+    if ( currentTool() == POINTER_TOOL && fw &&
+	 ( !qworkspace->activeWindow() || !::qt_cast<SourceEditor*>(qworkspace->activeWindow()) ) )
+	fw->setFocus();
+}
+
+void MainWindow::resetTool()
+{
+    actionPointerTool->setOn( TRUE );
+}
+
+void MainWindow::updateProperties( QObject * )
+{
+    if ( propertyEditor )
+	propertyEditor->refetchData();
+}
+
+bool MainWindow::eventFilter( QObject *o, QEvent *e )
+{
+    if ( ::qt_cast<MenuBarEditor*>(o) || ::qt_cast<PopupMenuEditor*>(o) ||
+	 ( o &&
+	   ( ::qt_cast<MenuBarEditor*>(o->parent()) ||
+	     ::qt_cast<PopupMenuEditor*>(o->parent()) ) ) ) {
+
+	if ( e->type() == QEvent::Accel && ::qt_cast<PopupMenuEditor*>(o) ) {
+	    return TRUE; // consume accel events
+ 	} else if ( e->type() == QEvent::MouseButtonPress && ::qt_cast<MenuBarEditor*>(o) ) {
+	    QPoint pos = ((QMouseEvent*)e)->pos();
+	    MenuBarEditor *m = ::qt_cast<MenuBarEditor*>(o);
+	    showProperties( o );
+	    if ( m->findItem( pos ) >= m->count() )
+		m->setFocus();
+	} else if ( e->type() == QEvent::MouseButtonPress && ::qt_cast<PopupMenuEditor*>(o) ) {
+	    PopupMenuEditor *m = ::qt_cast<PopupMenuEditor*>(o);
+	    PopupMenuEditorItem *i = m->at( ((QMouseEvent*)e)->pos() );
+	    if ( m->find( i->action() ) != -1 && !i->isSeparator() )
+		showProperties( i->action() );
+	}
+	return QMainWindow::eventFilter( o, e );
+    }
+
+    if ( !o || !e || !o->isWidgetType() )
+	return QMainWindow::eventFilter( o, e );
+
+    QWidget *w = 0;
+    bool passiveInteractor;
+    switch ( e->type() ) {
+    case QEvent::AccelOverride:
+	if ( ( (QKeyEvent*)e )->key() == Key_F1 &&
+	     ( ( (QKeyEvent*)e )->state() & ShiftButton ) != ShiftButton ) {
+	    w = (QWidget*)o;
+	    while ( w ) {
+		if ( ::qt_cast<PropertyList*>(w) )
+		    break;
+		w = w->parentWidget( TRUE );
+	    }
+	    if ( w ) {
+		propertyEditor->propertyList()->showCurrentWhatsThis();
+		( (QKeyEvent*)e )->accept();
+		return TRUE;
+	    }
+	}
+	break;
+    case QEvent::Accel:
+	if ( ( ( (QKeyEvent*)e )->key() == Key_A ||
+	       ( (QKeyEvent*)e )->key() == Key_E ) &&
+	     ( (QKeyEvent*)e )->state() & ControlButton ) {
+	    if ( qWorkspace()->activeWindow() &&
+		 ::qt_cast<SourceEditor*>(qWorkspace()->activeWindow()) ) {
+		( (QKeyEvent*)e )->ignore();
+		return TRUE;
+	    }
+	}
+	break;
+    case QEvent::ContextMenu:
+    case QEvent::MouseButtonPress:
+	if ( o && currentTool() == POINTER_TOOL &&
+	     ( ::qt_cast<MenuBarEditor*>(o) ||
+	       ::qt_cast<PopupMenuEditor*>(o) ||
+	       ::qt_cast<QDesignerToolBar*>(o) ||
+	       ( ::qt_cast<QComboBox*>(o) ||
+		 ::qt_cast<QToolButton*>(o) ||
+		 ::qt_cast<QDesignerToolBarSeparator*>(o) ) &&
+	       o->parent()
+	       && ( ::qt_cast<QDesignerToolBar*>(o->parent())
+		   || ::qt_cast<QDesignerWidgetStack*>(o->parent())) ) ) {
+	    QWidget *w = (QWidget*)o;
+	    if ( ::qt_cast<QToolButton*>(w) ||
+		 ::qt_cast<QComboBox*>(w) ||
+		 ::qt_cast<PopupMenuEditor*>(w) ||
+		 ::qt_cast<QDesignerToolBarSeparator*>(w) )
+		w = w->parentWidget();
+	    QWidget *pw = w->parentWidget();
+	    while ( pw ) {
+		if ( ::qt_cast<FormWindow*>(pw) ) {
+		    ( (FormWindow*)pw )->emitShowProperties( w );
+		    if ( !::qt_cast<QDesignerToolBar*>(o) )
+			return ( !::qt_cast<QToolButton*>(o) &&
+				 !::qt_cast<MenuBarEditor*>(o) &&
+				 !::qt_cast<QComboBox*>(o) &&
+				 !::qt_cast<QDesignerToolBarSeparator*>(o) );
+		}
+		pw = pw->parentWidget();
+	    }
+	}
+	if ( o && ( ::qt_cast<QDesignerToolBar*>(o) || o->inherits("QDockWindowHandle") )
+	     && e->type() == QEvent::ContextMenu )
+	    break;
+	if ( isAToolBarChild( o ) && currentTool() != CONNECT_TOOL && currentTool() != BUDDY_TOOL )
+	    break;
+	if ( ::qt_cast<QSizeGrip*>(o) )
+	    break;
+	if ( !( w = isAFormWindowChild( o ) ) ||
+	     ::qt_cast<SizeHandle*>(o) ||
+	     ::qt_cast<OrderIndicator*>(o) )
+	    break;
+	if ( !w->hasFocus() )
+	    w->setFocus();
+	passiveInteractor = WidgetFactory::isPassiveInteractor( o );
+	if ( !passiveInteractor || currentTool() != ORDER_TOOL ) {
+	    if( e->type() == QEvent::ContextMenu ) {
+		( (FormWindow*)w )->handleContextMenu( (QContextMenuEvent*)e,
+						       ( (FormWindow*)w )->designerWidget( o ) );
+		return TRUE;
+	    } else {
+		( (FormWindow*)w )->handleMousePress( (QMouseEvent*)e,
+						      ( (FormWindow*)w )->designerWidget( o ) );
+	    }
+	}
+	lastPressWidget = (QWidget*)o;
+	if ( passiveInteractor )
+	    QTimer::singleShot( 0, formWindow(), SLOT( visibilityChanged() ) );
+	if ( currentTool() == CONNECT_TOOL || currentTool() == BUDDY_TOOL )
+	    return TRUE;
+	return !passiveInteractor;
+    case QEvent::MouseButtonRelease:
+	lastPressWidget = 0;
+	if ( isAToolBarChild( o )  && currentTool() != CONNECT_TOOL && currentTool() != BUDDY_TOOL )
+	    break;
+	if ( ::qt_cast<QSizeGrip*>(o) )
+	    break;
+	if ( !( w = isAFormWindowChild( o ) ) ||
+	     ::qt_cast<SizeHandle*>(o) ||
+	     ::qt_cast<OrderIndicator*>(o) )
+	    break;
+	passiveInteractor = WidgetFactory::isPassiveInteractor( o );
+	if ( !passiveInteractor )
+	    ( (FormWindow*)w )->handleMouseRelease( (QMouseEvent*)e,
+						    ( (FormWindow*)w )->designerWidget( o ) );
+	if ( passiveInteractor ) {
+	    QTimer::singleShot( 0, this, SLOT( selectionChanged() ) );
+	    QTimer::singleShot( 0, formWindow(), SLOT( visibilityChanged() ) );
+	}
+	return !passiveInteractor;
+    case QEvent::MouseMove:
+	if ( isAToolBarChild( o ) && currentTool() != CONNECT_TOOL && currentTool() != BUDDY_TOOL )
+	    break;
+	w = isAFormWindowChild( o );
+	if ( lastPressWidget != (QWidget*)o && w &&
+	     !::qt_cast<SizeHandle*>(o) && !::qt_cast<OrderIndicator*>(o) &&
+	     !::qt_cast<PopupMenuEditor*>(o) && !::qt_cast<QMenuBar*>(o) &&
+	     !::qt_cast<QSizeGrip*>(o) )
+	    return TRUE;
+	if ( o && ::qt_cast<QSizeGrip*>(o) )
+	    break;
+	if ( lastPressWidget != (QWidget*)o ||
+	     ( !w || ::qt_cast<SizeHandle*>(o) ) ||
+	       ::qt_cast<OrderIndicator*>(o) )
+	    break;
+	passiveInteractor = WidgetFactory::isPassiveInteractor( o );
+	if ( !passiveInteractor )
+	    ( (FormWindow*)w )->handleMouseMove( (QMouseEvent*)e,
+						 ( (FormWindow*)w )->designerWidget( o ) );
+	return !passiveInteractor;
+    case QEvent::KeyPress:
+	if ( ( (QKeyEvent*)e )->key() == Key_Escape && currentTool() != POINTER_TOOL ) {
+	    resetTool();
+	    return FALSE;
+	}
+	if ( ( (QKeyEvent*)e )->key() == Key_Escape && incrementalSearch->hasFocus() ) {
+	    if ( ::qt_cast<SourceEditor*>(qWorkspace()->activeWindow()) ) {
+		qWorkspace()->activeWindow()->setFocus();
+		return TRUE;
+	    }
+	}
+	if ( !( w = isAFormWindowChild( o ) ) ||
+	     ::qt_cast<SizeHandle*>(o) ||
+	     ::qt_cast<OrderIndicator*>(o) )
+	    break;
+	( (FormWindow*)w )->handleKeyPress( (QKeyEvent*)e, ( (FormWindow*)w )->designerWidget( o ) );
+	if ( ((QKeyEvent*)e)->isAccepted() )
+	    return TRUE;
+	break;
+    case QEvent::MouseButtonDblClick:
+	if ( !( w = isAFormWindowChild( o ) ) ||
+	     ::qt_cast<SizeHandle*>(o) ||
+	     ::qt_cast<OrderIndicator*>(o) ) {
+	    if ( ::qt_cast<QToolButton*>(o) && ((QToolButton*)o)->isOn() &&
+		 o->parent() && ::qt_cast<QToolBar*>(o->parent()) && formWindow() )
+		formWindow()->setToolFixed();
+	    break;
+	}
+	if ( currentTool() == ORDER_TOOL ) {
+	    ( (FormWindow*)w )->handleMouseDblClick( (QMouseEvent*)e,
+						     ( (FormWindow*)w )->designerWidget( o ) );
+	    return TRUE;
+	}
+	if ( !WidgetFactory::isPassiveInteractor( o ) && ( (FormWindow*)w )->formFile() )
+	    return openEditor( ( (FormWindow*)w )->designerWidget( o ), (FormWindow*)w );
+	return TRUE;
+    case QEvent::KeyRelease:
+	if ( !( w = isAFormWindowChild( o ) ) ||
+	     ::qt_cast<SizeHandle*>(o) ||
+	     ::qt_cast<OrderIndicator*>(o) )
+	    break;
+	( (FormWindow*)w )->handleKeyRelease( (QKeyEvent*)e, ( (FormWindow*)w )->designerWidget( o ) );
+	if ( ((QKeyEvent*)e)->isAccepted() )
+	    return TRUE;
+	break;
+    case QEvent::Hide:
+	if ( !( w = isAFormWindowChild( o ) ) ||
+	     ::qt_cast<SizeHandle*>(o) ||
+	     ::qt_cast<OrderIndicator*>(o) )
+	    break;
+	if ( ( (FormWindow*)w )->isWidgetSelected( (QWidget*)o ) )
+	    ( (FormWindow*)w )->selectWidget( (QWidget*)o, FALSE );
+	break;
+    case QEvent::Enter:
+    case QEvent::Leave:
+	if ( !( w = isAFormWindowChild( o ) ) ||
+	     ::qt_cast<SizeHandle*>(o) ||
+	     ::qt_cast<OrderIndicator*>(o) ||
+	     ::qt_cast<MenuBarEditor*>(o) )
+	    break;
+	return TRUE;
+    case QEvent::Resize:
+    case QEvent::Move:
+	if ( !( w = isAFormWindowChild( o ) ) ||
+	     ::qt_cast<SizeHandle*>(o) ||
+	     ::qt_cast<OrderIndicator*>(o) )
+	    break;
+	if ( WidgetFactory::layoutType( (QWidget*)o->parent() ) != WidgetFactory::NoLayout ) {
+	    ( (FormWindow*)w )->updateSelection( (QWidget*)o );
+	    if ( e->type() != QEvent::Resize )
+		( (FormWindow*)w )->updateChildSelections( (QWidget*)o );
+	}
+	break;
+    case QEvent::Close:
+	if ( o->isWidgetType() && (QWidget*)o == (QWidget*)previewedForm ) {
+	    if ( lastActiveFormWindow && lastActiveFormWindow->project() ) {
+		QStringList lst =
+		    MetaDataBase::fakeProperty( lastActiveFormWindow, "database" ).toStringList();
+		lastActiveFormWindow->project()->closeDatabase( lst[ 0 ] );
+	    }
+	}
+	break;
+    case QEvent::DragEnter:
+	if ( o == qWorkspace() || o == workspace() || o == workspace()->viewport() ) {
+	    workspace()->contentsDragEnterEvent( (QDragEnterEvent*)e );
+	    return TRUE;
+	}
+	break;
+    case QEvent::DragMove:
+	if ( o == qWorkspace() || o == workspace() || o == workspace()->viewport() ) {
+	    workspace()->contentsDragMoveEvent( (QDragMoveEvent*)e );
+	    return TRUE;
+	}
+	break;
+    case QEvent::Drop:
+	if ( o == qWorkspace() || o == workspace() || o == workspace()->viewport() ) {
+	    workspace()->contentsDropEvent( (QDropEvent*)e );
+	    return TRUE;
+	}
+	break;
+    case QEvent::Show:
+	if ( o != this )
+	    break;
+	if ( ((QShowEvent*)e)->spontaneous() )
+	    break;
+	QApplication::sendPostedEvents( qworkspace, QEvent::ChildInserted );
+	showEvent( (QShowEvent*)e );
+	checkTempFiles();
+	return TRUE;
+    case QEvent::Wheel:
+	if ( !( w = isAFormWindowChild( o ) ) ||
+	     ::qt_cast<SizeHandle*>(o) ||
+	     ::qt_cast<OrderIndicator*>(o) )
+	    break;
+	return TRUE;
+    case QEvent::FocusIn:
+	if ( !::qt_cast<FormWindow*>(o) && isAFormWindowChild( o ) )
+	    return TRUE; //FIXME
+	if ( hierarchyView->formDefinitionView()->isRenaming()
+	     && ( o->inherits( "Editor" ) || ::qt_cast<FormWindow*>(o) ) )
+		QApplication::sendPostedEvents();
+	if ( o->inherits( "Editor" ) ) {
+	    QWidget *w = (QWidget*)o;
+	    while ( w ) {
+		if ( ::qt_cast<SourceEditor*>(w) )
+		    break;
+		w = w->parentWidget( TRUE );
+	    }
+	    if ( ::qt_cast<SourceEditor*>(w) )
+		( (SourceEditor*)w )->checkTimeStamp();
+	} else if ( ::qt_cast<FormWindow*>(o) ) {
+	    FormWindow *fw = (FormWindow*)o;
+	    if ( fw->formFile() && fw->formFile()->editor() )
+		fw->formFile()->editor()->checkTimeStamp();
+	}
+	break;
+    case QEvent::FocusOut:
+	if ( !::qt_cast<FormWindow*>(o) && isAFormWindowChild( o ) )
+	    return TRUE;
+	break;
+    default:
+	return QMainWindow::eventFilter( o, e );
+    }
+
+    return QMainWindow::eventFilter( o, e );
+}
+
+QWidget *MainWindow::isAFormWindowChild( QObject *o ) const
+{
+    if ( ::qt_cast<QWizard*>(o->parent()) && !::qt_cast<QPushButton*>(o) )
+	return 0;
+    while ( o ) {
+	if ( ::qt_cast<FormWindow*>(o) )
+	    return (QWidget*)o;
+	o = o->parent();
+    }
+    return 0;
+}
+
+QWidget *MainWindow::isAToolBarChild( QObject *o ) const
+{
+    while ( o ) {
+	if ( ::qt_cast<QDesignerToolBar*>(o) )
+	    return (QWidget*)o;
+	if ( ::qt_cast<FormWindow*>(o) )
+	    return 0;
+	o = o->parent();
+    }
+    return 0;
+}
+
+FormWindow *MainWindow::formWindow()
+{
+    if ( qworkspace->activeWindow() ) {
+	FormWindow *fw = 0;
+	if ( ::qt_cast<FormWindow*>(qworkspace->activeWindow()) )
+	    fw = (FormWindow*)qworkspace->activeWindow();
+	else if ( lastActiveFormWindow &&
+		    qworkspace->windowList().find( lastActiveFormWindow ) != -1)
+	    fw = lastActiveFormWindow;
+	return fw;
+    }
+    return 0;
+}
+
+void MainWindow::emitProjectSignals()
+{
+    emit hasNonDummyProject( !currentProject->isDummy() );
+    emit hasActiveWindowOrProject( !!qworkspace->activeWindow() || !currentProject->isDummy() );
+}
+
+void MainWindow::insertFormWindow( FormWindow *fw )
+{
+    if ( fw )
+	QWhatsThis::add( fw, tr( "<b>The Form Window</b>"
+			       "<p>Use the various tools to add widgets or to change the layout "
+			       "and behavior of the components in the form. Select one or multiple "
+			       "widgets to move them or lay them out. If a single widget is chosen it can "
+			       "be resized using the resize handles.</p>"
+			       "<p>Changes in the <b>Property Editor</b> are visible at design time, "
+			       "and you can preview the form in different styles.</p>"
+			       "<p>You can change the grid resolution, or turn the grid off in the "
+			       "<b>Preferences</b> dialog in the <b>Edit</b> menu."
+			       "<p>You can have several forms open, and all open forms are listed "
+			       "in the <b>Form List</b>.") );
+
+    connect( fw, SIGNAL( showProperties( QObject * ) ),
+	     this, SLOT( showProperties( QObject * ) ) );
+    connect( fw, SIGNAL( updateProperties( QObject * ) ),
+	     this, SLOT( updateProperties( QObject * ) ) );
+    connect( this, SIGNAL( currentToolChanged() ),
+	     fw, SLOT( currentToolChanged() ) );
+    connect( fw, SIGNAL( selectionChanged() ),
+	     this, SLOT( selectionChanged() ) );
+    connect( fw, SIGNAL( undoRedoChanged( bool, bool, const QString &, const QString & ) ),
+	     this, SLOT( updateUndoRedo( bool, bool, const QString &, const QString & ) ) );
+
+    if ( !mblockNewForms ) {
+    } else {
+	fw->setProject( currentProject );
+    }
+    fw->show();
+    fw->currentToolChanged();
+    if ( fw->caption().isEmpty() && qstrlen( fw->name() )  )
+	fw->setCaption( fw->name() );
+    fw->mainContainer()->setCaption( fw->caption() );
+    WidgetFactory::saveDefaultProperties( fw->mainContainer(),
+					  WidgetDatabase::
+					  idFromClassName( WidgetFactory::classNameOf( fw->mainContainer() ) ) );
+    activeWindowChanged( fw );
+    emit formWindowsChanged();
+    for ( SourceEditor *e = sourceEditors.first(); e; e = sourceEditors.next() ) {
+	if ( e->project() == fw->project() )
+	    e->resetContext();
+    }
+}
+
+void MainWindow::createNewProject( const QString &lang )
+{
+    Project *pro = new Project( "", "", projectSettingsPluginManager );
+    pro->setLanguage( lang );
+
+
+    if ( !openProjectSettings( pro ) ) {
+	delete pro;
+	return;
+    }
+
+    if ( !pro->isValid() ) {
+	QMessageBox::information( this, tr("New Project"), tr( "Cannot create an invalid project." ) );
+	delete pro;
+	return;
+    }
+
+    QAction *a = new QAction( pro->makeRelative( pro->fileName() ),
+			      pro->makeRelative( pro->fileName() ), 0, actionGroupProjects, 0, TRUE );
+    projects.insert( a, pro );
+    addRecentlyOpened( pro->makeAbsolute( pro->fileName() ), recentlyProjects );
+    projectSelected( a );
+}
+
+
+bool MainWindow::unregisterClient( FormWindow *w )
+{
+    propertyEditor->closed( w );
+    objectHierarchy()->closed( w );
+    if ( w == lastActiveFormWindow )
+	lastActiveFormWindow = 0;
+
+    QPtrList<SourceEditor> waitingForDelete;
+    waitingForDelete.setAutoDelete( TRUE );
+    for ( SourceEditor *e = sourceEditors.first(); e; e = sourceEditors.next() ) {
+	if ( e->object() == w )
+	    waitingForDelete.append( e );
+    }
+
+    if ( actionEditor->form() == w ) {
+	actionEditor->setFormWindow( 0 );
+	actionEditor->parentWidget()->hide();
+    }
+
+    return TRUE;
+}
+
+void MainWindow::activeWindowChanged( QWidget *w )
+{
+    QWidget *old = formWindow();
+    if ( ::qt_cast<FormWindow*>(w) ) {
+	FormWindow *fw = (FormWindow*)w;
+	FormWindow *ofw = lastActiveFormWindow;
+	lastActiveFormWindow = fw;
+	lastActiveFormWindow->updateUndoInfo();
+	emit hasActiveForm( TRUE );
+	if ( formWindow() ) {
+	    formWindow()->emitShowProperties();
+	    emit formModified( formWindow()->commandHistory()->isModified() );
+	    if ( currentTool() != POINTER_TOOL )
+		formWindow()->clearSelection();
+	}
+	workspace()->activeFormChanged( fw );
+	setAppropriate( (QDockWindow*)actionEditor->parentWidget(),
+			::qt_cast<QMainWindow*>(lastActiveFormWindow->mainContainer()) );
+	if ( appropriate( (QDockWindow*)actionEditor->parentWidget() ) ) {
+	    if ( actionEditor->wantToBeShown() )
+		actionEditor->parentWidget()->show();
+	} else {
+	    QWidget *mc = 0;
+	    if ( ofw && (mc = ofw->mainContainer()) && ::qt_cast<QMainWindow*>(mc) )
+		actionEditor->setWantToBeShown( !actionEditor->parentWidget()->isHidden() );
+	    actionEditor->parentWidget()->hide();
+	}
+
+	actionEditor->setFormWindow( lastActiveFormWindow );
+	if ( wspace && fw->project() && fw->project() != currentProject ) {
+	    for ( QMap<QAction*, Project *>::ConstIterator it = projects.begin(); it != projects.end(); ++it ) {
+		if ( *it == fw->project() ) {
+		    projectSelected( it.key() );
+		    break;
+		}
+	    }
+	}
+	emit formWindowChanged();
+
+    } else if ( w == propertyEditor ) {
+	propertyEditor->resetFocus();
+    } else if ( !lastActiveFormWindow ) {
+	emit formWindowChanged();
+	emit hasActiveForm( FALSE );
+	actionEditUndo->setEnabled( FALSE );
+	actionEditRedo->setEnabled( FALSE );
+    }
+
+    if ( !w ) {
+	emit formWindowChanged();
+	emit hasActiveForm( FALSE );
+	propertyEditor->clear();
+	hierarchyView->clear();
+	updateUndoRedo( FALSE, FALSE, QString::null, QString::null );
+    }
+
+    selectionChanged();
+
+    if ( ::qt_cast<SourceEditor*>(w) ) {
+	SourceEditor *se = (SourceEditor*)w;
+	QGuardedPtr<FormWindow> fw = se->formWindow();
+	if ( se->formWindow() &&
+	     lastActiveFormWindow != fw ) {
+	    activeWindowChanged( se->formWindow() );
+	}
+	actionSearchFind->setEnabled( TRUE );
+	actionSearchIncremetal->setEnabled( TRUE );
+	actionSearchReplace->setEnabled( TRUE );
+	actionSearchGotoLine->setEnabled( TRUE );
+	incrementalSearch->setEnabled( TRUE );
+
+	actionEditUndo->setEnabled( FALSE );
+	actionEditRedo->setEnabled( FALSE );
+	actionEditCut->setEnabled( TRUE );
+	actionEditCopy->setEnabled( TRUE );
+	actionEditPaste->setEnabled( TRUE );
+	actionEditSelectAll->setEnabled( TRUE );
+	actionEditUndo->setMenuText( tr( "&Undo" ) );
+	actionEditUndo->setToolTip( textNoAccel( actionEditUndo->menuText()) );
+	actionEditRedo->setMenuText( tr( "&Redo" ) );
+	actionEditRedo->setToolTip( textNoAccel( actionEditRedo->menuText()) );
+	if ( hierarchyView->sourceEditor() != w )
+	    hierarchyView->showClasses( se );
+	actionEditor->setFormWindow( 0 );
+	if ( wspace && se->project() && se->project() != currentProject ) {
+	    for ( QMap<QAction*, Project *>::ConstIterator it = projects.begin(); it != projects.end(); ++it ) {
+		if ( *it == se->project() ) {
+		    projectSelected( it.key() );
+		    break;
+		}
+	    }
+	}
+	workspace()->activeEditorChanged( se );
+    } else {
+	actionSearchFind->setEnabled( FALSE );
+	actionSearchIncremetal->setEnabled( FALSE );
+	actionSearchReplace->setEnabled( FALSE );
+	actionSearchGotoLine->setEnabled( FALSE );
+	incrementalSearch->setEnabled( FALSE );
+    }
+
+    if ( currentTool() == ORDER_TOOL && w != old )
+	emit currentToolChanged();
+
+    emit hasActiveWindow( !!qworkspace->activeWindow() );
+}
+
+void MainWindow::updateUndoRedo( bool undoAvailable, bool redoAvailable,
+				 const QString &undoCmd, const QString &redoCmd )
+{
+    if ( qWorkspace()->activeWindow() &&
+	 ::qt_cast<SourceEditor*>(qWorkspace()->activeWindow()) )
+	 return; // do not set a formWindow related command
+    actionEditUndo->setEnabled( undoAvailable );
+    actionEditRedo->setEnabled( redoAvailable );
+    if ( !undoCmd.isEmpty() )
+	actionEditUndo->setMenuText( tr( "&Undo: %1" ).arg( undoCmd ) );
+    else
+	actionEditUndo->setMenuText( tr( "&Undo: Not Available" ) );
+    if ( !redoCmd.isEmpty() )
+	actionEditRedo->setMenuText( tr( "&Redo: %1" ).arg( redoCmd ) );
+    else
+	actionEditRedo->setMenuText( tr( "&Redo: Not Available" ) );
+
+    actionEditUndo->setToolTip( textNoAccel( actionEditUndo->menuText()) );
+    actionEditRedo->setToolTip( textNoAccel( actionEditRedo->menuText()) );
+
+    if ( currentTool() == ORDER_TOOL ) {
+	actionEditUndo->setEnabled( FALSE );
+	actionEditRedo->setEnabled( FALSE );
+    }
+}
+
+void MainWindow::updateEditorUndoRedo()
+{
+    if ( !qWorkspace()->activeWindow() ||
+	 !::qt_cast<SourceEditor*>(qWorkspace()->activeWindow()) )
+	return;
+    SourceEditor *editor = (SourceEditor*)qWorkspace()->activeWindow();
+    actionEditUndo->setEnabled( editor->editIsUndoAvailable() );
+    actionEditRedo->setEnabled( editor->editIsRedoAvailable() );
+}
+
+QWorkspace *MainWindow::qWorkspace() const
+{
+    return qworkspace;
+}
+
+void MainWindow::popupFormWindowMenu( const QPoint & gp, FormWindow *fw )
+{
+    QValueList<uint> ids;
+    QMap<QString, int> commands;
+
+    setupRMBSpecialCommands( ids, commands, fw );
+    setupRMBProperties( ids, commands, fw );
+
+    qApp->processEvents();
+    int r = rmbFormWindow->exec( gp );
+
+    handleRMBProperties( r, commands, fw );
+    handleRMBSpecialCommands( r, commands, fw );
+
+    for ( QValueList<uint>::ConstIterator i = ids.begin(); i != ids.end(); ++i )
+	rmbFormWindow->removeItem( *i );
+}
+
+void MainWindow::popupWidgetMenu( const QPoint &gp, FormWindow * /*fw*/, QWidget * w)
+{
+    QValueList<uint> ids;
+    QMap<QString, int> commands;
+
+    setupRMBSpecialCommands( ids, commands, w );
+    setupRMBProperties( ids, commands, w );
+
+    qApp->processEvents();
+    int r = rmbWidgets->exec( gp );
+
+    handleRMBProperties( r, commands, w );
+    handleRMBSpecialCommands( r, commands, w );
+
+    for ( QValueList<uint>::ConstIterator i = ids.begin(); i != ids.end(); ++i )
+	rmbWidgets->removeItem( *i );
+}
+
+void MainWindow::setupRMBProperties( QValueList<uint> &ids, QMap<QString, int> &props, QWidget *w )
+{
+    const QMetaProperty* text = w->metaObject()->property( w->metaObject()->findProperty( "text", TRUE ), TRUE );
+    if ( text && qstrcmp( text->type(), "QString") != 0 )
+	text = 0;
+    const QMetaProperty* title = w->metaObject()->property( w->metaObject()->findProperty( "title", TRUE ), TRUE );
+    if ( title && qstrcmp( title->type(), "QString") != 0 )
+	title = 0;
+    const QMetaProperty* pagetitle =
+	w->metaObject()->property( w->metaObject()->findProperty( "pageTitle", TRUE ), TRUE );
+    if ( pagetitle && qstrcmp( pagetitle->type(), "QString") != 0 )
+	pagetitle = 0;
+    const QMetaProperty* pixmap =
+	w->metaObject()->property( w->metaObject()->findProperty( "pixmap", TRUE ), TRUE );
+    if ( pixmap && qstrcmp( pixmap->type(), "QPixmap") != 0 )
+	pixmap = 0;
+
+    if ( text && text->designable(w) ||
+	 title && title->designable(w) ||
+	 pagetitle && pagetitle->designable(w) ||
+	 pixmap && pixmap->designable(w) ) {
+	int id = 0;
+	if ( ids.isEmpty() )
+	    ids << rmbWidgets->insertSeparator(0);
+	if ( pixmap && pixmap->designable(w) ) {
+	    ids << ( id = rmbWidgets->insertItem( tr("Choose Pixmap..."), -1, 0) );
+	    props.insert( "pixmap", id );
+	}
+	if ( text && text->designable(w) && !::qt_cast<QTextEdit*>(w) ) {
+	    ids << ( id = rmbWidgets->insertItem( tr("Edit Text..."), -1, 0) );
+	    props.insert( "text", id );
+	}
+	if ( title && title->designable(w) ) {
+	    ids << ( id = rmbWidgets->insertItem( tr("Edit Title..."), -1, 0) );
+	    props.insert( "title", id );
+	}
+	if ( pagetitle && pagetitle->designable(w) ) {
+	    ids << ( id = rmbWidgets->insertItem( tr("Edit Page Title..."), -1, 0) );
+	    props.insert( "pagetitle", id );
+	}
+    }
+}
+
+#ifdef QT_CONTAINER_CUSTOM_WIDGETS
+static QWidgetContainerInterfacePrivate *containerWidgetInterface( QWidget *w )
+{
+    WidgetInterface *iface = 0;
+    widgetManager()->queryInterface( WidgetFactory::classNameOf( w ), &iface );
+    if ( !iface )
+	return 0;
+    QWidgetContainerInterfacePrivate *iface2 = 0;
+    iface->queryInterface( IID_QWidgetContainer, (QUnknownInterface**)&iface2 );
+    if ( !iface2 )
+	return 0;
+    iface->release();
+    return iface2;
+}
+#endif
+
+void MainWindow::setupRMBSpecialCommands( QValueList<uint> &ids,
+					  QMap<QString, int> &commands, QWidget *w )
+{
+    int id;
+
+    if ( ::qt_cast<QTabWidget*>(w) ) {
+	if ( ids.isEmpty() )
+	    ids << rmbWidgets->insertSeparator( 0 );
+	if ( ( (QDesignerTabWidget*)w )->count() > 1) {
+	    ids << ( id = rmbWidgets->insertItem( tr("Delete Page"), -1, 0 ) );
+	    commands.insert( "remove", id );
+	}
+	ids << ( id = rmbWidgets->insertItem( tr("Add Page"), -1, 0 ) );
+	commands.insert( "add", id );
+    } else if ( ::qt_cast<QWidgetStack*>(w) ) {
+	if ( ids.isEmpty() )
+	    ids << rmbWidgets->insertSeparator( 0 );
+	if ( ( (QDesignerWidgetStack*)w )->count() > 1) {
+	    ids << ( id = rmbWidgets->insertItem( tr("Previous Page"), -1, 0 ) );
+	    commands.insert( "prevpage", id );
+	    ids << ( id = rmbWidgets->insertItem( tr("Next Page"), -1, 0 ) );
+	    ids << rmbWidgets->insertSeparator( 0 );
+	    commands.insert( "nextpage", id );
+	    ids << ( id = rmbWidgets->insertItem( tr("Delete Page"), -1, 0 ) );
+	    commands.insert( "remove", id );
+	}
+	ids << ( id = rmbWidgets->insertItem( tr("Add Page"), -1, 0 ) );
+	commands.insert( "add", id );
+    } else if ( ::qt_cast<QToolBox*>(w) ) {
+	if ( ids.isEmpty() )
+	    ids << rmbWidgets->insertSeparator( 0 );
+	if ( ( (QToolBox*)w )->count() > 1 ) {
+	    ids << ( id = rmbWidgets->insertItem( tr("Delete Page"), -1, 0 ) );
+	    commands.insert( "remove", id );
+	}
+	ids << ( id = rmbWidgets->insertItem( tr("Add Page"), -1, 0 ) );
+	commands.insert( "add", id );
+#ifdef QT_CONTAINER_CUSTOM_WIDGETS
+    } else if ( WidgetDatabase::
+		isCustomPluginWidget( WidgetDatabase::
+				      idFromClassName( WidgetFactory::classNameOf( w ) ) ) ) {
+	QWidgetContainerInterfacePrivate *iface = containerWidgetInterface( w );
+	if ( iface && iface->supportsPages( WidgetFactory::classNameOf( w ) ) ) {
+	    if ( ids.isEmpty() )
+		ids << rmbWidgets->insertSeparator( 0 );
+
+	    if ( iface->count( WidgetFactory::classNameOf( w ), w ) > 1 ) {
+		ids << ( id = rmbWidgets->insertItem( tr( "Delete Page" ), -1, 0 ) );
+		commands.insert( "remove", id );
+	    }
+	    ids << ( id = rmbWidgets->insertItem( tr("Add Page"), -1, 0 ) );
+	    commands.insert( "add", id );
+	    if ( iface->currentIndex( WidgetFactory::classNameOf( w ), w ) != -1 ) {
+		ids << ( id = rmbWidgets->insertItem( tr("Rename Current Page..."), -1, 0 ) );
+		commands.insert( "rename", id );
+	    }
+	}
+	if ( iface )
+	    iface->release();
+#endif // QT_CONTAINER_CUSTOM_WIDGETS
+    }
+
+    if ( WidgetFactory::hasSpecialEditor( WidgetDatabase::
+			  idFromClassName( WidgetFactory::classNameOf( w ) ), w ) ) {
+	if ( ids.isEmpty() )
+	    ids << rmbWidgets->insertSeparator( 0 );
+	ids << ( id = rmbWidgets->insertItem( tr("Edit..."), -1, 0 ) );
+	commands.insert( "edit", id );
+    }
+}
+
+void MainWindow::setupRMBSpecialCommands( QValueList<uint> &ids,
+					  QMap<QString, int> &commands, FormWindow *fw )
+{
+    int id;
+
+    if ( ::qt_cast<QWizard*>(fw->mainContainer()) ) {
+	if ( ids.isEmpty() )
+	    ids << rmbFormWindow->insertSeparator( 0 );
+
+	if ( ( (QWizard*)fw->mainContainer() )->pageCount() > 1) {
+	    ids << ( id = rmbFormWindow->insertItem( tr("Delete Page"), -1, 0 ) );
+	    commands.insert( "remove", id );
+	}
+
+	ids << ( id = rmbFormWindow->insertItem( tr("Add Page"), -1, 0 ) );
+	commands.insert( "add", id );
+
+	ids << ( id = rmbFormWindow->insertItem( tr("Edit Page Title..."), -1, 0 ) );
+	commands.insert( "rename", id );
+
+	ids << ( id = rmbFormWindow->insertItem( tr("Edit Pages..."), -1, 0 ) );
+	commands.insert( "edit", id );
+
+    } else if ( ::qt_cast<QMainWindow*>(fw->mainContainer()) ) {
+	if ( ids.isEmpty() )
+	    ids << rmbFormWindow->insertSeparator( 0 );
+	ids << ( id = rmbFormWindow->insertItem( tr( "Add Menu Item" ), -1, 0 ) );
+	commands.insert( "add_menu_item", id );
+	ids << ( id = rmbFormWindow->insertItem( tr( "Add Toolbar" ), -1, 0 ) );
+	commands.insert( "add_toolbar", id );
+    }
+}
+
+void MainWindow::handleRMBProperties( int id, QMap<QString, int> &props, QWidget *w )
+{
+    if ( id == props[ "text" ] ) {
+	bool ok = FALSE;
+	bool oldDoWrap = FALSE;
+	if ( ::qt_cast<QLabel*>(w) ) {
+	    int align = w->property( "alignment" ).toInt();
+	    if ( align & WordBreak )
+		oldDoWrap = TRUE;
+	}
+	bool doWrap = oldDoWrap;
+
+	QString text;
+	if ( ::qt_cast<QTextView*>(w) || ::qt_cast<QLabel*>(w) || ::qt_cast<QButton*>(w) ) {
+	    text = MultiLineEditor::getText( this, w->property( "text" ).toString(), !::qt_cast<QButton*>(w), &doWrap );
+	    ok = !text.isNull();
+	} else {
+	    text = QInputDialog::getText( tr("Text"), tr( "New text" ),
+				  QLineEdit::Normal, w->property("text").toString(), &ok, this );
+	}
+	if ( ok ) {
+	    if ( oldDoWrap != doWrap ) {
+		QString pn( tr( "Set 'wordwrap' of '%1'" ).arg( w->name() ) );
+		SetPropertyCommand *cmd = new SetPropertyCommand( pn, formWindow(), w, propertyEditor,
+								  "wordwrap", QVariant( oldDoWrap, 0 ),
+								  QVariant( doWrap, 0 ), QString::null, QString::null );
+		cmd->execute();
+		formWindow()->commandHistory()->addCommand( cmd );
+		MetaDataBase::setPropertyChanged( w, "wordwrap", TRUE );
+	    }
+
+	    QString pn( tr( "Set the 'text' of '%1'" ).arg( w->name() ) );
+	    SetPropertyCommand *cmd = new SetPropertyCommand( pn, formWindow(), w, propertyEditor,
+							      "text", w->property( "text" ),
+							      text, QString::null, QString::null );
+	    cmd->execute();
+	    formWindow()->commandHistory()->addCommand( cmd );
+	    MetaDataBase::setPropertyChanged( w, "text", TRUE );
+	}
+    } else if ( id == props[ "title" ] ) {
+	bool ok = FALSE;
+	QString title = QInputDialog::getText( tr("Title"), tr( "New title" ),
+			       QLineEdit::Normal, w->property("title").toString(), &ok, this );
+	if ( ok ) {
+	    QString pn( tr( "Set the 'title' of '%2'" ).arg( w->name() ) );
+	    SetPropertyCommand *cmd = new SetPropertyCommand( pn, formWindow(), w, propertyEditor,
+							      "title", w->property( "title" ),
+							      title, QString::null, QString::null );
+	    cmd->execute();
+	    formWindow()->commandHistory()->addCommand( cmd );
+	    MetaDataBase::setPropertyChanged( w, "title", TRUE );
+	}
+    } else if ( id == props[ "pagetitle" ] ) {
+	bool ok = FALSE;
+	QString text = QInputDialog::getText( tr("Page Title"), tr( "New page title" ),
+			      QLineEdit::Normal, w->property("pageTitle").toString(), &ok, this );
+	if ( ok ) {
+	    QString pn( tr( "Set the 'pageTitle' of '%2'" ).arg( w->name() ) );
+	    SetPropertyCommand *cmd = new SetPropertyCommand( pn, formWindow(), w, propertyEditor,
+							      "pageTitle",
+							      w->property( "pageTitle" ),
+							      text, QString::null, QString::null );
+	    cmd->execute();
+	    formWindow()->commandHistory()->addCommand( cmd );
+	    MetaDataBase::setPropertyChanged( w, "pageTitle", TRUE );
+	}
+    } else if ( id == props[ "pixmap" ] ) {
+	QPixmap oldPix = w->property( "pixmap" ).toPixmap();
+	QPixmap pix = qChoosePixmap( this, formWindow(), oldPix );
+	if ( !pix.isNull() ) {
+	    QString pn( tr( "Set the 'pixmap' of '%2'" ).arg( w->name() ) );
+	    SetPropertyCommand *cmd = new SetPropertyCommand( pn, formWindow(), w, propertyEditor,
+							      "pixmap", w->property( "pixmap" ),
+							      pix, QString::null, QString::null );
+	    cmd->execute();
+	    formWindow()->commandHistory()->addCommand( cmd );
+	    MetaDataBase::setPropertyChanged( w, "pixmap", TRUE );
+	}
+    }
+}
+
+void MainWindow::handleRMBSpecialCommands( int id, QMap<QString, int> &commands, QWidget *w )
+{
+    if ( ::qt_cast<QTabWidget*>(w) ) {
+	QTabWidget *tw = (QTabWidget*)w;
+	if ( id == commands[ "add" ] ) {
+	    AddTabPageCommand *cmd =
+		new AddTabPageCommand( tr( "Add Page to %1" ).arg( tw->name() ), formWindow(),
+				       tw, "Tab" );
+	    formWindow()->commandHistory()->addCommand( cmd );
+	    cmd->execute();
+	} else if ( id == commands[ "remove" ] ) {
+	    if ( tw->currentPage() ) {
+		QDesignerTabWidget *dtw = (QDesignerTabWidget*)tw;
+		DeleteTabPageCommand *cmd =
+		    new DeleteTabPageCommand( tr( "Delete Page %1 of %2" ).
+					      arg( dtw->pageTitle() ).arg( tw->name() ),
+					      formWindow(), tw, tw->currentPage() );
+		formWindow()->commandHistory()->addCommand( cmd );
+		cmd->execute();
+	    }
+	}
+    } else if ( ::qt_cast<QToolBox*>(w) ) {
+	QToolBox *tb = (QToolBox*)w;
+	if ( id == commands[ "add" ] ) {
+	    AddToolBoxPageCommand *cmd =
+		new AddToolBoxPageCommand( tr( "Add Page to %1" ).arg( tb->name() ),
+					   formWindow(),
+					   tb, "Page" );
+	    formWindow()->commandHistory()->addCommand( cmd );
+	    cmd->execute();
+	} else if ( id == commands[ "remove" ] ) {
+	    if ( tb->currentItem() ) {
+		DeleteToolBoxPageCommand *cmd =
+		    new DeleteToolBoxPageCommand( tr( "Delete Page %1 of %2" ).
+					  arg( tb->itemLabel( tb->currentIndex() ) ).
+					  arg( tb->name() ),
+					  formWindow(), tb, tb->currentItem() );
+		formWindow()->commandHistory()->addCommand( cmd );
+		cmd->execute();
+	    }
+	}
+    } else if ( ::qt_cast<QWidgetStack*>(w) ) {
+	QDesignerWidgetStack *ws = (QDesignerWidgetStack*)w;
+	if ( id == commands[ "add" ] ) {
+	    AddWidgetStackPageCommand *cmd =
+		new AddWidgetStackPageCommand( tr( "Add Page to %1" ).arg( ws->name() ),
+					       formWindow(), ws );
+	    formWindow()->commandHistory()->addCommand( cmd );
+	    cmd->execute();
+	} else if ( id == commands[ "remove" ] ) {
+	    if ( ws->visibleWidget() ) {
+		DeleteWidgetStackPageCommand *cmd =
+		    new DeleteWidgetStackPageCommand( tr( "Delete Page %1 of %2" ).
+						      arg( ws->currentPage() ).arg( ws->name() ),
+						      formWindow(), ws, ws->visibleWidget() );
+		formWindow()->commandHistory()->addCommand( cmd );
+		cmd->execute();
+	    }
+	} else if ( id == commands[ "nextpage" ] ) {
+	    int currentPage = w->property( "currentPage" ).toInt();
+	    QString pn( tr( "Raise next page of '%2'" ).arg( w->name() ) );
+	    SetPropertyCommand *cmd =
+		new SetPropertyCommand( pn, formWindow(), w, propertyEditor,
+					"currentPage", currentPage,
+					currentPage + 1, QString::null, QString::null );
+	    cmd->execute();
+	    formWindow()->commandHistory()->addCommand( cmd );
+	    MetaDataBase::setPropertyChanged( w, "currentPage", TRUE );
+	} else if ( id == commands[ "prevpage" ] ) {
+	    int currentPage = w->property( "currentPage" ).toInt();
+	    QString pn( tr( "Raise previous page of '%2'" ).arg( w->name() ) );
+	    SetPropertyCommand *cmd =
+		new SetPropertyCommand( pn, formWindow(), w, propertyEditor,
+					"currentPage", currentPage,
+					currentPage -1, QString::null, QString::null );
+	    cmd->execute();
+	    formWindow()->commandHistory()->addCommand( cmd );
+	    MetaDataBase::setPropertyChanged( w, "currentPage", TRUE );
+	}
+#ifdef QT_CONTAINER_CUSTOM_WIDGETS
+    } else if ( WidgetDatabase::
+		isCustomPluginWidget( WidgetDatabase::
+				      idFromClassName( WidgetFactory::classNameOf( w ) ) ) ) {
+	if ( id == commands[ "add" ] ) {
+	    AddContainerPageCommand *cmd =
+		new AddContainerPageCommand( tr( "Add Page to %1" ).arg( w->name() ),
+					     formWindow(), w, "Page" );
+	    formWindow()->commandHistory()->addCommand( cmd );
+	    cmd->execute();
+	} else if ( id == commands[ "remove" ] ) {
+	    QWidgetContainerInterfacePrivate *iface = containerWidgetInterface( w );
+	    if ( iface ) {
+		QString wClassName = WidgetFactory::classNameOf( w );
+		int index = iface->currentIndex( wClassName, w );
+		DeleteContainerPageCommand *cmd =
+		    new DeleteContainerPageCommand( tr( "Delete Page %1 of %2" ).
+						    arg( iface->pageLabel( wClassName,
+									   w, index ) ).
+						    arg( w->name() ),
+						    formWindow(), w, index );
+		formWindow()->commandHistory()->addCommand( cmd );
+		cmd->execute();
+		iface->release();
+	    }
+	} else if ( id == commands[ "rename" ] ) {
+	    QWidgetContainerInterfacePrivate *iface = containerWidgetInterface( w );
+	    if ( iface ) {
+		bool ok = FALSE;
+		QString wClassName = WidgetFactory::classNameOf( w );
+		int index = iface->currentIndex( wClassName, w );
+		QString text = QInputDialog::getText( tr("Page Title"), tr( "New page title" ),
+						      QLineEdit::Normal,
+						      iface->pageLabel( wClassName, w,
+								       index ),
+						      &ok, this );
+		if ( ok ) {
+		    RenameContainerPageCommand *cmd =
+			new RenameContainerPageCommand( tr( "Rename Page %1 to %2" ).
+							arg( iface->
+							     pageLabel( wClassName, w,
+									index ) ).
+							arg( text ), formWindow(),
+							w, index, text );
+		    formWindow()->commandHistory()->addCommand( cmd );
+		    cmd->execute();
+		}
+		iface->release();
+	    }
+	}
+#endif // QT_CONTAINER_CUSTOM_WIDGETS
+    }
+
+    if ( WidgetFactory::hasSpecialEditor( WidgetDatabase::
+				  idFromClassName( WidgetFactory::classNameOf( w ) ), w ) ) {
+	if ( id == commands[ "edit" ] )
+	    WidgetFactory::editWidget( WidgetDatabase::
+		       idFromClassName( WidgetFactory::classNameOf( w ) ), this, w, formWindow() );
+    }
+}
+
+void MainWindow::handleRMBSpecialCommands( int id, QMap<QString, int> &commands, FormWindow *fw )
+{
+    if ( ::qt_cast<QWizard*>(fw->mainContainer()) ) {
+	QWizard *wiz = (QWizard*)fw->mainContainer();
+	if ( id == commands[ "add" ] ) {
+	    AddWizardPageCommand *cmd =
+		new AddWizardPageCommand( tr( "Add Page to %1" ).arg( wiz->name() ),
+					  formWindow(), wiz, "WizardPage" );
+	    formWindow()->commandHistory()->addCommand( cmd );
+	    cmd->execute();
+	} else if ( id == commands[ "remove" ] ) {
+	    if ( wiz->currentPage() ) {
+		QDesignerWizard *dw = (QDesignerWizard*)wiz;
+		DeleteWizardPageCommand *cmd =
+		    new DeleteWizardPageCommand( tr( "Delete Page %1 of %2" ).
+						 arg( dw->pageTitle() ).arg( wiz->name() ),
+						 formWindow(), wiz,
+						 wiz->indexOf( wiz->currentPage() ) );
+		formWindow()->commandHistory()->addCommand( cmd );
+		cmd->execute();
+	    }
+	} else if ( id == commands[ "edit" ] ) {
+	    WizardEditor *e = new WizardEditor( this, wiz, fw );
+	    e->exec();
+	    delete e;
+	} else if ( id == commands[ "rename" ] ) {
+
+	    bool ok = FALSE;
+	    QDesignerWizard *dw = (QDesignerWizard*)wiz;
+	    QString text = QInputDialog::getText( tr("Page Title"), tr( "New page title" ),
+					  QLineEdit::Normal, dw->pageTitle(), &ok, this );
+	    if ( ok ) {
+		QString pn( tr( "Rename page %1 of %2" ).arg( dw->pageTitle() ).arg( wiz->name() ) );
+		RenameWizardPageCommand *cmd =
+		    new RenameWizardPageCommand( pn, formWindow()
+						 , wiz, wiz->indexOf( wiz->currentPage() ), text );
+		formWindow()->commandHistory()->addCommand( cmd );
+		cmd->execute();
+	    }
+	}
+    } else if ( ::qt_cast<QMainWindow*>(fw->mainContainer()) ) {
+	QMainWindow *mw = (QMainWindow*)fw->mainContainer();
+	if ( id == commands[ "add_toolbar" ] ) {
+	    AddToolBarCommand *cmd =
+		new AddToolBarCommand( tr( "Add Toolbar to '%1'" ).arg( formWindow()->name() ),
+				       formWindow(), mw );
+	    formWindow()->commandHistory()->addCommand( cmd );
+	    cmd->execute();
+	} else if ( id == commands[ "add_menu_item" ] ) {
+	    AddMenuCommand *cmd =
+		new AddMenuCommand( tr( "Add Menu to '%1'" ).arg( formWindow()->name() ),
+				    formWindow(), mw );
+	    formWindow()->commandHistory()->addCommand( cmd );
+	    cmd->execute();
+	}
+    }
+}
+
+void MainWindow::clipboardChanged()
+{
+    QString text( qApp->clipboard()->text() );
+    QString start( "<!DOCTYPE UI-SELECTION>" );
+    actionEditPaste->setEnabled( text.left( start.length() ) == start );
+}
+
+void MainWindow::selectionChanged()
+{
+    layoutChilds = FALSE;
+    layoutSelected = FALSE;
+    breakLayout = FALSE;
+    if ( !formWindow() ) {
+	actionEditCut->setEnabled( FALSE );
+	actionEditCopy->setEnabled( FALSE );
+	actionEditDelete->setEnabled( FALSE );
+	actionEditAdjustSize->setEnabled( FALSE );
+	actionEditHLayout->setEnabled( FALSE );
+	actionEditVLayout->setEnabled( FALSE );
+	actionEditSplitHorizontal->setEnabled( FALSE );
+	actionEditSplitVertical->setEnabled( FALSE );
+	actionEditGridLayout->setEnabled( FALSE );
+	actionEditBreakLayout->setEnabled( FALSE );
+	actionEditLower->setEnabled( FALSE );
+	actionEditRaise->setEnabled( FALSE );
+	actionEditAdjustSize->setEnabled( FALSE );
+	return;
+    }
+
+    int selectedWidgets = formWindow()->numSelectedWidgets();
+    bool enable = selectedWidgets > 0;
+    actionEditCut->setEnabled( enable );
+    actionEditCopy->setEnabled( enable );
+    actionEditDelete->setEnabled( enable );
+    actionEditLower->setEnabled( enable );
+    actionEditRaise->setEnabled( enable );
+
+    actionEditAdjustSize->setEnabled( FALSE );
+    actionEditSplitHorizontal->setEnabled( FALSE );
+    actionEditSplitVertical->setEnabled( FALSE );
+
+    enable = FALSE;
+    QWidgetList widgets = formWindow()->selectedWidgets();
+    if ( selectedWidgets > 1 ) {
+	int unlaidout = 0;
+	int laidout = 0;
+	for ( QWidget *w = widgets.first(); w; w = widgets.next() ) {
+	    if ( !w->parentWidget() || WidgetFactory::layoutType( w->parentWidget() ) == WidgetFactory::NoLayout )
+		unlaidout++;
+	    else
+		laidout++;
+	}
+	actionEditHLayout->setEnabled( unlaidout > 1 );
+	actionEditVLayout->setEnabled( unlaidout > 1 );
+	actionEditSplitHorizontal->setEnabled( unlaidout > 1 );
+	actionEditSplitVertical->setEnabled( unlaidout > 1 );
+	actionEditGridLayout->setEnabled( unlaidout > 1 );
+	actionEditBreakLayout->setEnabled( laidout > 0 );
+	actionEditAdjustSize->setEnabled( laidout > 0 );
+	layoutSelected = unlaidout > 1;
+	breakLayout = laidout > 0;
+    } else if ( selectedWidgets == 1 ) {
+	QWidget *w = widgets.first();
+	bool isContainer = WidgetDatabase::isContainer( WidgetDatabase::idFromClassName( WidgetFactory::classNameOf( w ) ) ) ||
+			   w == formWindow()->mainContainer();
+	actionEditAdjustSize->setEnabled( !w->parentWidget() ||
+					  WidgetFactory::layoutType( w->parentWidget() ) == WidgetFactory::NoLayout );
+
+	if ( !isContainer ) {
+	    actionEditHLayout->setEnabled( FALSE );
+	    actionEditVLayout->setEnabled( FALSE );
+	    actionEditGridLayout->setEnabled( FALSE );
+	    if ( w->parentWidget() && WidgetFactory::layoutType( w->parentWidget() ) != WidgetFactory::NoLayout ) {
+		actionEditBreakLayout->setEnabled( !isAToolBarChild( w ) );
+		breakLayout = TRUE;
+	    } else {
+		actionEditBreakLayout->setEnabled( FALSE );
+	    }
+	} else {
+	    if ( WidgetFactory::layoutType( w ) == WidgetFactory::NoLayout ) {
+		if ( !formWindow()->hasInsertedChildren( w ) ) {
+		    actionEditHLayout->setEnabled( FALSE );
+		    actionEditVLayout->setEnabled( FALSE );
+		    actionEditGridLayout->setEnabled( FALSE );
+		    actionEditBreakLayout->setEnabled( FALSE );
+		} else {
+		    actionEditHLayout->setEnabled( TRUE );
+		    actionEditVLayout->setEnabled( TRUE );
+		    actionEditGridLayout->setEnabled( TRUE );
+		    actionEditBreakLayout->setEnabled( FALSE );
+		    layoutChilds = TRUE;
+		}
+		if ( w->parentWidget() && WidgetFactory::layoutType( w->parentWidget() ) != WidgetFactory::NoLayout ) {
+		    actionEditBreakLayout->setEnabled( !isAToolBarChild( w ) );
+		    breakLayout = TRUE;
+		}
+	    } else {
+		actionEditHLayout->setEnabled( FALSE );
+		actionEditVLayout->setEnabled( FALSE );
+		actionEditGridLayout->setEnabled( FALSE );
+		actionEditBreakLayout->setEnabled( !isAToolBarChild( w ) );
+		breakLayout = TRUE;
+	    }
+	}
+    } else if ( selectedWidgets == 0 ) {
+	actionEditAdjustSize->setEnabled( TRUE );
+	QWidget *w = formWindow()->mainContainer();
+	if ( WidgetFactory::layoutType( w ) == WidgetFactory::NoLayout ) {
+	    if ( !formWindow()->hasInsertedChildren( w ) ) {
+		actionEditHLayout->setEnabled( FALSE );
+		actionEditVLayout->setEnabled( FALSE );
+		actionEditGridLayout->setEnabled( FALSE );
+		actionEditBreakLayout->setEnabled( FALSE );
+	    } else {
+		actionEditHLayout->setEnabled( TRUE );
+		actionEditVLayout->setEnabled( TRUE );
+		actionEditGridLayout->setEnabled( TRUE );
+		actionEditBreakLayout->setEnabled( FALSE );
+		layoutChilds = TRUE;
+	    }
+	} else {
+	    actionEditHLayout->setEnabled( FALSE );
+	    actionEditVLayout->setEnabled( FALSE );
+	    actionEditGridLayout->setEnabled( FALSE );
+	    actionEditBreakLayout->setEnabled( TRUE );
+	    breakLayout = TRUE;
+	}
+    } else {
+	actionEditHLayout->setEnabled( FALSE );
+	actionEditVLayout->setEnabled( FALSE );
+	actionEditGridLayout->setEnabled( FALSE );
+	actionEditBreakLayout->setEnabled( FALSE );
+    }
+}
+
+static QString fixArgs( const QString &s2 )
+{
+    QString s = s2;
+    return s.replace( ',', ';' );
+}
+
+void MainWindow::writeConfig()
+{
+    QSettings config;
+
+    // No search path for unix, only needs application name
+    config.insertSearchPath( QSettings::Windows, "/Trolltech" );
+
+    QString keybase = DesignerApplication::settingsKey();
+
+    if (savePluginPaths) {
+	QStringList pluginPaths = QApplication::libraryPaths();
+	config.writeEntry( keybase + "PluginPaths", pluginPaths );
+    }
+    config.writeEntry( keybase + "RestoreWorkspace", restoreConfig );
+    config.writeEntry( keybase + "SplashScreen", splashScreen );
+    config.writeEntry( keybase + "ShowStartDialog", shStartDialog );
+    config.writeEntry( keybase + "FileFilter", fileFilter );
+    config.writeEntry( keybase + "TemplatePath", templPath );
+    config.writeEntry( keybase + "RecentlyOpenedFiles", recentlyFiles );
+    config.writeEntry( keybase + "RecentlyOpenedProjects", recentlyProjects );
+    config.writeEntry( keybase + "DatabaseAutoEdit", databaseAutoEdit );
+
+    config.writeEntry( keybase + "AutoSave/Enabled", autoSaveEnabled );
+    config.writeEntry( keybase + "AutoSave/Interval", autoSaveInterval );
+
+    config.writeEntry( keybase + "Grid/Snap", snGrid );
+    config.writeEntry( keybase + "Grid/Show", sGrid );
+    config.writeEntry( keybase + "Grid/x", grid().x() );
+    config.writeEntry( keybase + "Grid/y", grid().y() );
+    config.writeEntry( keybase + "LastToolPage",
+		       toolBox->itemLabel( toolBox->currentIndex() ) );
+
+    config.writeEntry( keybase + "Background/UsePixmap", backPix );
+    config.writeEntry( keybase + "Background/Color", (int)qworkspace->backgroundColor().rgb() );
+    if ( qworkspace->backgroundPixmap() )
+	qworkspace->backgroundPixmap()->save( QDir::home().absPath() + "/.designer/" + "background.xpm", "PNG" );
+
+    config.writeEntry( keybase + "Geometries/MainwindowX", x() );
+    config.writeEntry( keybase + "Geometries/MainwindowY", y() );
+    config.writeEntry( keybase + "Geometries/MainwindowWidth", width() );
+    config.writeEntry( keybase + "Geometries/MainwindowHeight", height() );
+    config.writeEntry( keybase + "Geometries/MainwindowMaximized", isMaximized() );
+    config.writeEntry( keybase + "Geometries/PropertyEditorX", propertyEditor->parentWidget()->x() );
+    config.writeEntry( keybase + "Geometries/PropertyEditorY", propertyEditor->parentWidget()->y() );
+    config.writeEntry( keybase + "Geometries/PropertyEditorWidth", propertyEditor->parentWidget()->width() );
+    config.writeEntry( keybase + "Geometries/PropertyEditorHeight", propertyEditor->parentWidget()->height() );
+    config.writeEntry( keybase + "Geometries/HierarchyViewX", hierarchyView->parentWidget()->x() );
+    config.writeEntry( keybase + "Geometries/HierarchyViewY", hierarchyView->parentWidget()->y() );
+    config.writeEntry( keybase + "Geometries/HierarchyViewWidth", hierarchyView->parentWidget()->width() );
+    config.writeEntry( keybase + "Geometries/HierarchyViewHeight", hierarchyView->parentWidget()->height() );
+    config.writeEntry( keybase + "Geometries/WorkspaceX", wspace->parentWidget()->x() );
+    config.writeEntry( keybase + "Geometries/WorkspaceY", wspace->parentWidget()->y() );
+    config.writeEntry( keybase + "Geometries/WorkspaceWidth", wspace->parentWidget()->width() );
+    config.writeEntry( keybase + "Geometries/WorkspaceHeight", wspace->parentWidget()->height() );
+
+    config.writeEntry( keybase + "View/TextLabels", usesTextLabel() );
+    config.writeEntry( keybase + "View/BigIcons", usesBigPixmaps() );
+
+    QString mwlKey = "MainwindowLayout";
+    if ( singleProjectMode() )
+	mwlKey += "S";
+    QString mainWindowLayout;
+    QTextStream ts( &mainWindowLayout, IO_WriteOnly );
+    ts << *this;
+    config.writeEntry( keybase + mwlKey, mainWindowLayout );
+
+
+    QPtrList<MetaDataBase::CustomWidget> *lst = MetaDataBase::customWidgets();
+    config.writeEntry( keybase + "CustomWidgets/num", (int)lst->count() );
+    int j = 0;
+    QDir::home().mkdir( ".designer" );
+    for ( MetaDataBase::CustomWidget *w = lst->first(); w; w = lst->next() ) {
+	QStringList l;
+	l << w->className;
+	l << w->includeFile;
+	l << QString::number( (int)w->includePolicy );
+	l << QString::number( w->sizeHint.width() );
+	l << QString::number( w->sizeHint.height() );
+	l << QString::number( w->lstSignals.count() );
+	for ( QValueList<QCString>::ConstIterator it = w->lstSignals.begin(); it != w->lstSignals.end(); ++it )
+	    l << QString( fixArgs( *it ) );
+	l << QString::number( w->lstSlots.count() );
+	for ( QValueList<MetaDataBase::Function>::ConstIterator it2 = w->lstSlots.begin(); it2 != w->lstSlots.end(); ++it2 ) {
+	    l << fixArgs( (*it2).function );
+	    l << (*it2).access;
+	}
+	l << QString::number( w->lstProperties.count() );
+	for ( QValueList<MetaDataBase::Property>::ConstIterator it3 = w->lstProperties.begin(); it3 != w->lstProperties.end(); ++it3 ) {
+	    l << (*it3).property;
+	    l << (*it3).type;
+	}
+	l << QString::number( size_type_to_int( w->sizePolicy.horData() ) );
+	l << QString::number( size_type_to_int( w->sizePolicy.verData() ) );
+	l << QString::number( (int)w->isContainer );
+	config.writeEntry( keybase + "CustomWidgets/Widget" + QString::number( j++ ), l, ',' );
+	w->pixmap->save( QDir::home().absPath() + "/.designer/" + w->className, "XPM" );
+    }
+
+    QStringList l;
+    for ( QAction *a = commonWidgetsPage.first(); a; a = commonWidgetsPage.next() )
+	l << a->text();
+    config.writeEntry( keybase + "ToolBox/CommonWidgets", l );
+}
+
+static QString fixArgs2( const QString &s2 )
+{
+    QString s = s2;
+    return s.replace( ';', ',' );
+}
+
+void MainWindow::readConfig()
+{
+    QString keybase = DesignerApplication::settingsKey();
+    QSettings config;
+    config.insertSearchPath( QSettings::Windows, "/Trolltech" );
+
+    bool ok;
+    bool readPreviousConfig = FALSE;
+    QString backPixName( QDir::home().absPath() + "/.designer/" + "background.xpm" );
+    restoreConfig = config.readBoolEntry( keybase + "RestoreWorkspace", TRUE, &ok );
+    if ( !ok ) {
+	keybase = DesignerApplication::oldSettingsKey();
+	restoreConfig = config.readBoolEntry( keybase + "RestoreWorkspace", TRUE, &ok );
+	if ( !ok ) {
+	    if ( oWindow ) {
+		oWindow->shuttingDown();
+		( (QDockWindow*)oWindow->parent() )->hide();
+	    }
+	    QPixmap pix;
+	    pix.load( backPixName );
+	    if ( !pix.isNull() )
+		qworkspace->setBackgroundPixmap( pix );
+	    return;
+	}
+	readPreviousConfig = TRUE;
+    }
+    if ( !readPreviousConfig ) {
+	fileFilter = config.readEntry( keybase + "FileFilter", fileFilter );
+	templPath = config.readEntry( keybase + "TemplatePath", QString::null );
+	databaseAutoEdit = config.readBoolEntry( keybase + "DatabaseAutoEdit", databaseAutoEdit );
+	shStartDialog = config.readBoolEntry( keybase + "ShowStartDialog", shStartDialog );
+	autoSaveEnabled = config.readBoolEntry( keybase + "AutoSave/Enabled", autoSaveEnabled );
+	autoSaveInterval = config.readNumEntry( keybase + "AutoSave/Interval", autoSaveInterval );
+    }
+
+    if ( restoreConfig || readPreviousConfig ) {
+	QString s = config.readEntry( keybase + "LastToolPage" );
+	for ( int i = 0; i < toolBox->count(); ++i ) {
+	    if ( toolBox->itemLabel(i) == s ) {
+		toolBox->setCurrentIndex( i );
+		break;
+	    }
+	}
+	// We know that the oldSettingsKey() will return 3.1
+	if ( keybase == DesignerApplication::oldSettingsKey() ) {
+	    if (keybase.contains("3.1"))
+		recentlyFiles = config.readListEntry( keybase + "RecentlyOpenedFiles", ',' );
+	    else
+		recentlyFiles = config.readListEntry(keybase + "RecentlyOpenedFiles");
+
+	    if ( recentlyFiles.count() == 1 && recentlyFiles[0].isNull() )
+		recentlyFiles.clear();
+	    if (keybase.contains("3.1"))
+		recentlyProjects = config.readListEntry( keybase + "RecentlyOpenedProjects", ',' );
+	    else
+		recentlyProjects = config.readListEntry( keybase + "RecentlyOpenedProjects");
+	    if ( recentlyProjects.count() == 1 && recentlyProjects[0].isNull() )
+		recentlyProjects.clear();
+	} else {
+	    recentlyFiles = config.readListEntry( keybase + "RecentlyOpenedFiles" );
+	    recentlyProjects = config.readListEntry( keybase + "RecentlyOpenedProjects" );
+	}
+
+	backPix = config.readBoolEntry( keybase + "Background/UsePixmap", TRUE ) | readPreviousConfig;
+	if ( backPix ) {
+	    QPixmap pix;
+	    pix.load( backPixName );
+	    if ( !pix.isNull() )
+		qworkspace->setBackgroundPixmap( pix );
+	} else {
+	    qworkspace->setBackgroundColor( QColor( (QRgb)config.readNumEntry( keybase + "Background/Color" ) ) );
+	}
+
+	if ( !readPreviousConfig ) {
+	    splashScreen = config.readBoolEntry( keybase + "SplashScreen", TRUE );
+
+	    sGrid = config.readBoolEntry( keybase + "Grid/Show", TRUE );
+	    snGrid = config.readBoolEntry( keybase + "Grid/Snap", TRUE );
+	    grd.setX( config.readNumEntry( keybase + "Grid/x", 10 ) );
+	    grd.setY( config.readNumEntry( keybase + "Grid/y", 10 ) );
+
+	    if ( !config.readBoolEntry( DesignerApplication::settingsKey() + "Geometries/MainwindowMaximized", FALSE ) ) {
+		QRect r( pos(), size() );
+		r.setX( config.readNumEntry( keybase + "Geometries/MainwindowX", r.x() ) );
+		r.setY( config.readNumEntry( keybase + "Geometries/MainwindowY", r.y() ) );
+		r.setWidth( config.readNumEntry( keybase + "Geometries/MainwindowWidth", r.width() ) );
+		r.setHeight( config.readNumEntry( keybase + "Geometries/MainwindowHeight", r.height() ) );
+
+		QRect desk = QApplication::desktop()->geometry();
+		QRect inter = desk.intersect( r );
+		resize( r.size() );
+		if ( inter.width() * inter.height() > ( r.width() * r.height() / 20 ) ) {
+		    move( r.topLeft() );
+		}
+	    }
+	    setUsesTextLabel( config.readBoolEntry( keybase + "View/TextLabels", FALSE ) );
+	    setUsesBigPixmaps( FALSE /*config.readBoolEntry( "BigIcons", FALSE )*/ ); // ### disabled for now
+	}
+    }
+    int num = config.readNumEntry( keybase + "CustomWidgets/num" );
+    for ( int j = 0; j < num; ++j ) {
+	MetaDataBase::CustomWidget *w = new MetaDataBase::CustomWidget;
+	QStringList l = config.readListEntry( keybase + "CustomWidgets/Widget" + QString::number( j ), ',' );
+	w->className = l[ 0 ];
+	w->includeFile = l[ 1 ];
+	w->includePolicy = (MetaDataBase::CustomWidget::IncludePolicy)l[ 2 ].toInt();
+	w->sizeHint.setWidth( l[ 3 ].toInt() );
+	w->sizeHint.setHeight( l[ 4 ].toInt() );
+	uint c = 5;
+	if ( l.count() > c ) {
+	    int numSignals = l[ c ].toInt();
+	    c++;
+	    for ( int i = 0; i < numSignals; ++i, c++ )
+		w->lstSignals.append( fixArgs2( l[ c ] ).latin1() );
+	}
+	if ( l.count() > c ) {
+	    int numSlots = l[ c ].toInt();
+	    c++;
+	    for ( int i = 0; i < numSlots; ++i ) {
+		MetaDataBase::Function slot;
+		slot.function = fixArgs2( l[ c ] );
+		c++;
+		slot.access = l[ c ];
+		c++;
+		w->lstSlots.append( slot );
+	    }
+	}
+	if ( l.count() > c ) {
+	    int numProperties = l[ c ].toInt();
+	    c++;
+	    for ( int i = 0; i < numProperties; ++i ) {
+		MetaDataBase::Property prop;
+		prop.property = l[ c ];
+		c++;
+		prop.type = l[ c ];
+		c++;
+		w->lstProperties.append( prop );
+	    }
+	} if ( l.count() > c ) {
+	    QSizePolicy::SizeType h, v;
+	     h = int_to_size_type( l[ c++ ].toInt() );
+	     v = int_to_size_type( l[ c++ ].toInt() );
+	     w->sizePolicy = QSizePolicy( h, v );
+	}
+	if ( l.count() > c ) {
+	    w->isContainer = (bool)l[ c++ ].toInt();
+	}
+	w->pixmap = new QPixmap( QPixmap::fromMimeSource( QDir::home().absPath() + "/.designer/" + w->className ) );
+	MetaDataBase::addCustomWidget( w );
+    }
+    if ( num > 0 )
+	rebuildCustomWidgetGUI();
+
+    if ( !restoreConfig )
+	return;
+
+#ifndef Q_WS_MAC
+    /* I'm sorry to make this not happen on the Mac, but it seems to hang somewhere deep
+       in QLayout, it gets into a very large loop - and seems it has to do with clever
+       things the designer does ###Sam */
+    QApplication::sendPostedEvents();
+#endif
+
+    if ( !readPreviousConfig ) {
+	QString mwlKey = "MainwindowLayout";
+	if ( singleProjectMode() )
+	    mwlKey += "S";
+	QString mainWindowLayout = config.readEntry( keybase + mwlKey );
+	QTextStream ts( &mainWindowLayout, IO_ReadOnly );
+	ts >> *this;
+    }
+    if ( readPreviousConfig && oWindow ) {
+	oWindow->shuttingDown();
+	( (QDockWindow*)oWindow->parent() )->hide();
+    }
+
+    rebuildCustomWidgetGUI();
+
+    QStringList l = config.readListEntry( keybase + "ToolBox/CommonWidgets" );
+    if ( !l.isEmpty() ) {
+	QPtrList<QAction> lst;
+	commonWidgetsPage.clear();
+	for ( QStringList::ConstIterator it = l.begin(); it != l.end(); ++it ) {
+	    for ( QAction *a = toolActions.first(); a; a = toolActions.next() ) {
+		if ( *it == a->text() ) {
+		    lst.append( a );
+		    break;
+		}
+	    }
+	}
+	if ( lst != commonWidgetsPage ) {
+	    commonWidgetsPage = lst;
+	    rebuildCommonWidgetsToolBoxPage();
+	}
+    }
+}
+
+HierarchyView *MainWindow::objectHierarchy() const
+{
+    if ( !hierarchyView )
+	( (MainWindow*)this )->setupHierarchyView();
+    return hierarchyView;
+}
+
+QPopupMenu *MainWindow::setupNormalHierarchyMenu( QWidget *parent )
+{
+    QPopupMenu *menu = new QPopupMenu( parent );
+
+    actionEditCut->addTo( menu );
+    actionEditCopy->addTo( menu );
+    actionEditPaste->addTo( menu );
+    actionEditDelete->addTo( menu );
+
+    return menu;
+}
+
+QPopupMenu *MainWindow::setupTabWidgetHierarchyMenu( QWidget *parent, const char *addSlot, const char *removeSlot )
+{
+    QPopupMenu *menu = new QPopupMenu( parent );
+
+    menu->insertItem( tr( "Add Page" ), parent, addSlot );
+    menu->insertItem( tr( "Delete Page" ), parent, removeSlot );
+    menu->insertSeparator();
+    actionEditCut->addTo( menu );
+    actionEditCopy->addTo( menu );
+    actionEditPaste->addTo( menu );
+    actionEditDelete->addTo( menu );
+
+    return menu;
+}
+
+void MainWindow::closeEvent( QCloseEvent *e )
+{
+    if ( singleProject ) {
+	hide();
+	e->ignore();
+	return;
+    }
+
+    QWidgetList windows = qWorkspace()->windowList();
+    QWidgetListIt wit( windows );
+    while ( wit.current() ) {
+	QWidget *w = wit.current();
+	++wit;
+	if ( ::qt_cast<FormWindow*>(w) ) {
+	    if ( ( (FormWindow*)w )->formFile()->editor() )
+		windows.removeRef( ( (FormWindow*)w )->formFile()->editor() );
+	    if ( ( (FormWindow*)w )->formFile()->formWindow() )
+		windows.removeRef( ( (FormWindow*)w )->formFile()->formWindow() );
+	    if ( !( (FormWindow*)w )->formFile()->close() ) {
+		e->ignore();
+		return;
+	    }
+	} else if ( ::qt_cast<SourceEditor*>(w) ) {
+	    if ( !( (SourceEditor*)w )->close() ) {
+		e->ignore();
+		return;
+	    }
+	}
+	w->close();
+    }
+
+    QMapConstIterator<QAction*, Project*> it = projects.begin();
+    while( it != projects.end() ) {
+	Project *pro = it.data();
+	++it;
+	if ( pro->isModified() ) {
+	    switch ( QMessageBox::warning( this, tr( "Save Project Settings" ),
+					   tr( "Save changes to '%1'?" ).arg( pro->fileName() ),
+					   tr( "&Yes" ), tr( "&No" ), tr( "&Cancel" ), 0, 2 ) ) {
+	    case 0: // save
+		pro->save();
+		break;
+	    case 1: // don't save
+		break;
+	    case 2: // cancel
+		e->ignore();
+		return;
+	    default:
+		break;
+	    }
+	}
+    }
+
+    writeConfig();
+    hide();
+    e->accept();
+
+    if ( client ) {
+	QDir home( QDir::homeDirPath() );
+	home.remove( ".designerpid" );
+    }
+}
+
+Workspace *MainWindow::workspace() const
+{
+    if ( !wspace )
+	( (MainWindow*)this )->setupWorkspace();
+    return wspace;
+}
+
+PropertyEditor *MainWindow::propertyeditor() const
+{
+    if ( !propertyEditor )
+	( (MainWindow*)this )->setupPropertyEditor();
+    return propertyEditor;
+}
+
+ActionEditor *MainWindow::actioneditor() const
+{
+    if ( !actionEditor )
+	( (MainWindow*)this )->setupActionEditor();
+    return actionEditor;
+}
+
+bool MainWindow::openEditor( QWidget *w, FormWindow *f )
+{
+    if ( f && !f->project()->isCpp() && !WidgetFactory::isPassiveInteractor( w ) ) {
+	QString defSignal = WidgetFactory::defaultSignal( w );
+	if ( defSignal.isEmpty() ) {
+	    editSource();
+	} else {
+	    QString s = QString( w->name() ) + "_" + defSignal;
+	    LanguageInterface *iface = MetaDataBase::languageInterface( f->project()->language() );
+	    if ( iface ) {
+		QStrList sigs = iface->signalNames( w );
+		QString fullSignal;
+		for ( int i = 0; i < (int)sigs.count(); ++i ) {
+		    QString sig = sigs.at( i );
+		    if ( sig.left( sig.find( '(' ) ) == defSignal ) {
+			fullSignal = sig;
+			break;
+		    }
+		}
+
+		if ( !fullSignal.isEmpty() ) {
+		    QString signl = fullSignal;
+		    fullSignal = fullSignal.mid( fullSignal.find( '(' ) + 1 );
+		    fullSignal.remove( (int)fullSignal.length() - 1, 1 );
+		    fullSignal = iface->createArguments( fullSignal.simplifyWhiteSpace() );
+		    s += "(" + fullSignal + ")";
+		    if ( !MetaDataBase::hasFunction( f, s.latin1() ) )
+			MetaDataBase::addFunction( f, s.latin1(), "", "public", "slot",
+						   f->project()->language(), "void" );
+		    s = s.left( s.find( '(' ) ).latin1();
+		    if ( !MetaDataBase::hasConnection( f, w, defSignal.latin1(), f->mainContainer(), s.latin1() ) ) {
+			MetaDataBase::Connection conn;
+			conn.sender = w;
+			conn.receiver = f->mainContainer();
+			conn.signal = signl;
+			conn.slot = s;
+			AddConnectionCommand *cmd =
+			    new AddConnectionCommand( tr( "Add connection" ), f, conn );
+			f->commandHistory()->addCommand( cmd );
+			cmd->execute();
+			f->formFile()->setModified( TRUE );
+		    }
+		}
+	    }
+	    editFunction( s, TRUE );
+	}
+	return TRUE;
+    }
+    if ( WidgetFactory::hasSpecialEditor( WidgetDatabase::
+					  idFromClassName( WidgetFactory::classNameOf( w ) ), w ) ) {
+	statusBar()->message( tr( "Edit %1..." ).arg( w->className() ) );
+	WidgetFactory::editWidget( WidgetDatabase::idFromClassName( WidgetFactory::classNameOf( w ) ),
+				   this, w, formWindow() );
+	statusBar()->clear();
+	return TRUE;
+    }
+
+    const QMetaProperty* text = w->metaObject()->property( w->metaObject()->findProperty( "text", TRUE ), TRUE );
+    const QMetaProperty* title = w->metaObject()->property( w->metaObject()->findProperty( "title", TRUE ), TRUE );
+    if ( text && text->designable(w) ) {
+	bool ok = FALSE;
+	bool oldDoWrap = FALSE;
+	if ( ::qt_cast<QLabel*>(w) ) {
+	    int align = w->property( "alignment" ).toInt();
+	    if ( align & WordBreak )
+		oldDoWrap = TRUE;
+	}
+	bool doWrap = oldDoWrap;
+
+	QString text;
+	if ( ::qt_cast<QTextEdit*>(w) || ::qt_cast<QLabel*>(w) || ::qt_cast<QButton*>(w) ) {
+	    text = MultiLineEditor::getText( this, w->property( "text" ).toString(),
+					     !::qt_cast<QButton*>(w), &doWrap );
+	    ok = !text.isNull();
+	} else {
+	    text = QInputDialog::getText( tr("Text"), tr( "New text" ),
+				  QLineEdit::Normal, w->property("text").toString(), &ok, this );
+	}
+	if ( ok ) {
+	    if ( oldDoWrap != doWrap ) {
+		QString pn( tr( "Set 'wordwrap' of '%1'" ).arg( w->name() ) );
+		SetPropertyCommand *cmd = new SetPropertyCommand( pn, formWindow(), w, propertyEditor,
+								  "wordwrap", QVariant( oldDoWrap, 0 ),
+								  QVariant( doWrap, 0 ), QString::null, QString::null );
+		cmd->execute();
+		formWindow()->commandHistory()->addCommand( cmd );
+		MetaDataBase::setPropertyChanged( w, "wordwrap", TRUE );
+	    }
+
+	    QString pn( tr( "Set the 'text' of '%1'" ).arg( w->name() ) );
+	    SetPropertyCommand *cmd = new SetPropertyCommand( pn, formWindow(), w, propertyEditor,
+							      "text", w->property( "text" ),
+							      text, QString::null, QString::null );
+	    cmd->execute();
+	    formWindow()->commandHistory()->addCommand( cmd );
+	    MetaDataBase::setPropertyChanged( w, "text", TRUE );
+	}
+	return TRUE;
+    }
+    if ( title && title->designable(w) ) {
+	bool ok = FALSE;
+	QString text;
+	text = QInputDialog::getText( tr("Title"), tr( "New title" ), QLineEdit::Normal, w->property("title").toString(), &ok, this );
+	if ( ok ) {
+	    QString pn( tr( "Set the 'title' of '%2'" ).arg( w->name() ) );
+	    SetPropertyCommand *cmd = new SetPropertyCommand( pn, formWindow(), w, propertyEditor,
+							      "title", w->property( "title" ),
+							      text, QString::null, QString::null );
+	    cmd->execute();
+	    formWindow()->commandHistory()->addCommand( cmd );
+	    MetaDataBase::setPropertyChanged( w, "title", TRUE );
+	}
+	return TRUE;
+    }
+
+    if ( !WidgetFactory::isPassiveInteractor( w ) )
+	editSource();
+
+    return TRUE;
+}
+
+void MainWindow::rebuildCustomWidgetGUI()
+{
+    customWidgetToolBar->clear();
+    customWidgetMenu->clear();
+    customWidgetToolBar2->clear();
+    int count = 0;
+
+    QPtrListIterator<QAction> it( toolActions );
+    QAction *action;
+    while ( ( action = it.current() ) ) {
+	++it;
+	if ( ( (WidgetAction*)action )->group() == "Custom Widgets" )
+	    delete action;
+    }
+
+    QPtrList<MetaDataBase::CustomWidget> *lst = MetaDataBase::customWidgets();
+
+    actionToolsCustomWidget->addTo( customWidgetMenu );
+    customWidgetMenu->insertSeparator();
+
+    for ( MetaDataBase::CustomWidget *w = lst->first(); w; w = lst->next() ) {
+	WidgetAction* a = new WidgetAction( "Custom Widgets", actionGroupTools, QString::number( w->id ).latin1() );
+	a->setToggleAction( TRUE );
+	a->setText( w->className );
+	a->setIconSet( *w->pixmap );
+	a->setStatusTip( tr( "Insert a " +w->className + " (custom widget)" ) );
+	a->setWhatsThis( tr("<b>" + w->className + " (custom widget)</b>"
+			    "<p>Click <b>Edit Custom Widgets...</b> in the <b>Tools|Custom</b> menu to "
+			    "add and change custom widgets. You can add properties as well as "
+			    "signals and slots to integrate them into Qt Designer, "
+			    "and provide a pixmap which will be used to represent the widget on the form.</p>") );
+
+	a->addTo( customWidgetToolBar );
+	a->addTo( customWidgetToolBar2 );
+	a->addTo( customWidgetMenu );
+	count++;
+    }
+    QWidget *wid;
+    customWidgetToolBar2->setStretchableWidget( ( wid = new QWidget( customWidgetToolBar2 ) ) );
+    wid->setBackgroundMode( customWidgetToolBar2->backgroundMode() );
+
+    if ( count == 0 )
+	customWidgetToolBar->hide();
+    else if ( customWidgetToolBar->isVisible() )
+	customWidgetToolBar->show();
+}
+
+void MainWindow::rebuildCommonWidgetsToolBoxPage()
+{
+    toolBox->setUpdatesEnabled( FALSE );
+    commonWidgetsToolBar->setUpdatesEnabled( FALSE );
+    commonWidgetsToolBar->clear();
+    for ( QAction *a = commonWidgetsPage.first(); a; a = commonWidgetsPage.next() )
+	a->addTo( commonWidgetsToolBar );
+    QWidget *w;
+    commonWidgetsToolBar->setStretchableWidget( ( w = new QWidget( commonWidgetsToolBar ) ) );
+    w->setBackgroundMode( commonWidgetsToolBar->backgroundMode() );
+    toolBox->setUpdatesEnabled( TRUE );
+    commonWidgetsToolBar->setUpdatesEnabled( TRUE );
+}
+
+bool MainWindow::isCustomWidgetUsed( MetaDataBase::CustomWidget *wid )
+{
+    QWidgetList windows = qWorkspace()->windowList();
+    for ( QWidget *w = windows.first(); w; w = windows.next() ) {
+	if ( ::qt_cast<FormWindow*>(w) ) {
+	    if ( ( (FormWindow*)w )->isCustomWidgetUsed( wid ) )
+		return TRUE;
+	}
+    }
+    return FALSE;
+}
+
+void MainWindow::setGrid( const QPoint &p )
+{
+    if ( p == grd )
+	return;
+    grd = p;
+    QWidgetList windows = qWorkspace()->windowList();
+    for ( QWidget *w = windows.first(); w; w = windows.next() ) {
+	if ( !::qt_cast<FormWindow*>(w) )
+	    continue;
+	( (FormWindow*)w )->mainContainer()->update();
+    }
+}
+
+void MainWindow::setShowGrid( bool b )
+{
+    if ( b == sGrid )
+	return;
+    sGrid = b;
+    QWidgetList windows = qWorkspace()->windowList();
+    for ( QWidget *w = windows.first(); w; w = windows.next() ) {
+	if ( !::qt_cast<FormWindow*>(w) )
+	    continue;
+	( (FormWindow*)w )->mainContainer()->update();
+    }
+}
+
+void MainWindow::setSnapGrid( bool b )
+{
+    if ( b == snGrid )
+	return;
+    snGrid = b;
+}
+
+QString MainWindow::documentationPath() const
+{
+    return QString( qInstallPathDocs() ) + "/html/";
+}
+
+void MainWindow::windowsMenuActivated( int id )
+{
+    QWidget* w = qworkspace->windowList().at( id );
+    if ( w )
+	w->setFocus();
+}
+
+void MainWindow::projectSelected( QAction *a )
+{
+    a->setOn( TRUE );
+    if ( currentProject )
+	currentProject->setActive( FALSE );
+    Project *p = *projects.find( a );
+    p->setActive( TRUE );
+    if ( currentProject == p )
+	return;
+    currentProject = p;
+    if ( wspace )
+	wspace->setCurrentProject( currentProject );
+}
+
+void MainWindow::openProject( const QString &fn )
+{
+    for ( QMap<QAction*, Project*>::ConstIterator it = projects.begin(); it != projects.end(); ++it ) {
+	if ( (*it)->fileName() == fn ) {
+	    projectSelected( it.key() );
+	    return;
+	}
+    }
+    QApplication::setOverrideCursor( waitCursor );
+    Project *pro = new Project( fn, "", projectSettingsPluginManager );
+    pro->setModified( FALSE );
+    QAction *a = new QAction( pro->projectName(), pro->projectName(), 0, actionGroupProjects, 0, TRUE );
+    projects.insert( a, pro );
+    projectSelected( a );
+    QApplication::restoreOverrideCursor();
+}
+
+void MainWindow::checkTempFiles()
+{
+    QString s = QDir::homeDirPath() + "/.designer";
+    QString baseName = s+ "/saved-form-";
+    if ( !QFile::exists( baseName + "1.ui" ) )
+	return;
+    DesignerApplication::closeSplash();
+    QDir d( s );
+    d.setNameFilter( "*.ui" );
+    QStringList lst = d.entryList();
+    QApplication::restoreOverrideCursor();
+    bool load = QMessageBox::information( this, tr( "Restoring the Last Session" ),
+					  tr( "Qt Designer found some temporary saved files, which were\n"
+					      "written when Qt Designer crashed last time. Do you want to\n"
+					      "load these files?" ), tr( "&Yes" ), tr( "&No" ) ) == 0;
+    QApplication::setOverrideCursor( waitCursor );
+    for ( QStringList::ConstIterator it = lst.begin(); it != lst.end(); ++it ) {
+	if ( load )
+	    openFormWindow( s + "/" + *it, FALSE );
+	d.remove( *it );
+    }
+}
+
+void MainWindow::showDialogHelp()
+{
+    QWidget *w = (QWidget*)sender();
+    w = w->topLevelWidget();
+
+    QString link = documentationPath() + "/designer-manual-13.html#";
+
+    if ( ::qt_cast<NewFormBase*>(w) || ::qt_cast<StartDialogBase*>(w) ) // own doc for startdialog?
+	link += "dialog-file-new";
+    else if ( ::qt_cast<CreateTemplate*>(w) )
+	link += "dialog-file-create-template";
+    else if ( ::qt_cast<EditFunctionsBase*>(w) )
+	link += "dialog-edit-functions";
+//     else if ( ::qt_cast<ConnectionViewerBase*>(w) )
+    else if ( w->inherits("ConnectionViewerBase") )
+ 	link += "dialog-view-connections";
+    else if ( ::qt_cast<FormSettingsBase*>(w) )
+	link += "dialog-edit-form-settings";
+    else if ( ::qt_cast<Preferences*>(w) )
+	link += "dialog-edit-preferences";
+    else if ( ::qt_cast<PixmapCollectionEditor*>(w) )
+	link += "dialog-image-collection";
+//    else if ( ::qt_cast<DatabaseConnectionBase*>(w) )
+    else if ( w->inherits( "DatabaseConnectionBase" ) )
+	link += "dialog-edit-database-connections";
+    else if ( ::qt_cast<ProjectSettingsBase*>(w) )
+	link += "dialog-project-settings";
+    else if ( ::qt_cast<FindDialog*>(w) )
+	link += "dialog-find-text";
+    else if ( ::qt_cast<ReplaceDialog*>(w) )
+	link += "dialog-replace-text";
+    else if ( ::qt_cast<GotoLineDialog*>(w) )
+	link += "dialog-go-to-line";
+//    else if ( ::qt_cast<ConnectionEditorBase*>(w) )
+    else if ( w->inherits("ConnectionEditorBase") )
+	link += "dialog-edit-connections";
+    else if ( ::qt_cast<CustomWidgetEditorBase*>(w) )
+	link += "dialog-edit-custom-widgets";
+    else if ( ::qt_cast<PaletteEditorBase*>(w) )
+	link += "dialog-edit-palette";
+    else if ( ::qt_cast<ListBoxEditorBase*>(w) )
+	link += "dialog-edit-listbox";
+    else if ( ::qt_cast<ListViewEditorBase*>(w) )
+	link += "dialog-edit-listview";
+    else if ( ::qt_cast<IconViewEditorBase*>(w) )
+	link += "dialog-edit-iconview";
+    else if ( ::qt_cast<TableEditorBase*>(w) )
+	link += "dialog-edit-table";
+    else if ( ::qt_cast<MultiLineEditor*>(w) )
+	link += "dialog-text";
+
+    else {
+	QMessageBox::information( this, tr( "Help" ),
+				  tr( "There is no help available for this dialog at the moment." ) );
+	return;
+    }
+
+    assistant->showPage( link );
+}
+
+void MainWindow::setupActionManager()
+{
+    actionPluginManager = new QPluginManager<ActionInterface>( IID_Action, QApplication::libraryPaths(), pluginDirectory() );
+
+    QStringList lst = actionPluginManager->featureList();
+    for ( QStringList::ConstIterator ait = lst.begin(); ait != lst.end(); ++ait ) {
+	ActionInterface *iface = 0;
+	actionPluginManager->queryInterface( *ait, &iface );
+	if ( !iface )
+	    continue;
+
+	iface->connectTo( desInterface );
+	QAction *a = iface->create( *ait, this );
+	if ( !a )
+	    continue;
+
+	QString grp = iface->group( *ait );
+	if ( grp.isEmpty() )
+	    grp = "3rd party actions";
+	QPopupMenu *menu = 0;
+	QToolBar *tb = 0;
+
+	if ( !( menu = (QPopupMenu*)child( grp.latin1(), "QPopupMenu" ) ) ) {
+	    menu = new QPopupMenu( this, grp.latin1() );
+	    menuBar()->insertItem( tr( grp ), menu );
+	}
+	if ( !( tb = (QToolBar*)child( grp.latin1(), "QToolBar" ) ) ) {
+	    tb = new QToolBar( this, grp.latin1() );
+	    tb->setCloseMode( QDockWindow::Undocked );
+	    addToolBar( tb, grp );
+	}
+
+	if ( iface->location( *ait, ActionInterface::Menu ) )
+	    a->addTo( menu );
+	if ( iface->location( *ait, ActionInterface::Toolbar ) )
+	    a->addTo( tb );
+
+	iface->release();
+    }
+}
+
+void MainWindow::editFunction( const QString &func, bool rereadSource )
+{
+    if ( !formWindow() )
+	return;
+
+    if ( formWindow()->formFile()->codeFileState() != FormFile::Ok )
+	if ( !formWindow()->formFile()->setupUihFile(FALSE) )
+	    return;
+
+    QString lang = currentProject->language();
+    if ( !MetaDataBase::hasEditor( lang ) ) {
+	QMessageBox::information( this, tr( "Edit Source" ),
+				  tr( "There is no plugin for editing " + lang + " code installed!\n"
+				      "Note: Plugins are not available in static Qt configurations." ) );
+	return;
+    }
+
+    for ( SourceEditor *e = sourceEditors.first(); e; e = sourceEditors.next() ) {
+	if ( e->language() == lang && e->formWindow() == formWindow() ) {
+	    e->show();
+	    e->setFunction( func );
+	    return;
+	}
+    }
+
+    createSourceEditor( formWindow(), formWindow()->project(), lang, func, rereadSource );
+}
+
+void MainWindow::setupRecentlyFilesMenu()
+{
+    recentlyFilesMenu->clear();
+    int id = 0;
+    for ( QStringList::ConstIterator it = recentlyFiles.begin(); it != recentlyFiles.end(); ++it ) {
+	recentlyFilesMenu->insertItem( *it, id );
+	id++;
+    }
+}
+
+void MainWindow::setupRecentlyProjectsMenu()
+{
+    recentlyProjectsMenu->clear();
+    int id = 0;
+    for ( QStringList::ConstIterator it = recentlyProjects.begin(); it != recentlyProjects.end(); ++it ) {
+	recentlyProjectsMenu->insertItem( *it, id );
+	id++;
+    }
+}
+
+QPtrList<DesignerProject> MainWindow::projectList() const
+{
+    QPtrList<DesignerProject> list;
+    QMapConstIterator<QAction*, Project*> it = projects.begin();
+
+    while( it != projects.end() ) {
+	Project *p = it.data();
+	++it;
+	list.append( p->iFace() );
+    }
+
+    return list;
+}
+
+QStringList MainWindow::projectNames() const
+{
+    QStringList res;
+    for ( QMap<QAction*, Project* >::ConstIterator it = projects.begin(); it != projects.end(); ++it )
+	res << (*it)->projectName();
+    return res;
+}
+
+QStringList MainWindow::projectFileNames() const
+{
+    QStringList res;
+    for ( QMap<QAction*, Project* >::ConstIterator it = projects.begin(); it != projects.end(); ++it )
+	res << (*it)->makeRelative( (*it)->fileName() );
+    return res;
+}
+
+Project *MainWindow::findProject( const QString &projectName ) const
+{
+    for ( QMap<QAction*, Project* >::ConstIterator it = projects.begin(); it != projects.end(); ++it ) {
+	if ( (*it)->projectName() == projectName )
+	    return *it;
+    }
+    return 0;
+}
+
+void MainWindow::setCurrentProject( Project *pro )
+{
+    for ( QMap<QAction*, Project* >::ConstIterator it = projects.begin(); it != projects.end(); ++it ) {
+	if ( *it == pro ) {
+	    projectSelected( it.key() );
+	    return;
+	}
+    }
+}
+
+void MainWindow::setCurrentProjectByFilename( const QString& proFilename )
+{
+    for ( QMap<QAction*, Project* >::ConstIterator it = projects.begin(); it != projects.end(); ++it ) {
+	if ( (*it)->makeRelative( (*it)->fileName() ) == proFilename ) {
+	    projectSelected( it.key() );
+	    return;
+	}
+    }
+}
+
+
+void MainWindow::recentlyFilesMenuActivated( int id )
+{
+    if ( id != -1 ) {
+	if ( !QFile::exists( *recentlyFiles.at( id ) ) ) {
+	    QMessageBox::warning( this, tr( "Open File" ),
+				  tr( "Could not open '%1'. File does not exist." ).
+				  arg( *recentlyFiles.at( id ) ) );
+	    recentlyFiles.remove( recentlyFiles.at( id ) );
+	    return;
+	}
+	fileOpen( "", "", *recentlyFiles.at( id ) );
+	QString fn( *recentlyFiles.at( id ) );
+	addRecentlyOpened( fn, recentlyFiles );
+    }
+}
+
+void MainWindow::recentlyProjectsMenuActivated( int id )
+{
+    if ( id != -1 ) {
+	if ( !QFile::exists( *recentlyProjects.at( id ) ) ) {
+	    QMessageBox::warning( this, tr( "Open Project" ),
+				  tr( "Could not open '%1'. File does not exist." ).
+				  arg( *recentlyProjects.at( id ) ) );
+	    recentlyProjects.remove( recentlyProjects.at( id ) );
+	    return;
+	}
+	openProject( *recentlyProjects.at( id ) );
+	QString fn( *recentlyProjects.at( id ) );
+	addRecentlyOpened( fn, recentlyProjects );
+    }
+}
+
+void MainWindow::addRecentlyOpened( const QString &fn, QStringList &lst )
+{
+    QFileInfo fi( fn );
+    fi.convertToAbs();
+    QString f = fi.filePath();
+    if ( lst.find( f ) != lst.end() )
+	lst.remove( f );
+    if ( lst.count() >= 10 )
+	lst.pop_back();
+    lst.prepend( f );
+}
+
+TemplateWizardInterface * MainWindow::templateWizardInterface( const QString& className )
+{
+    TemplateWizardInterface* iface = 0;
+    templateWizardPluginManager->queryInterface( className, & iface );
+    return iface;
+}
+
+void MainWindow::setupPluginManagers()
+{
+    editorPluginManager = new QPluginManager<EditorInterface>( IID_Editor, QApplication::libraryPaths(), pluginDirectory() );
+    MetaDataBase::setEditor( editorPluginManager->featureList() );
+
+    templateWizardPluginManager =
+	new QPluginManager<TemplateWizardInterface>( IID_TemplateWizard, QApplication::libraryPaths(), pluginDirectory() );
+
+    MetaDataBase::setupInterfaceManagers( pluginDirectory() );
+    preferencePluginManager =
+	new QPluginManager<PreferenceInterface>( IID_Preference, QApplication::libraryPaths(), pluginDirectory() );
+    projectSettingsPluginManager =
+	new QPluginManager<ProjectSettingsInterface>( IID_ProjectSettings, QApplication::libraryPaths(), pluginDirectory() );
+    sourceTemplatePluginManager =
+	new QPluginManager<SourceTemplateInterface>( IID_SourceTemplate, QApplication::libraryPaths(), pluginDirectory() );
+
+    if ( preferencePluginManager ) {
+	QStringList lst = preferencePluginManager->featureList();
+	for ( QStringList::ConstIterator it = lst.begin(); it != lst.end(); ++it ) {
+	    PreferenceInterface *i = 0;
+	    preferencePluginManager->queryInterface( *it, &i );
+	    if ( !i )
+		continue;
+	    i->connectTo( designerInterface() );
+	    PreferenceInterface::Preference *pf = i->preference();
+	    if ( pf )
+		addPreferencesTab( pf->tab, pf->title, pf->receiver, pf->init_slot, pf->accept_slot );
+	    i->deletePreferenceObject( pf );
+
+	    i->release();
+	}
+    }
+    if ( projectSettingsPluginManager ) {
+	QStringList lst = projectSettingsPluginManager->featureList();
+	for ( QStringList::ConstIterator it = lst.begin(); it != lst.end(); ++it ) {
+	    ProjectSettingsInterface *i = 0;
+	    projectSettingsPluginManager->queryInterface( *it, &i );
+	    if ( !i )
+		continue;
+	    i->connectTo( designerInterface() );
+
+	    ProjectSettingsInterface::ProjectSettings *pf = i->projectSetting();
+	    if ( pf )
+		addProjectTab( pf->tab, pf->title, pf->receiver, pf->init_slot, pf->accept_slot );
+	    i->deleteProjectSettingsObject( pf );
+	    i->release();
+	}
+    }
+}
+
+void MainWindow::addPreferencesTab( QWidget *tab, const QString &title, QObject *receiver, const char *init_slot, const char *accept_slot )
+{
+    Tab t;
+    t.w = tab;
+    t.title = title;
+    t.receiver = receiver;
+    t.init_slot = init_slot;
+    t.accept_slot = accept_slot;
+    preferenceTabs << t;
+}
+
+void MainWindow::addProjectTab( QWidget *tab, const QString &title, QObject *receiver, const char *init_slot, const char *accept_slot )
+{
+    Tab t;
+    t.w = tab;
+    t.title = title;
+    t.receiver = receiver;
+    t.init_slot = init_slot;
+    t.accept_slot = accept_slot;
+    projectTabs << t;
+}
+
+void MainWindow::setModified( bool b, QWidget *window )
+{
+    QWidget *w = window;
+    while ( w ) {
+	if ( ::qt_cast<FormWindow*>(w) ) {
+	    ( (FormWindow*)w )->modificationChanged( b );
+	    return;
+	} else if ( ::qt_cast<SourceEditor*>(w) ) {
+	    FormWindow *fw = ( (SourceEditor*)w )->formWindow();
+	    if ( fw && !fw->isFake() ) {
+		//fw->commandHistory()->setModified( b );
+		//fw->modificationChanged( b );
+		fw->formFile()->setModified( b, FormFile::WFormCode );
+		wspace->update( fw->formFile() );
+	    } else {
+		wspace->update();
+	    }
+	    return;
+	}
+	w = w->parentWidget( TRUE );
+    }
+}
+
+void MainWindow::editorClosed( SourceEditor *e )
+{
+    sourceEditors.take( sourceEditors.findRef( e ) );
+}
+
+void MainWindow::functionsChanged()
+{
+    updateFunctionsTimer->start( 0, TRUE );
+}
+
+void MainWindow::doFunctionsChanged()
+{
+    for ( SourceEditor *e = sourceEditors.first(); e; e = sourceEditors.next() )
+	e->refresh( FALSE );
+    hierarchyView->formDefinitionView()->refresh();
+}
+
+void MainWindow::updateFunctionList()
+{
+    if ( !qWorkspace()->activeWindow() || !::qt_cast<SourceEditor*>(qWorkspace()->activeWindow()) )
+	return;
+    SourceEditor *se = (SourceEditor*)qWorkspace()->activeWindow();
+    se->save();
+    hierarchyView->formDefinitionView()->refresh();
+    if ( !currentProject->isCpp() && se->formWindow() ) {
+	LanguageInterface *iface = MetaDataBase::languageInterface( currentProject->language() );
+	if ( !iface )
+	    return;
+	QValueList<LanguageInterface::Connection> conns;
+	iface->connections( se->text(), &conns );
+	MetaDataBase::setupConnections( se->formWindow(), conns );
+	propertyEditor->eventList()->setup();
+    }
+}
+
+void MainWindow::updateWorkspace()
+{
+    wspace->setCurrentProject( currentProject );
+}
+
+void MainWindow::showDebugStep( QObject *o, int line )
+{
+    for ( SourceEditor *e = sourceEditors.first(); e; e = sourceEditors.next() )
+	e->clearStep();
+    if ( !o || line == -1 )
+	return;
+    showSourceLine( o, line, Step );
+}
+
+void MainWindow::showStackFrame( QObject *o, int line )
+{
+    if ( !o || line == -1 )
+	return;
+    showSourceLine( o, line, StackFrame );
+}
+
+void MainWindow::showErrorMessage( QObject *o, int errorLine, const QString &errorMessage )
+{
+    if ( o ) {
+	errorLine--; // ######
+	QValueList<uint> l;
+	l << ( errorLine + 1 );
+	QStringList l2;
+	l2 << errorMessage;
+	QObjectList ol;
+	ol.append( o );
+	QStringList ll;
+	ll << currentProject->locationOfObject( o );
+	oWindow->setErrorMessages( l2, l, TRUE, ll, ol );
+	showSourceLine( o, errorLine, Error );
+    }
+}
+
+void MainWindow::finishedRun()
+{
+    inDebugMode = FALSE;
+    previewing = FALSE;
+    debuggingForms.clear();
+    enableAll( TRUE );
+    for ( SourceEditor *e = sourceEditors.first(); e; e = sourceEditors.next() ) {
+	if ( e->project() == currentProject )
+	    e->editorInterface()->setMode( EditorInterface::Editing );
+	e->clearStackFrame();
+    }
+    outputWindow()->clearErrorMessages();
+}
+
+void MainWindow::enableAll( bool enable )
+{
+    menuBar()->setEnabled( enable );
+    QObjectList *l = queryList( "QDockWindow" );
+    for ( QObject *o = l->first(); o; o = l->next() ) {
+	if ( o == wspace->parentWidget() ||
+	     o == oWindow->parentWidget() ||
+	     o == hierarchyView->parentWidget() )
+	    continue;
+	( (QWidget*)o )->setEnabled( enable );
+    }
+    delete l;
+}
+
+void MainWindow::showSourceLine( QObject *o, int line, LineMode lm )
+{
+    QWidgetList windows = qworkspace->windowList();
+    for ( QWidget *w = windows.first(); w; w = windows.next() ) {
+	FormWindow *fw = 0;
+	SourceEditor *se = 0;
+	SourceFile *sf = 0;
+	if ( ::qt_cast<FormWindow*>(w) ) {
+	    fw = (FormWindow*)w;
+	} else if ( ::qt_cast<SourceEditor*>(w) ) {
+	    se = (SourceEditor*)w;
+	    if ( !se->object() )
+		continue;
+	    if ( se->formWindow() )
+		fw = se->formWindow();
+	    else
+		sf = se->sourceFile();
+	}
+
+	if ( fw ) {
+	    if ( fw->project() != currentProject )
+		continue;
+	    if ( qstrcmp( fw->name(), o->name() ) == 0 ||
+		 fw->isFake() && currentProject->objectForFakeForm( fw ) == o ) {
+		if ( se ) {
+		    switch ( lm ) {
+		    case Error:
+			se->editorInterface()->setError( line );
+			break;
+		    case Step:
+			se->editorInterface()->setStep( line );
+			break;
+		    case StackFrame:
+			se->editorInterface()->setStackFrame( line );
+			break;
+		    }
+		    return;
+		} else {
+		    fw->showNormal();
+		    fw->setFocus();
+		    lastActiveFormWindow = fw;
+		    qApp->processEvents();
+		    se = editSource();
+		    if ( se ) {
+			switch ( lm ) {
+			case Error:
+			    se->editorInterface()->setError( line );
+			    break;
+			case Step:
+			    se->editorInterface()->setStep( line );
+			    break;
+			case StackFrame:
+			    se->editorInterface()->setStackFrame( line );
+			    break;
+			}
+			return;
+		    }
+		}
+	    }
+	} else if ( se ) {
+	    if ( o != sf )
+		continue;
+	    switch ( lm ) {
+	    case Error:
+		se->editorInterface()->setError( line );
+		break;
+	    case Step:
+		se->editorInterface()->setStep( line );
+		break;
+	    case StackFrame:
+		se->editorInterface()->setStackFrame( line );
+		break;
+	    }
+	    return;
+	}
+    }
+
+    if ( ::qt_cast<SourceFile*>(o) ) {
+	for ( QPtrListIterator<SourceFile> sources = currentProject->sourceFiles();
+	      sources.current(); ++sources ) {
+	    SourceFile* f = sources.current();
+	    if ( f == o ) {
+		SourceEditor *se = editSource( f );
+		if ( se ) {
+		    switch ( lm ) {
+		    case Error:
+			se->editorInterface()->setError( line );
+			break;
+		    case Step:
+			se->editorInterface()->setStep( line );
+			break;
+		    case StackFrame:
+			se->editorInterface()->setStackFrame( line );
+			break;
+		    }
+		}
+		return;
+	    }
+	}
+    }
+
+    FormFile *ff = currentProject->fakeFormFileFor( o );
+    FormWindow *fw = 0;
+    if ( ff )
+	fw = ff->formWindow();
+
+    if ( !fw && !qwf_forms ) {
+	qWarning( "MainWindow::showSourceLine: qwf_forms is NULL!" );
+	return;
+    }
+
+    mblockNewForms = TRUE;
+    if ( !fw )
+	openFormWindow( currentProject->makeAbsolute( *qwf_forms->find( (QWidget*)o ) ) );
+    else
+	fw->formFile()->showEditor( FALSE );
+    qApp->processEvents(); // give all views the chance to get the formwindow
+    SourceEditor *se = editSource();
+    if ( se ) {
+	switch ( lm ) {
+	case Error:
+	    se->editorInterface()->setError( line );
+	    break;
+	case Step:
+	    se->editorInterface()->setStep( line );
+	    break;
+	case StackFrame:
+	    se->editorInterface()->setStackFrame( line );
+	    break;
+	}
+    }
+    mblockNewForms = FALSE;
+}
+
+
+QObject *MainWindow::findRealObject( QObject *o )
+{
+    QWidgetList windows = qWorkspace()->windowList();
+    for ( QWidget *w = windows.first(); w; w = windows.next() ) {
+	if ( ::qt_cast<FormWindow*>(w) && QString( w->name() ) == QString( o->name() ) )
+	    return w;
+	else if ( ::qt_cast<SourceEditor*>(w) && ( (SourceEditor*)w )->formWindow() &&
+		  QString( ( (SourceEditor*)w )->formWindow()->name() ) == QString( o->name() ) )
+	    return w;
+	else if ( ::qt_cast<SourceFile*>(w) && ( (SourceEditor*)w )->sourceFile() &&
+		  ( (SourceEditor*)w )->sourceFile() == o )
+	    return o;
+    }
+    return 0;
+}
+
+void MainWindow::formNameChanged( FormWindow *fw )
+{
+    for ( SourceEditor *e = sourceEditors.first(); e; e = sourceEditors.next() ) {
+	if ( e->object() == fw )
+	    e->refresh( TRUE );
+	if ( e->project() == fw->project() )
+	    e->resetContext();
+    }
+}
+
+void MainWindow::breakPointsChanged()
+{
+    if ( !inDebugMode )
+	return;
+    if ( !qWorkspace()->activeWindow() || !::qt_cast<SourceEditor*>(qWorkspace()->activeWindow()) )
+	return;
+    SourceEditor *e = (SourceEditor*)qWorkspace()->activeWindow();
+    if ( !e->object() || !e->project() )
+	return;
+    if ( e->project() != currentProject )
+	return;
+
+    if ( !interpreterPluginManager ) {
+	interpreterPluginManager =
+	    new QPluginManager<InterpreterInterface>( IID_Interpreter,
+						      QApplication::libraryPaths(),
+						      "/qsa" );
+    }
+
+    InterpreterInterface *iiface = 0;
+    if ( interpreterPluginManager ) {
+	QString lang = currentProject->language();
+	iiface = 0;
+	interpreterPluginManager->queryInterface( lang, &iiface );
+	if ( !iiface )
+	    return;
+    }
+
+    e->saveBreakPoints();
+
+    for ( QObject *o = debuggingForms.first(); o; o = debuggingForms.next() ) {
+	if ( qstrcmp( o->name(), e->object()->name() ) == 0 ) {
+	    iiface->setBreakPoints( o, MetaDataBase::breakPoints( e->object() ) );
+	    break;
+	}
+    }
+
+    for ( e = sourceEditors.first(); e; e = sourceEditors.next() ) {
+	if ( e->project() == currentProject && e->sourceFile() ) {
+	    QValueList<uint> bps = MetaDataBase::breakPoints( e->sourceFile() );
+	    iiface->setBreakPoints( e->object(), bps );
+	}
+    }
+
+    iiface->release();
+}
+
+int MainWindow::currentLayoutDefaultSpacing() const
+{
+    if ( ( (MainWindow*)this )->formWindow() )
+	return ( (MainWindow*)this )->formWindow()->layoutDefaultSpacing();
+    return BOXLAYOUT_DEFAULT_SPACING;
+}
+
+int MainWindow::currentLayoutDefaultMargin() const
+{
+    if ( ( (MainWindow*)this )->formWindow() )
+	return ( (MainWindow*)this )->formWindow()->layoutDefaultMargin();
+    return BOXLAYOUT_DEFAULT_MARGIN;
+}
+
+void MainWindow::saveAllBreakPoints()
+{
+    for ( SourceEditor *e = sourceEditors.first(); e; e = sourceEditors.next() ) {
+	e->save();
+	e->saveBreakPoints();
+    }
+}
+
+void MainWindow::resetBreakPoints()
+{
+    for ( SourceEditor *e = sourceEditors.first(); e; e = sourceEditors.next() )
+	e->resetBreakPoints();
+}
+
+SourceFile *MainWindow::sourceFile()
+{
+    for ( SourceEditor *e = sourceEditors.first(); e; e = sourceEditors.next() ) {
+	if ( qworkspace->activeWindow() == e ) {
+	    if ( e->sourceFile() )
+		return e->sourceFile();
+	}
+    }
+    return 0;
+}
+
+bool MainWindow::openProjectSettings( Project *pro )
+{
+    ProjectSettings dia( pro, this, 0, TRUE );
+    SenderObject *senderObject = new SenderObject( designerInterface() );
+    QValueList<Tab>::ConstIterator it;
+    for ( it = projectTabs.begin(); it != projectTabs.end(); ++it ) {
+	Tab t = *it;
+	if ( t.title != pro->language() )
+	    continue;
+	dia.tabWidget->addTab( t.w, t.title );
+	if ( t.receiver ) {
+	    connect( dia.buttonOk, SIGNAL( clicked() ), senderObject, SLOT( emitAcceptSignal() ) );
+	    connect( senderObject, SIGNAL( acceptSignal( QUnknownInterface * ) ), t.receiver, t.accept_slot );
+	    connect( senderObject, SIGNAL( initSignal( QUnknownInterface * ) ), t.receiver, t.init_slot );
+	    senderObject->emitInitSignal();
+	    disconnect( senderObject, SIGNAL( initSignal( QUnknownInterface * ) ), t.receiver, t.init_slot );
+	}
+    }
+
+    if ( singleProject )
+	dia.tabWidget->setTabEnabled( dia.tabSettings, FALSE );
+
+    int res = dia.exec();
+
+    delete senderObject;
+
+    for ( it = projectTabs.begin(); it != projectTabs.end(); ++it ) {
+	Tab t = *it;
+	dia.tabWidget->removePage( t.w );
+	t.w->reparent( 0, QPoint(0,0), FALSE );
+    }
+
+    return res == QDialog::Accepted;
+}
+
+void MainWindow::popupProjectMenu( const QPoint &pos )
+{
+    projectMenu->exec( pos );
+}
+
+QStringList MainWindow::sourceTemplates() const
+{
+    return sourceTemplatePluginManager->featureList();
+}
+
+SourceTemplateInterface* MainWindow::sourceTemplateInterface( const QString& templ )
+{
+    SourceTemplateInterface *iface = 0;
+    sourceTemplatePluginManager->queryInterface( templ, &iface);
+    return iface;
+}
+
+QString MainWindow::whatsThisFrom( const QString &key )
+{
+    if ( menuHelpFile.isEmpty() ) {
+	QString fn( documentationPath() );
+	fn += "/designer-manual-11.html";
+	QFile f( fn );
+	if ( f.open( IO_ReadOnly ) ) {
+	    QTextStream ts( &f );
+	    menuHelpFile = ts.read();
+	}
+    }
+
+    int i = menuHelpFile.find( key );
+    if ( i == -1 )
+	return QString::null;
+    int start = i;
+    int end = i;
+    start = menuHelpFile.findRev( "<li>", i ) + 4;
+    end = menuHelpFile.find( '\n', i ) - 1;
+    return menuHelpFile.mid( start, end - start + 1 );
+}
+
+void MainWindow::setSingleProject( Project *pro )
+{
+    if ( eProject ) {
+	Project *pro = eProject;
+	pro->save();
+	QWidgetList windows = qWorkspace()->windowList();
+	qWorkspace()->blockSignals( TRUE );
+	QWidgetListIt wit( windows );
+	while ( wit.current() ) {
+	    QWidget *w = wit.current();
+	    ++wit;
+	    if ( ::qt_cast<FormWindow*>(w) ) {
+		if ( ( (FormWindow*)w )->project() == pro ) {
+		    if ( ( (FormWindow*)w )->formFile()->editor() )
+			windows.removeRef( ( (FormWindow*)w )->formFile()->editor() );
+		    ( (FormWindow*)w )->formFile()->close();
+		}
+	    } else if ( ::qt_cast<SourceEditor*>(w) ) {
+		( (SourceEditor*)w )->close();
+	    }
+	}
+	hierarchyView->clear();
+	windows = qWorkspace()->windowList();
+	qWorkspace()->blockSignals( FALSE );
+	currentProject = 0;
+	updateUndoRedo( FALSE, FALSE, QString::null, QString::null );
+    }
+
+    singleProject = TRUE;
+    projects.clear();
+    QAction *a = new QAction( tr( pro->name() ), tr( pro->name() ), 0,
+			      actionGroupProjects, 0, TRUE );
+    eProject = pro;
+    projects.insert( a, eProject );
+    a->setOn( TRUE );
+    actionGroupProjects->removeFrom( projectMenu );
+    actionGroupProjects->removeFrom( projectToolBar );
+    currentProject = eProject;
+    currentProject->designerCreated();
+}
+
+void MainWindow::shuttingDown()
+{
+    outputWindow()->shuttingDown();
+}
+
+void MainWindow::showGUIStuff( bool b )
+{
+    if ( (bool)guiStuffVisible == b )
+	return;
+    guiStuffVisible = b;
+    if ( !b ) {
+	setAppropriate( (QDockWindow*)toolBox->parentWidget(), FALSE );
+	toolBox->parentWidget()->hide();
+	for ( QToolBar *tb = widgetToolBars.first(); tb; tb = widgetToolBars.next() ) {
+	    tb->hide();
+	    setAppropriate( tb, FALSE );
+	}
+	propertyEditor->setPropertyEditorEnabled( FALSE );
+	setAppropriate( layoutToolBar, FALSE );
+	layoutToolBar->hide();
+	setAppropriate( toolsToolBar, FALSE );
+	toolsToolBar->hide();
+	menubar->removeItem( toolsMenuId );
+	menubar->removeItem( toolsMenuId + 1 );
+	menubar->removeItem( toolsMenuId + 2 );
+	disconnect( this, SIGNAL( hasActiveForm(bool) ), actionEditAccels, SLOT( setEnabled(bool) ) );
+	disconnect( this, SIGNAL( hasActiveForm(bool) ), actionEditFunctions, SLOT( setEnabled(bool) ) );
+	disconnect( this, SIGNAL( hasActiveForm(bool) ), actionEditConnections, SLOT( setEnabled(bool) ) );
+	disconnect( this, SIGNAL( hasActiveForm(bool) ), actionEditSource, SLOT( setEnabled(bool) ) );
+	disconnect( this, SIGNAL( hasActiveForm(bool) ), actionEditFormSettings, SLOT( setEnabled(bool) ) );
+	actionEditFormSettings->setEnabled( FALSE );
+	actionEditSource->setEnabled( FALSE );
+	actionEditConnections->setEnabled( FALSE );
+	actionEditFunctions->setEnabled( FALSE );
+	actionEditAccels->setEnabled( FALSE );
+	( (QDockWindow*)propertyEditor->parentWidget() )->
+	    setCaption( tr( "Signal Handlers" ) );
+	actionGroupNew->removeFrom( fileMenu );
+	actionGroupNew->removeFrom( projectToolBar );
+	actionFileSave->removeFrom( fileMenu );
+	actionFileSave->removeFrom( projectToolBar );
+	actionFileExit->removeFrom( fileMenu );
+	actionNewFile->addTo( fileMenu );
+	actionNewFile->addTo( projectToolBar );
+	actionFileSave->addTo( fileMenu );
+	actionFileSave->addTo( projectToolBar );
+	actionFileExit->addTo( fileMenu );
+    } else {
+	setAppropriate( (QDockWindow*)toolBox->parentWidget(), TRUE );
+	toolBox->parentWidget()->show();
+	for ( QToolBar *tb = widgetToolBars.first(); tb; tb = widgetToolBars.next() ) {
+	    setAppropriate( tb, TRUE );
+	    tb->hide();
+	}
+	propertyEditor->setPropertyEditorEnabled( TRUE );
+	setAppropriate( layoutToolBar, TRUE );
+	layoutToolBar->show();
+	setAppropriate( toolsToolBar, TRUE );
+	toolsToolBar->show();
+	menubar->insertItem( tr( "&Tools" ), toolsMenu, toolsMenuId, toolsMenuIndex );
+	menubar->insertItem( tr( "&Layout" ), layoutMenu, toolsMenuId + 1, toolsMenuIndex + 1 );
+	menubar->insertItem( tr( "&Preview" ), previewMenu, toolsMenuId + 2, toolsMenuIndex + 2 );
+	connect( this, SIGNAL( hasActiveForm(bool) ), actionEditAccels, SLOT( setEnabled(bool) ) );
+	connect( this, SIGNAL( hasActiveForm(bool) ), actionEditFunctions, SLOT( setEnabled(bool) ) );
+	connect( this, SIGNAL( hasActiveForm(bool) ), actionEditConnections, SLOT( setEnabled(bool) ) );
+	connect( this, SIGNAL( hasActiveForm(bool) ), actionEditSource, SLOT( setEnabled(bool) ) );
+	connect( this, SIGNAL( hasActiveForm(bool) ), actionEditFormSettings, SLOT( setEnabled(bool) ) );
+	actionEditFormSettings->setEnabled( TRUE );
+	actionEditSource->setEnabled( TRUE );
+	actionEditConnections->setEnabled( TRUE );
+	actionEditFunctions->setEnabled( TRUE );
+	actionEditAccels->setEnabled( TRUE );
+	( (QDockWindow*)propertyEditor->parentWidget() )->
+	    setCaption( tr( "Property Editor/Signal Handlers" ) );
+	actionFileSave->removeFrom( fileMenu );
+	actionFileSave->removeFrom( projectToolBar );
+	actionFileExit->removeFrom( fileMenu );
+	actionGroupNew->addTo( fileMenu );
+	actionGroupNew->addTo( projectToolBar );
+	actionFileSave->addTo( fileMenu );
+	actionFileSave->addTo( projectToolBar );
+	actionFileExit->addTo( fileMenu );
+    }
+}
+
+void MainWindow::setEditorsReadOnly( bool b )
+{
+    editorsReadOnly = b;
+}
+
+void MainWindow::setPluginDirectory( const QString &pd )
+{
+    pluginDir = pd;
+    if ( !qwf_plugin_dir )
+	qwf_plugin_dir = new QString( pd );
+    else
+	*qwf_plugin_dir = pd;
+}
+
+void MainWindow::toggleSignalHandlers( bool show )
+{
+    if ( sSignalHandlers == show )
+	return;
+    sSignalHandlers = show;
+    propertyEditor->setSignalHandlersEnabled( show );
+}
diff -Nru qt-x11-free-3.3.3.orig/tools/designer/designer/mainwindow.h qt-x11-free-3.3.3/tools/designer/designer/mainwindow.h
--- qt-x11-free-3.3.3.orig/tools/designer/designer/mainwindow.h	2004-08-22 13:20:57.659911219 +0200
+++ qt-x11-free-3.3.3/tools/designer/designer/mainwindow.h	2004-08-22 13:23:07.038437774 +0200
@@ -107,6 +107,7 @@
 
     QPopupMenu *setupNormalHierarchyMenu( QWidget *parent );
     QPopupMenu *setupTabWidgetHierarchyMenu( QWidget *parent, const char *addSlot, const char *removeSlot );
+    static const int POPUP_REMOVE_PAGE_ID = 1;
 
     FormWindow *openFormWindow( const QString &fn, bool validFileName = TRUE, FormFile *ff = 0 );
     bool isCustomWidgetUsed( MetaDataBase::CustomWidget *w );
